# 타입 변환과 단축 평가

자바스크립트에는 모든 값에 타입이 있다. 값의 타입은 개발자의 의도에 따라 명시적으로 또는 암묵적으로 변환될수 있다.

## 명시적 타입 변환 (Explicit Coercion)

개발자가 의도적으로 값을 특정 타입으로 변환하는 것을 말함.
즉, 코드에서 명확하게 타입을 변환하도록 지시하는 것.
자바스크립트에서는 toString(), Number(), Boolean() 등과 같은 방법을 사용해 변환할 수 있다.

```
let x = 10;

// 숫자를 문자열로 명시적 변환
let str = x.toString();
console.log(typeof str, str); // string "10"
console.log(typeof x, x); // number 10 (원본 값은 변하지 않음)

```

### 암묵적 타입 변환

개발자의 의도와는 상관없이 코드의 문맥을 고려해 자바스크립트 엔진이 테이터 타입을 자동으로 변환하는 것.

### 암묵적 타입 변환의 종류

문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.

### 문자열 타입으로의 변환

예시: 1 + '2' → "12" +연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다.
따라서 모든 피연산자는 문자열 타입이 되어야 한다.

### 숫자 타입으로의 변환 (질문 있음)

이상하게 책에 있는 대로면 1 - '1' // -> 0 이라고 하는데 이거 문자열 타입으로 변환이랑 로직이 서로 부딫히는거 아닌가 생각이 든다 <br>
알아 보니 '-'는 산술연산자로서 동작하고 '+'는 문자 연결 연산자로 동작한다고 한다....<br>
왜 타입 스크립트를 쓰는 추새인지 알겠다.

### 자바스크립트 엔진의 동작

- 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.
- 연산자 표현식의 피연산자(피연산자도 표현식이다)만이 암묵적 타입 변환의 대상이 되는 것은 아니다.

## 단축 평가(Short-circuit Evaluation)

단축 평가는 논리 연산자(||, &&)를 사용할 때 표현식의 평가를 도중에 멈추고 결과를 결정하는 것을 말한다.

### 논리 연산자를 사용한 단축 평가

논리 연산자 (&&, ||)의 동작

- && (논리곱): 두 피연산자가 모두 true일 때만 true 반환
- || (논리합): 두 피연산자 중 하나만 true여도 true 반환
  <br>

### 논리곱(&&)과 논리합(||)의 평가 방식

- Cat && Dog와 같은 표현식에서 Cat은 true로 평가되고, Dog도 true로 평가되어 마지막에 평가된 Dog를 반환한다.
- Cat || Dog에서는 Cat이 true이므로 Cat을 그대로 반환하고, Dog는 평가하지 않는다.
  이렇게 논리곱(&&)과 논리합(||)은 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.

### 단축 평가의 규칙

- true || anything -> true
- false || anything -> anything
- true && anything -> anything
- false && anything -> false

### 객체를 확인하는 패턴

객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인할 때 단축 평가를 사용한다.<br>
예를 들어 elem이 null이 아닐 때만 elem.value를 확인하려면 elem && elem.value와 같이 사용할 수 있다.

```
var elem = null;

// elem이 null 또는 undefined인 경우 단축 평가로 elem.value에 접근하지 않음
var value = elem && elem.value;

console.log(value); // 결과: null
```

### 매개변수의 기본값 설정

- 함수를 호출할 때 인수가 전달되지 않을 경우 undefined가 할당되는 것을 방지하기 위해 단축 평가를 사용할 수 있다.
- 예를 들어, str이 undefined일 때 빈 문자열을 기본값으로 설정하려면 str = str || ''와 같이 사용할 수 있다.

```
function getStringLength(str) {
    // str이 undefined이거나 falsy 값이면 빈 문자열로 기본값 설정
    str = str || '';
    return str.length;
}

console.log(getStringLength());     // 결과: 0 (빈 문자열의 길이)
console.log(getStringLength('hi')); // 결과: 2 ('hi'의 길이)
```

### 옵셔널 체이닝 연산자

옵셔널 체이닝 연산자는(?.) ES11에서 도입된 연산자로 객체의 프로퍼티를 안전하게 접근할 수 있도록 도와준다.

옵셔널 체이닝 연산자의 동작 방식

- 좌항의 피연산자가 null 또는 undefined일 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티를 참조.

### 옵셔널 체이닝 연산자 사용 방법

```
var elem = null;

// elem이 null 또는 undefined일 경우 undefined를 반환하고, 그렇지 않으면 elem.value에 접근
var value = elem?.value;
console.log(value); // 결과: undefined
```

이 예제에서 elem이 null이므로 elem?.value는 undefined를 반환한다.

기존 방식: 논리 연산자 &&를 사용한 안전한 프로퍼티 접근 <br>
옵셔널 체이닝 연산자가 도입되기 전에는 논리 연산자 &&를 사용하여 프로퍼티 접근을 안전하게 수행했다. 하지만 이제 옵셔널 체인으로 보다 간결하게 프로터피 접근에 대한 예외처리가 가능해졌다.

### 논리 연산자 &&를 사용한 프로퍼티 접근

```
var elem = null;

// elem이 Falsy 값이면 elem으로 평가되고, elem이 Truthy 값이면 elem.value로 평가된다.
var value = elem && elem.value;
console.log(value); // 결과: null
```

elem이 null이므로, elem && elem.value는 elem의 값인 null을 반환합니다.

### 문자열의 길이를 안전하게 참조

```
var str = '';

// 문자열의 길이(length)를 참조한다.
var length = str && str.length;
console.log(length); // 결과: ''
```

str이 빈 문자열('')이므로 Falsy 값으로 평가되어 str.length는 평가되지 않는다.<br>
옵셔널 체이닝 연산자를 사용하면 코드가 더 간결하고 읽기 쉬워지며, null 또는 undefined인 객체의 프로퍼티를 참조할 때 발생할 수 있는 오류를 방지할 수 있다.

### Null 병합 연산자

Null 병합 연산자(??)는 ES11(ECMAScript 2020)에서 도입된 연산자로, 좌항의 피연산자가 null 또는 undefined일 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 그대로 반환한다.

- Null 병합 연산자 사용법

```
var foo = null ?? 'default string';
console.log(foo); // 결과: "default string"
```

foo가 null이므로 ?? 연산자의 오른쪽 값인 'default string'이 할당됩니다.

### Null 병합 연산자와 기존 논리 연산자의 차이점

Null 병합 연산자 도입 전에는 논리 연산자 ||를 사용해 기본값을 설정하는 방식이 일반적이었다. 하지만 ||는 좌항의 피연산자가 Falsy 값이면 오른쪽 피연산자를 반환하기 때문에, null이나 undefined 외에도 false, 0, NaN, '' 등도 기본값 처리의 원인이 될 수 있다. 반면, Null 병합 연산자는 오직 null이나 undefined일 때만 기본값을 적용한다.

### Null 병합 연산자의 활용

```
var foo = '' ?? 'default string';
console.log(foo); // 결과: ''
```

foo가 빈 문자열('')이지만, 이는 null이나 undefined가 아니므로 ?? 연산자는 좌항의 빈 문자열을 그대로 반환한다.

### Falsy 값과 Null 병합 연산자 비교

```
var foo = '' || 'default string';
console.log(foo); // 결과: "default string"
```

|| 연산자를 사용하면 빈 문자열도 Falsy 값으로 처리되어 'default string'이 반환된다.
<br>
Null 병합 연산자를 사용하면 Falsy 값 중에서도 null과 undefined만을 대상으로 기본값을 적용할 수 있어, 더 명확하고 안전한 코드를 작성할 수 있다.

## 09 연습문제

### 1. 암묵적 타입 변환

다음 코드의 출력 결과를 예상하고 그 이유를 설명하세요.

```
let result1 = 2 + '3' - 1;
let result2 = '5' * '2';
let result3 = '4' && 0 || 'Hello';

console.log(result1); // 예상 출력: ?
console.log(result2); // 예상 출력: ?
console.log(result3); // 예상 출력: ?
```

- result1에서는 어떤 타입 변환이 발생하고, 그 결과는 무엇인가요?
- result2에서는 어떤 연산이 일어나며, 결과는 무엇인가요?
- result3에서 단축 평가와 관련된 연산은 어떻게 이루어지나요?

<details>
    <summary>해설</summary>
    result 1 <br>
    예상출력 : 22 <br><br>
    해설 <br>
    * 2 + '3'에서 + 연산자는 문자열 연결 연산자로 동작합니다. 2는 문자열 '3'과 연결되어 "23"이 됩니다.<br>
    * "23"은 문자열이므로 - 1은 암묵적 타입 변환을 통해 "23"을 숫자 23으로 변환합니다.<br>
    * 23 - 1은 22가 됩니다.<br><br>
    result 2 <br>
    예상 출력: 10 <br><br>
    해설 <br>
    * 연산자는 산술 연산자이므로 피연산자들을 숫자 타입으로 암묵적 타입 변환합니다.<br>
    * '5'와 '2'는 각각 숫자 5와 2로 변환됩니다.<br>
    * 5 * 2는 10이 됩니다.<br><br>
    result 3 <br>
    예상 출력: "Hello" <br><br>
    해설 <br>
    * && 연산자는 좌항이 true로 평가되면 우항을 반환합니다.<br>
    * '4'는 true로 평가되므로 우항인 0이 반환됩니다.<br>
    * || 연산자는 좌항이 false로 평가되면 우항을 반환합니다.<br>
    * 0은 false로 평가되므로 우항인 "Hello"가 반환됩니다. <br>

</details>

### 2. 단축 평가와 NULL 병합 연산자

다음 함수는 전달된 인수에 따라 다르게 동작합니다. 빈 문자열(''), null, undefined 및 기타 값이 전달될 때 각 경우의 출력 결과를 설명하세요.

```
function getMessage(msg) {
    return msg ?? 'Default message';
}

console.log(getMessage(''));         // 예상 출력: ?
console.log(getMessage(null));       // 예상 출력: ?
console.log(getMessage(undefined));  // 예상 출력: ?
console.log(getMessage('Hello'));    // 예상 출력: ?
```

- msg가 빈 문자열일 때, null일 때, undefined일 때 각각 어떤 결과를 반환하며, 그 이유는 무엇인가요?
- 이 함수에서 ?? 연산자 대신 ||를 사용하면 어떤 차이가 발생하나요?
<br>
<details>
    <summary>해설</summary>
    getMessage('')<br>
    예상 출력: ""<br>
    해설:<br>
    * ''은 빈 문자열로, null이나 undefined가 아닙니다.<br>
    * ?? 연산자는 null과 undefined만 기본값을 적용합니다.<br>
    * 따라서, msg가 빈 문자열일 때는 그대로 ''가 반환됩니다.<br><br>
    getMessage(null) <br>
    예상 출력: "Default message"<br>
    해설:<br>
    msg가 null이므로 ?? 연산자의 우항인 'Default message'가 반환됩니다.<br><br>
    getMessage(undefined)<br>
    예상 출력: "Default message"<br>
    해설:<br>
    msg가 undefined이므로 ?? 연산자의 우항인 'Default message'가 반환됩니다.<br><br>
    getMessage('Hello')<br>
    예상 출력: "Hello"<br>
    해설:
    msg가 문자열 "Hello"이므로 null이나 undefined가 아닙니다.<br>
    ?? 연산자는 null과 undefined만 기본값을 적용합니다.<br>
    따라서, "Hello"가 그대로 반환됩니다.<br><br>
    || 연산자와의 차이점:<br>
    || 연산자는 좌항이 false로 평가되는 값(false, 0, NaN, '')이면 우항을 반환합니다.<br>
    따라서, getMessage('')에서 ||를 사용하면 빈 문자열은 false로 평가되어 'Default message'가 반환됩니다.<br>
    그러나 ?? 연산자는 null과 undefined에만 반응하므로 빈 문자열('')이 그대로 반환되는 차이가 있습니다.
</details>
