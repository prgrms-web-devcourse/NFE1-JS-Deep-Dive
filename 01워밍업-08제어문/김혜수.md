# 01장 프로그래밍

## **프로그래밍**이란?

: 정확하고 상세하게 **요구사항**을 ‘Code(컴퓨터가 이해하는 언어=**프로그래밍 언어**)’로 설명하는 것

하지만, 사람의 언어와 컴퓨터의 언어가 다르기 때문에 중간에 번역을 해줄 역할이 필요하고 이를 `컴파일러` OR `인터프리터`라고 한다.

### **[🔄 → 💻 컴퓨터]**

**👤 (사람): 코드 작성 — ✍️ (컴파일러): 코드 변환 — 💻 (컴퓨터): 코드 실행**

🔍 **_사람의 요구사항 집합들을 분석해 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어 하는 것이 프로그래밍이다._**

# 02장 자바스크립트란?

: HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 **웹 브라우저에서 동작하는 유일한 프로그래밍 언어**

1. **자바스크립트 진화 과정**

| **시기**                                                                                 | **주요 기술 및 발전**                        | **설명**                                                                                                                                                                 |
| ---------------------------------------------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **초기 (1995-2004)**                                                                     | **자바스크립트 탄생**                        | - 브렌던 아이크(Brendan Eich)가 1995년 10일 만에 자바스크립트를 개발                                                                                                     |
| - 처음에는 브라우저 내에서 간단한 동작을 처리하기 위한 스크립트 언어로 설계              |
|                                                                                          | **DOM 조작 및 DHTML**                        | - 1990년대 말과 2000년대 초에, 자바스크립트는 DOM(Document Object Model)을 통해 HTML 문서를 조작하는 데 사용되기 시작                                                    |
| - DHTML(동적 HTML) 개념 도입                                                             |
| **Ajax (2005)**                                                                          | **Ajax (Asynchronous JavaScript and XML)**   | `Ajax` : 페이지를 새로 고치지 않고도 서버와 비동기적으로 데이터를 주고받을 수 있게 해줌.                                                                                 |
| → 웹 애플리케이션의 사용자 경험을 크게 향상                                              |
| **jQuery (2006)**                                                                        | **jQuery 라이브러리**                        | - `jQuery` : 크로스 브라우징 문제를 해결하고 DOM 조작을 쉽게 할 수 있도록 도와주는 자바스크립트 라이브러리                                                               |
| → 개발 생산성이 크게 향상                                                                |
| **V8 자바스크립트 엔진 (2008)**                                                          | **Google V8 엔진**                           | - 구글이 개발한 `V8 엔진`: 자바스크립트의 성능을 크게 향상                                                                                                               |
| - 자바스크립트를 컴파일하여 네이티브 코드로 실행시킴으로써 웹 애플리케이션의 속도를 높힘 |
| **Node.js (2009)**                                                                       | **Node.js 런타임 환경**                      | - `Node.js`: **V8 엔진을 기반**으로 만들어진 서버 사이드 자바스크립트 런타임 환경이를 통해 자바스크립트로 서버 측 개발이 가능 + JavaScript의 사용 범위가 확장되었습니다. |
| **SPA 프레임워크 (2010년대 이후)**                                                       | **Single Page Application (SPA) 프레임워크** | `Angular`, `React`, `Vue.js` 등의 SPA 프레임워크 : 클라이언트 측에서의 복잡한 UI 관리와 상태 관리를 가능함                                                               |
| → 웹 애플리케이션이 더욱 대화형이고 응답성 Good!                                         |

1. **자바스크립트 특징**
   - 기본 문법은 C, Java와 유사
   - 개발자가 별도의 컴파일 작업을 수행하지 않는 `인터프리터 언어`
     → 인터프리터는 소스코드 즉시 실행 + 컴파일러는 머신 코드 생성 및 최적화 → 빠른 코드 실행 가능 !
   - **명령형 / 함수형 / 프로토타입** 기반 객체지향 프로그래밍 지원 **(= 멀티 패러다임 프로그래밍 언어)**
     | 항목 | 인터프리터 언어 | 컴파일러 언어 |
     | --------------- | ----------------------------- | ---------------------------------------------- |
     | **실행 방식** | 소스 코드를 한 줄씩 읽고 실행 | 전체 소스 코드를 한 번에 기계어로 변환 후 실행 |
     | **속도** | 보통 느림 | 보통 빠름 |
     | **디버깅** | 실행 중간에 오류를 발견 가능 | 컴파일 단계에서 오류 발견 |
     | **메모리 사용** | 상대적으로 적음 | 상대적으로 많음 |
     | **예시 언어** | Python, JavaScript, Ruby | C, C++, Java |
2. **Javascript - ECMAScript**
   자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 `ECMAScript`와 브라우저가 별도 지원하는 [**클라이언트 사이드 Web API**](https://www.w3.org/standards/webdesign/script), 즉 `DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker` 등을 아우르는 개념이다.

# 04장 변수

## 변수

- 하나의 값을 저장하기 위해 확보한 메모리에서 확보한 공간

| 용어                   | 의미                                                                         |
| ---------------------- | ---------------------------------------------------------------------------- |
| 데이터 타입(Data Type) | 프로그래밍 언어에서 사용할 수 있는 값의 종류                                 |
| 변수(Variable)         | 값이 저장된 메모리 공간의 주소를 가리키는 식별자(identifier)                 |
| 리터럴(literal)        | 소스코드 안에서 직접 만들어 낸 상수 값 자체를 말하며 값을 구성하는 최소 단위 |

- 메모리상 값은 언제든 변경이 가능

## 변수 선언

- 식별자와 메모리 주소를 연결하여 값을 저장할 수 있도록 준비하는 것으로 변수 선언에 의해 확보된 메모리 공간은 Release되기 전까지 누구도 사용할 수 없도록 보호된다.
- 변수 선언에는 ~~var (ES6 이전),~~ const, let 키워드를 사용한다.
- 변수 선언만 한 경우 값이 할당된 것은 아니지만 확보된 메모리가 빈건 아니다.
  **_Why? 자바스크립트는 undefined로 할당하여 초기화 하기 때문_** - 선언 : 변수 이름 등록 → JS 엔진에 변수 존재 알림 - 초기화 : 값을 저장하기 위한 메모리 확보 + 암묵적 undefined 할당 → 초기화

## 변수 선언 실행 시점과 변수 호이스팅

```tsx
console.log(score); // undefined
var score; // 변수 선언
```

왜 log의 값이 undefined일까? **(에러아님!)**
답은 간단하다 ! JS는 위에서 부터 한줄씩 실행되는데 아직 변수를 선언하기 전에 실행되었기 때문이다.

다른 언어에서 상상하지도 못할 부분이 바로 이곳인데 **변수 호이스팅**이다.

변수 선언문의 코드가 선두로 끌어올려진 것처럼 동작하여 에러가 나지 않는다는 아주 독특한 특징을 가지고있다..
(다른 언어와 비교해서 그런가 논리적이지 않아서 근본없이 느껴져서 별로당…)

## 데이터 타입

> 자바스크립트의 값은 모두 데이터 타입을 가지며 가능한 타입은 아래와 같다.
> 또한 자바스크립트는 할당된 값에 **동적으로 변수 타입이 결정**되는데 이 점이 다른 프로그래밍 언어와 구별되는 점이다.

- 원시 타입**(단일 메모리 할당)**
  : \*\*\*\*변경 불가능한 값 → 원시 값을 변수에 할당하면 메모리 공간에는 실제 값이 저장됨
  - `number`
  - `string`
  - `boolean`
  - `null`
  - `undefined`
  - `symbol`(ES6)
- 객체 타입**(메모리 주소가 할당)**
  : 객체는 변경 가능한 값으로, 객체를 할당한 변수는 재할당 없이 객체를 직접 변경
  - `object`

## 값의 할당

변수에 값을 할당하는 방법은 대입연산자(=)를 사용하는 것이다.

- 자바스크립트 엔진은 축약하여 선언과 할당을 동시에 하여도 선언문과 할당문으로 나누어 실행
- 변수 선언은 런타임 이전 실행 BUT 값의 할당은 순차적으로 실행되는 시점(=런타임)에 실행

![01](https://github.com/user-attachments/assets/7253b4c3-de43-45c1-b46a-6f1ab5d74b51)

```jsx
// undefined. 런타임 시점에 첫 번째로 실행
// 변수 호이스팅으로 인해 undefined가 초기화된 변수를 콘솔에 출력
console.log(score);

// 변수 호이스팅으로 런타임 전에 먼저 선언문이 실행
var score;

// 런타임 시점에 두 번째로 실행되는 코드. 80이라는 값이 할당
socre = 80;

//score에 값이 할당되었기에 80 출력
console.log(score);
```

- 변수 선언과 값의 할당을 동시에 하더라도 선언문 → 할당문으로 나누어 실행함 (호이스팅)
  **즉, 값 할당 시 undefined가 저장된 메모리 공간 외 새로운 메모리 공간을 확보하여 값을 할당하고 식별자끼리 연결하는 것이다!**

## 값의 재할당

: 이미 값이 존재하는 변수에 새로운 값을 다시 할당

```jsx
// var 키워드로 선언한 변수는 재할당 가능!
var score = 80; // 변수 선언과 동시에 할당함
score = 90; // 새로운 값을 기존 변수 score에 재할당
```

![02](https://github.com/user-attachments/assets/29448122-5433-47e2-9f39-d18c14d0ffb7)

- `var score=80` 은 재할당이다.
  Why ? 앞서 말했듯 자바스크립트 엔진은 선언문과 할당문을 나누어 실행하고, 선언 시 undefined로 초기화 한다고 배웠다. 따라서 값을 처음 할당하는것도 재할당인 것이다.
- 그림을 예로 보면, 재 할당 시 새로운 메모리 공간을 확보하고 그곳에 값을 할당하여 식별자(score)과 매핑됨을 확인할 수 있다.
  - 여기서 생기는 불필요한 값은 `Garbage Collector`에 의해 메모리에서 자동해제 된다.

# 05 장 표현식과 문

## 값

:  **표현식(expression)** 이 **평가(Evaluate)** 되어 생성된 **결과**

모든 값은 메모리에 2진수의 나열로 저장되고 앞에 데이터 타입이 붙어 값을 다르게 해석할 수 있다.
0100 0001이 Number타입이면 65이고, String 타입이면 ‘A’인 것 처럼..

## 리터럴

: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

![03](https://github.com/user-attachments/assets/f0b8e6ec-549b-4f19-a3f2-6ed4ca7ae233)

![04](https://github.com/user-attachments/assets/8c4a5773-d407-4ff3-b629-39a2a746d24f)

자바스크립트는 런타임 시점에서 리터럴을 평가해 값을 생성한다. 따라서 리터럴은 값을 생성하기 위한 표기법!

## 표현식

: **값(value)**으로 평가될 수 있는 **문(statement)으로 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**

- 표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄진다
- 다양한 표현식이 있지만 **모두 값으로 평가된다**는 점은 동일하다.
  → 값으로 평가될 수 있는 문은 모두 표현식

```jsx
//리터럴 표현식
10;
("hello");

//식별자 표현식
sum;
person.name;
arr[1];

//연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수 & 메소드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName();
```

- 표현식(2+3)과 값(5)은 동치이다.

  - 이 말은 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치 할 수 있는 것을 의미한다.
    (ex)

  ```jsx
  var x = 1 + 2;

  x + 3; // -> 6
  ```

  → x + 6은 표현식이다.
  _+ 연산자는 좌항과 우항의 값을 산술 연산하는 연산자이므로, 좌항과 우항에는 숫자 값이 위치해야 한다.
  이때 좌항 x는 식별자 표현식이, x에는 숫자 값 3이 할당되어 있고, 식별자 표현식 x를 평가하면, 숫자 값 3이 결과로 생성된다. 따라서 숫자 값이 위치해야할 자리에 표현식 x를 사용할 수 있다._

## 표현식인 문과 표현식이 아닌 문

**문은 표현식과 표현식이 아닌 문을 포함한다.**

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식 X
var x; // 문 O 표현식X

//  문 O 표현식 O
x = 1 + 2;
```

- 표현식은 값으로 평가될 수 있는 문, 표현식이 아닌 문은 값으로 평가되지 않는 문

이를 명확하게 구분할 수 있는 방법은 **변수에 할당**해보는 것!

```jsx
var foo = var x; // SyntaxError : Unexpected token var
```

위 코드에서 볼 수 있듯 변수 선언문은 표현식이 아니다. → 따라서 **변수 선언문을 값처럼 사용 할 수 없다.**

```jsx
var x; // 표현식이 아닌 문(변수 선언문)
x = 100; // 할당문은 표현식이면서 완전한 문이다.
```

x = 100은 리터럴 100에 대한 평가 결과인 숫자 값 100을 x라는 변수에 할당하는 할당문이다.

이 때 리터럴 100은 평가 결과 값을 가지므로 변수에 할당할 수 있다.

또한 할당문 x = 100은 **그 자체로도 평가식**이기에 평가 결과 값은 100이다.

```jsx
// 표현식인 문은 값처럼 사용할 수 있다.
var foo = (x = 100);
console.log(foo); // 100;
```

위 코드에서 **할당문을 값처럼 변수에 할당**했다. **할당문은 표현식**이므로 값으로 평가된다. 즉 x = 100은 x 변수에 100을 할당한 값 100으로 평가된다. 따라서 foo 변수에는 100이 할당된다.

# 06 데이터

## 데이터 타입의 필요성

## 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야하나 메모리에 값을 저장하려면 먼저 확보해야할 공간의 크기를 정해야한다. 즉, **몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 저장할 수 있는지 알아야**한다.

```jsx
var score = 100;
```

위 코드가 실행하면 100에 해당하는 값을 저장하기 위해서 공간을 확보하고 숫자 값 100을 2진수로 저장하게 된다. 즉 **먼저 공간의 크기를 적절히 정해야지 값을 저장할 수 있는 것**이다.

자바스크립트 엔진은 값의 데이터 타입에 따라서 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 **값의 데이터 타입에 따라서 확보해야할 메모리 공간의 크기가 결정**된다.

자바스크립트 엔진에서는 숫자타입의 값을 저장하기 위해서 8바이트의 메모리 공간을 확보한다. 그리고 100을 이진수로 저장한다. **(그림 참조)**

![05](https://github.com/user-attachments/assets/1928722b-37a5-4493-8ce7-cf31837da79b)

자바스크립트 엔진은 숫자타입의 값을 생성할 때 정밀도 64비트 부동소수점 형식을 사용한다.

→ 즉, 실제 메모리에 저장되는 이진수의 값은 위 그림과 다름.

이 값을 참조하는 경우, 식별자 score를 통해서 숫자 타입의 값 100이 저장되어있는 메모리 공간의 주소를 찾아갈 수 있다. 정확히 말하면 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있다.

그러면 선두 메모리부터 **데이터 타입에 따라 정해진 offset만큼의 메모리**가 100에 대한 이진수를 저장한 공간일 것이다.

숫자 타입은 8바이트이므로 만약 8바이트를 읽어들이지 않는다면 데이터 손실이 일어날 것이다. 자바스크립트 엔진은 score라는 변수에 숫자 타입이 할당되어 있는 것을 인식하고 8바이트 단위로 메모리에 있는 값을 읽을 것이다.

결국 데이터 타입이 존재하므로 메모리에 **정해진 크기의 공간을 확보**할 수 있고, **이에 따라 참조**할 수 있다.

## 데이터 타입에 의한 값의 해석

데이터를 효과적으로 저장하고, 손실 없이 읽는 것 외에 다른 문제가 더 있는데 이는 “위에서 저장한 100에 대한 이진수를 다시 **읽어올 때 어떻게 해석하느냐** ”하는 문제이다.
만약 메모리에 0100 0001이 저장되어있고 이를 숫자로 해석하면 65이지만, 문자열로 해석하면 'A'이다. 이 때 **어떤 데이터 타입의 값이냐에 따라 해석이 정해진다**.

> 데이터 타입의 필요성 정리 :
>
> - 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
> - 값을 참조할 때 한 번에 읽어 들어야 할 메모리 공간의 크기를 결정하기 위해
> - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

---

# 동적 타이핑

자바스크립트의 모든 값은 데이터 타입을 가진다. 하지만 변수는 데이터 타입을 가지지 않는다.

## 동적 타입 언어와 정적 타입 언어

C나 자바 같은 **정적 타입 언어**는 **변수를 선언할 때 해당 변수에 할당할 수 있는 데이터 타입을 사전에 선언**해야 한다. 이를 명시적 선언이라 한다.

```java
//java의 예시
int i = 0;
char c = 'c';
```

정적 타입 언어는 변수의 타입을 변경할 수 없으며, **변수에 선언한 타입과 맞는 값만 할당 가능**하다.
정적타입 언어는 컴파일 시점에 타입체크를 수행한다. 만약 이를 통과하지 못한다면 프로그램 자체가 실행되지 않는다. 이를 통해 **타입의 일관성을 강제**하므로 **안정적인 코드**를 구현할 수 있으며, 런타입에 발생하는 에러를 줄일 수 있다.

BUT 자바스크립트는 변수를 선언할 때 타입을 선언하지 않는다. `var`, `let` `const` 키워드만 사용할 뿐이다. 자바스크립트의 변수에는 어떤 타입의 값이이라도 할당이 가능하다.

```jsx
var foo;
console.log(typeof foo); // undefined;

foo = 3;
console.log(typeof foo); // number

foo = "hello";
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // booean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console.log(typeof foo); // symbol

foo = {};
console.log(typeof foo); // object

foo = [];
console.log(typeof foo); //object

foo = function () {};
console.log(typeof foo); // function
```

typeof 연산자는 변수의 데이터 타입이 아닌 **변수에 할당된 값의 데이터 타입을 반환**한다.

자바스크립트의 변수는 선언이 아닌 **할당에 의해 타입이 결정**된다. 그리고 **재할당에 의해 변수의 타입이 언제든지 동적으로 변할 수** 있다. 이러한 특징을 **동적 타이핑**이라고 한다.

## 동적 타입 언어와 변수

동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있는데 이는 즉 문제를 일으킬 위험도 많다는 의미이다……

1. 복잡한 프로그램 안에서 변수의 값은 계속 변화하고, 동적 타입 언어는 변수에 어떤 값이 할당되냐에 따라 데이터 타입이 변하기 까지 한다. 그러므로 동적 타입 언어는 변수의 값을 확인하기 전에는 타입을 확신할 수 없다.
2. 자바스크립트는 개발자의 의도와 상관없이 자바스크립트 엔진의 암묵적인 룰에 의해서 타입이 자동으로 변하기도 한다. 숫자 타입이라고 예측하고 프로그램을 짰지만 알고보니 문자 타입의 변수일 수도 있다.

결국 이러한 이유로 변수를 사용하기 전에 매번 데이터 타입을 체크하게 되는데 이는 번거로울 뿐아니라 코드의 양도 증가하고 지저분해진다.

따라서 변수를 사용할 때 이 점을 주의해야한다 !!!!!!

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
- 변수의 스코프를 최대한 좁게 만들어야 한다.
- 전역 변수는 최대한 사용하지 않는다.
- 변수보다는 최대한 상수를 사용한다.
- 의미있는 변수 네이밍이 필요하다.

# 07장 연산자

## 연산자 우선순위

명령어가 여러 연산자로 이뤄져있을 경우 연산자 간의 우선순에 맞춰서 연산한다.

즉, 우선순위가 높은 연산자 일수록 먼저 실행

![06](https://github.com/user-attachments/assets/5957b3fa-abdd-4fed-8fcb-33377fd44600)

![07](https://github.com/user-attachments/assets/7ad0a3e3-bc5f-4d95-a43f-aad1c1915fc3)

연산자의 종류와 우선 순위를 모두 기억하기 어렵기에 가장 우선순위가 높은 그룹 연산자를 사용하여 명시적으로 조절하는 것이 좋다!

---

## 연산자 결합 순서

: 연산자의 어느 쪽 부터 평가를 수행할 것인지를 나타내는 순서

![08](https://github.com/user-attachments/assets/a98b2bf6-9c1d-41c9-9860-3305d09c0371)

# 08장 제어문

---

## 블록문

- **블록문**은 0개 이상의 문을 중괄호로 묶은 것이며, 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.
- 주로 제어문이나 함수를 정의할 때 사용된다.
- 블록문은 항상 **자체 종결성**을 갖기 때문에 ;을 붙이지 않는다.

## 조건문

- **조건문**은 주어진 조건식의 평가 결과에 따라 코드 블록이 실행된다.
- 조건식은 불리언 값으로 평가될 수 있는 표현식이다.
- 자바스크립트는 **if ... else** 문과 **switch** 문 두 가지 조건문을 제공한다.

### if ... else

- **true** : if 문의 코드 블록이 실행
- **false** : else 문의 코드 블록이 실행
- 조건식을 추가해 **추가 조건**에 따라 실행되는 코드 블록을 실행하려면 **else if** 문을 사용 !

> 📍 대부분의 if ... else 문은 삼항 연산자로 바꿔 쓰기 가능!

```
if(조건식) {
  코드 블록 // 조건식 → true
} else if(다른 조건식) {
  코드 블록
} else {
  코드 블록 // 조건식 → false
}
```

### switch

- **switch 문**은 주어진 표현식을 평가해, 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.
- 표현식과 일치하는 case 문이 없다면 default 문으로 이동한다. **(default 문은 선택사항)**

> 📍 **switch 문의 표현식은 불리언 값 보다는 문자나 숫자 값**

- 표현식에 해당하는 case 문에서는 **break** 키워드를 이용해 코드 블록을 탈출 해야한다!!!

```
var 표현식 = "표현식"

switch(표현식) {
  case '표현식':  // if (표현식 === '표현식')
    ...
    [break]

  case '표현식2':  // if (표현식 === '표현식2')
    ...
    [break]

  default:
    ...
    [break]
}
```

## 반복문

- **반복문**은 조건식의 평가 결과가 **참**인 경우 코드 블록을 실행한다.
- 조건이 거짓이 될 때까지 **반복**한다.

### for 문

- **for 문**은 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 수행한다.

```
for(변수, 조건식, 증감식) {
  조건식이 참일 경우 실행되는 문;
}

for (var i = 0; i < 3; i ++) {
  console.log(i); // 0 1 2
}
```

## break 문

- **break 문**은 코드 블록을 **탈출**한다. 정확히는 레이블 문, 반복문,switch 문의 코드 블록을 탈출한다.
- 언제든지 빠져나올 수 있다.

```
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break; // i가 5가 되면 코드 블록을 빠져나온다.
  }
  console.log(i); // 0 1 2 3 4
}
```

## continue 문

- **continue 문**은 코드 블록 실행의 현 시점을 중단하고 **다음 반복**을 실행한다.
- break 문처럼 반복문을 탈출하지 않는다.

```
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue; // i가 5일 경우 그 다음 이터레이션으로 넘어간다.
  }
  console.log(i); // 0 1 2 3 4 6 7 8 9
}
```

###
