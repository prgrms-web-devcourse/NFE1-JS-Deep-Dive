# Deep Dive Study - 7주차

<br/><br/><br/>

<h1 align="center">29.Math</h1>

<br/>

# Math 프로퍼티

### Math.PI

원주율 PI 값을 반환한다.

```js
Math.PI; // 3.141592653589793
```

<br/><br/>

# Math 메서드

### Math.abs

`Math.abs` 메서드는 인수로 전달된 숫자의 절대값을 반환한다. 절대값은 반드시 0 또는 양수이어야 한다.

```js
Math.abs(-1); // -> 1
Math.abs("-1"); // -> 1
Math.abs(""); // -> 0
Math.abs([]); // -> 0
Math.abs(null); // -> 0
Math.abs(undefined); // -> NaN
Math.abs({}); // -> NaN
Math.abs("string"); // -> NaN
Math.abs(); // -> NaN
```

<br/>

### Math.round

`Math.round`메서드는 인수로 전달된 숫자의 소수점 이하를 **반올림**한 정수를 반환한다.

```js
Math.round(1.4); // -> 1
Math.round(1.6); // -> 2
Math.round(-1.4); // -> -1
Math.round(-1.6); // -> -2
Math.round(1); // -> 1
Math.round(); // -> NaN
```

<br/>

### Math.ceil

`Math.ceil` 메서드는 인수로 전달된 숫자의 소수점 이하를 **올림**한 정수를 반환한다.

```js
Math.ceil(1.4); // -> 2
Math.ceil(1.6); // -> 2
Math.ceil(-1.4); // -> -1
Math.ceil(-1.6); // -> -1
Math.ceil(1); // -> 1
Math.ceil(); // -> NaN
```

<br/>

### Math.floor

`Math.floor` 메서드는 인수로 전달된 숫자의 소수점 이하를 **내림**한 정수를 반환한다. `Math.ceil`의 반대 개념이다.

```js
Math.floor(1.9); // -> 1
Math.floor(9.1); // -> 9
Math.floor(-1.9); // -> -2
Math.floor(-9.1); // -> -10
Math.floor(1); // -> 1
Math.floor(); // -> NaN
```

<br/>

### Math.sqrt

`Math.sqrt` 메서드는 인수로 전달된 숫자의 **제곱근을 반환**한다.

```js
Math.sqrt(9); // -> 3
Math.sqrt(-9); // -> NaN
Math.sqrt(2); // -> 1.414213562373095
Math.sqrt(1); // -> 1
Math.sqrt(0); // -> 0
Math.sqrt(); // -> NaN
```

<br/>

### Math.random

`Math.random` 메서드는 임의의 난수를 반환한다. 반환한 난수는 0에서 1미만의 실수다.

```js
Math.random();

const random = Math.floor(Math.random() * 10 + 1);
console.log(random);
```

<br/>

### Math.pow

`Math.pow` 메서드는 첫 번째 인수를 밑(base)으로, 두 번째 인수를 지수(exponent)로 거듭제곱한 결과를 반환한다.

```js
Math.pow(2, 8); // -> 256
Math.pow(2, -1); // -> 0.5
Math.pow(2); // -> NaN
```

ES7에서 도입된 **지수 연산자**를 사용하면 가독성이 더 좋다.

```js
// ES7 지수 연산자
2 ** (2 ** 2); // -> 16
Math.pow(Math.pow(2, 2), 2); // -> 16
```

<br/>

### Math.max

`Math.max` 메서드는 전달받은 인수 중에서 가장 큰 수를 반환한다. 인수가 전달되지 않으면 `-Infinity`를 반환한다.

```js
Math.max(1); // -> 1
Math.max(1, 2); // -> 2
Math.max(1, 2, 3); // -> 3
Math.max(); // -> -Infinity
```

배열을 인수로 전달받아 배열의 요소 중에서 최대값을 구하려면 `Function.prototype.apply` 메서드 또는 **스프레드 문법**을 사용해야 한다.

```js
// 배열 요소 중에서 최대값 취득
Math.max.apply(null, [1, 2, 3]); // -> 3

// ES6 스프레드 문법
Math.max(...[1, 2, 3]); // -> 3
```

<br/>

### Math.min

`Math.min` 메서드는 전달받은 인수 중에서 가장 작은 수를 반환한다. 인수가 전달되지 않으면 `Infinity`를 반환한다.

```js
Math.min(1); // -> 1
Math.min(1, 2); // -> 1
Math.min(1, 2, 3); // -> 1
Math.min(); // -> Infinity
```

배열을 인수로 전달받아 배열의 요소 중에서 최소값을 구하려면 `Function.prototype.apply` 메서드 또는 **스프레드 문법**을 사용해야 한다.

```js
// 배열 요소 중에서 최소값 취득
Math.min.apply(null, [1, 2, 3]); // -> 1

// ES6 스프레드 문법
Math.min(...[1, 2, 3]); // -> 1
```

<br/><br/><br/>

<h1 align="center">30.Date</h1>

<br/>

표준 빌트인 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수다.

UTC는 국제 표준시를 말한다 UTC는 GMT로 불리기도 한다. 이 둘은 소수점 단위에서만 차이가 나기 때문에 일상에서는 혼용되어 사용된다. 기술적인 표기에서는 UTC가 사용된다.

KST는 UTC에 9시간을 더한 시간이다. 즉, KST는 UTC보다 9시간 빠르다.

<br/><br/>

# Date 생성자 함수

Date는 생성자 함수다. Date 생성자 함수로 생성한 Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다. 이 값은 1970년 1월 1일 00:00:00(UTC)을 기점으로 Date 객체가 나타내는 날짜와 시간까지의 밀리초를 나타낸다.

Date 생성자 함수로 생성한 Date 객체는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다. 현재 날짜와 시간이 아닌 다른 날짜와 시간을 다루고 싶은 경우 Date 생성자 함수에 명시적으로 해당 날짜와 시간 정보를 인수로 지정한다.

<br/>

### new Date()

Date 생성자 함수를 인수 없이 `new` 연산자와 함께 호출하면 현재 날짜와 시간을 가지는 Date 객체를 반환한다.

Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖지만, Date 객체를 콘솔에 출력하면 기본적으로 날짜와 시간 정보를 출력한다.

```js
new Date();
// Tue Oct 29 2024 09:19:42 GMT+0900 (한국 표준시)
```

Date 생성자 함수를 new 연산자 없이 호출하면, Date 객체를 반환하지 않고 날짜와 시간정보를 나타내는 문자열을 반환한다.

```js
Date();
// '// Tue Oct 29 2024 09:19:42 GMT+0900 (한국 표준시)'
```

<br/>

### new Date(milliseconds)

Date 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다.

```js
//I 한국 표준시 KST는 협정 세계시 UTC에 9시간을 더한 시간0/다.
new Date(0); // - Thu Jan 01 1970 09:00:00 GMT+0900 (대한민국 표준시)

/*
86400000ms는 1day를 의미한다.
ls = 1,000ms
1m = 60s * 1,000ms = 60,000ms
lh = 60m * 60,000ms = 3,600,000ms
ld = 24h * 3,600,000ms = 86,400,000ms
*/
new Date(86400000); // - Fri Jan 02 1970 09:00:00 GMT+0900 (대한민국 표준시)
```

<br/>

### new Date(dateString)

Date 생성자 함수에 날짜와 시간을 나타내는 문자열을 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date객체를 반환한다. 이때 인수로 전달한 문자열은 `Date.parse` 메서드에 의해 해석 가능한 형식이어야 한다.

```js
new Date("May 26, 2020 10 : 00:001");
// 一 Tue May 26 2020 10:00:00 GMT+0900 (대한민국 표준시)

new Date("2020l03l26l10:00:00");
// - Thu Mar 26 2020 10:00:00 GMT+0900 (대한민국 표준시)
```

<br/>

### new Date(year, month,[,day, hour, minute, second, millisecond])

Date 생성자 함수에 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. <ins>이때 연, 월은 반드시 지정해야 한다.</ins> 지정하지 않은 옵션 정보는 0 또는 1로 초기화된다.

인수는 다음과 같다.

| 인수        | 내용                                                                   |
| ----------- | ---------------------------------------------------------------------- |
| year        | 연을 나타내는 1900년 이후의 정수. 0부터 99는 1900부터 1999로 처리된다. |
| month       | 월을 나타내는 0 ~11까지의 정수(주의: 0부터 시작, 0 = 1월)              |
| day         | 일을 나타내는 1 ~31까지의 정수                                         |
| hour        | 시를 나타내는 0 ~23까지의 정수                                         |
| minute      | 분을 나타내는 0 ~59까지의 정수                                         |
| second      | 초를 나타내는 0 ~59까지의 정수                                         |
| millisecond | 밀리초를 나타내는 0 ~999까지의 정수                                    |

<br/><br/>

# Date 메서드

<br/>

### Date.now

1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.

```js
Date.now(); // -> 1730161613289
```

<br/>

### Date.parse

1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간(new Date(dateString)의 인수와 동일한 형식)까지의 밀리초를 숫자로 반환한다.

```js
// UTC
Date.parse("Jan 2, 1970 00:00:00 UTC"); //- 86400000
// KST
Date.parse("Jan 2, 1970 09:00:00"); // - 86400000
// KST
Date.parse("1970101102109:00:00"); // - 86400000
```

<br/>

### Date.UTC

1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를숫자로 반환한다.

`Date.UTC` 메서드는 new Date(year,month[,day,hour,minute,second,millisecond])와 같은 형식의 인수를 사용해야 한다. `Date.UTC` 메서드의 인수는 로컬 타임(KST)이 아닌 UTC로 인식된다.

```js
Date.UTC(1970, 0, 2); // - 86400000
Date.UTC("1970/1/2"); // - NaN
```

<br/>

### Date.prototype.getFullYear

Date 객체의 연도를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24").getFullYear(); // - 2020
```

<br/>

### Date.prototype.setFullYear

Date 객체에 연도를 나타내는 정수를 설정한다. 연도 이외에 옵션으로 월, 일도 설정할 수 있다.

```js
const today = new Date();

// 년도 지정
today.setFullYear(2000);
today.getFullYear(); // -> 2000

// 년도/월/일 지정
today.setFullYear(1900, 0, 1);
today.getFullYear(); // -> 1900
```

<br/>

### Date.prototype.getMonth

Date 객체의 월을냐타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다.

```js
new Date("2020/07/24").getMonth(); // -> 6
```

<br/>

### Date.prototype.setMonth

Date 객체에 월을 나타내는 0 ~ 11의 정수를 설정한다. 1월은 0, 12월은 11이다. 월 이외에 옵션으로 일도 설정할수있다.

```js
const today = new Date();

// 월 지정
today.setMonth(0); // 1월
today.getMonth(); // -> 0

// 월/일 자정
today.setMonth(11, 1); // 12월 1일
today.getMonth(); // -> 11
```

<br/>

### Date.prototype.getDate

Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24").getDate(); // -> 24
```

<br/>

### Date.prototype.setDate

Date 객체에 날짜(1 ~ 31)를 나타내는 정수를 설정한다.

```js
const today = new Date();

// 날짜 지정
today.setDate(1);
today.getDate(); // -> 1
```

<br/>

### Date.prototype.getDay

Date 객체의 요일(0 ~ 6)을 나타내는 정수를 반환한다. 반환값은 다음과 같다.

| 요일   | 반환값 |
| ------ | ------ |
| 일요일 | 0      |
| 월요일 | 1      |
| 화요일 | 2      |
| 수요일 | 3      |
| 목요일 | 4      |
| 금요일 | 5      |
| 토요일 | 6      |

```js
newDate("2020/07/24").getDay(); // -> 5
```

<br/>

### Date.prototype.getHours

Date 객체의 시간(0 ~ 23)을 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:00").getHours(); // -> 12
```

<br/>

### Date.prototype.setHours

Date 객체에 시간(0 ~ 23)을 나타내는 정수를 설정한다. 시간 이외에 옵션으로 분, 초, 밀리초도 설정할 수 있다.

```js
const today = new Date();

// 시간 지정
today.setHours(7);
today.getHours(); // -> 7

// 시간/분/초/밀리초 지정
today.setHours(0, 0, 0, 0); // 00:00:00:00
today.getHours(); // -> 0
```

<br/>

### Date.prototype.getMinutes

Date 객체의 분(0 ~ 59)을 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:30").getMinutes(); // -> 30
```

<br/>

### Date.prototype.setMinutes

Date 객체에 분(0 ~ 59)을 나타내는 정수를 설정한다. 분 이외에 옵션으로 초, 밀리초도 설정할 수 있다.

```js
const today = new Date();
// 분 지정
today.setMinutes(50);
today.getMinutes(); // -> 50

// 분/초/밀리초 지정
today.setMinutes(5, 10, 999); // HH:05:10:999
today.getMinutes(); // -> 5
```

<br/>

### Date.prototype.getSeconds

Date 객체의 초(0 ~ 59)를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:30:10").getSeconds(); // -> 10
```

<br/>

### Date.prototype.setSeconds

Date 객체에 초(0 ~ 59)를 나타내는 정수를 설정한다. 초 이외에 옵션으로 밀리초도 설정할 수 있다.

```js
// 초 지정
today.setSeconds(30);
today.getSeconds(); // -> 30

// 초/밀리초 지정
today.setSeconds(10, 0); // HH:MM:10:000
today.getSeconds(); // -> 10
```

<br/>

### Date.prototype.getMilliseconds

Date 객체의 밀리초(0 ~ 999)를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:30:10:150").getMi1liseconds(); // -> 150
```

<br/>

### Date.prototype.setMilliseconds

Date 객체에 밀리초(0 ~ 999)를 나타내는 정수를 설정한다.

```js
const today = new Date();

// 밀리초 지정
today.setMi11iseconds(123);
today.getMilliseconds(); // -> 123
```

<br/>

### Date.prototype.getTime

1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 반환한다.

```js
new Date("2020/07/24/12:30").getTime(); // -> 1595561400000
```

<br/>

### Date.prototype.setTime

Date 객체에 1970년 1월 1일 00:00:00(UTC)를 기점으로 경과된 밀리초를 설정한다.

```js
const today = new Date();

// 1970년 1월 1일 00:00:00(UTC)를 기점으로 경과된 밀리초 설정
today.setTime(86400000); // 86400000은 1day를 나타낸다.
console.log(today); // -> Fri Jan 02 1970 09:00:00 GMT+0900 (대한민국 표준시)
```

<br/>

### Date.prototype.getTimezoneOffset

UTC와 Date 객체에 지정된 로캘(locale) 시간과의 차이를 분 단위로 반환한다. KST는 UTC에 9시간을 더한 시간이다. 즉, **UTC = KST - 9h**다.

```js
const today = new Date(); // today의 지정 로캘은 KSTCt.

// UTC와 today의 지정 로캘 KST와의 차이는 -9시간이다.
today.getTimezoneOffset() / 60; // -9
```

<br/>

### Date.prototype.toDateString

사람이 읽을 수 있는 형식의 문자열로 Date 객체의 날짜를 반환한다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> F:ri Jul 24 2020 12:30:00 아ff+0900 (대한민국 표준시)
today.toDateString(); // -> Fri Jul 24 2020
```

<br/>

### Date.prototype.toTimeString

사람이 읽을 수 있는 형식으로 Date 객체의 시간을 표현한 문자열을 반환한다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toTimeString(); // -> 12:30:00 GMT+0900 (대한민국 표준시)
```

<br/>

### Date.prototype.toISOString

`ISO 8601` 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.

```js
today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toISOString(); // -> 2020-07-24T03:30:00.000Z
today.toISOString().slice(0, 10); // -> 2020-07-24
today.toISOString().slice(0, 10).replace(/-/g, ""); // -> 20200724
```

<br/>

### Date.prototype.toLocaleString

인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다. 인수를 생략한 경우, 브라우저가 동작 중인 시스템의 로캘을 적용한다.

```js
today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toLocaleString(); // -> 2020. 7. 24. 오후 12:30:00
today.tolocaleString("ko-KR"); // -> 2020. 7. 24. 오후 12:30:00
today.toLocaleString("en-US"); // -> 7/24/2020, 12:30:00 PM
today.toLocaleString("ja-JP"); // -> 2020/7/24 12:30:00
```

<br/>

### Date.prototype.toLocaleTimeString

인수로 전달한 로캘을 기준으로 Date 객체의 시간을 표현한 문자열을 반환한다. 인수를 생략한 경우, 브라우저가 동작 중인 시스템의 로캘울 적용한다.

```js
today.toString(); // -> Fri Jul 24 202012:30:00 GMT+0900 (대한민국표준시)
today.toLocaleTimeString(); // -> 오후 12:30:00
today.toLocaleTimeString("ko-KR"); // -> 오후 12:30:00
today.toLocaleTimeString("en-US"); // -> 12:30:00 PM
today.toLocaleTimeString("ja-JP"); // -> 12:30:00
```

<br/><br/><br/>

<h1 align="center">31.RegExp</h1>

<br/>

<br/><br/><br/>

<h1 align="center">32.String</h1>

<br/>

# String 생성자 함수

표준 빌트인 객체인 String 객체는 생성자 함수 객체다. 따라서 `new` 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다.

String 생성자 함수에 인수를 전달하지 않고 `new` 연산자와 함께 호출하면 `[[StringData]]` 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다.

<br/>

```js
const strObj = new String();
console.log(strObj); // String {length: 0, [[PrimitiveValue]]: 1111}
```

위 예제를 크롬 브라우저의 개발자 도구에서 실행해보면 `[[PrimitiveValue]]`라는 접근할 수 없는 프로퍼티가 보인다. 이는 `[[StringData]]` 내부 슬롯을 가리킨다. ES5에서는 `[[StringData]]`를 `[[PrimitiveValue]]`라 불렀다.

<br/>

String 생성자 함수의 인수로 문자열을 전달하면서 `new` 연산자와 함께 호출하면 `[[StringData]]` 내부 슬롯에 인수로 전달받은 문자열을 할당한 String 래퍼 객체를 생성한다.

```js
const strObj = new String("Roh");
console.log(strObj);
// String {0: "R", 1: "o", 2: "h", length: 3, [[PrimitiveValue]]: "Roh"}
```

<br/>

String 래퍼 객체는 배열과 마찬가지로 `length` 프로퍼티와 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로, 각 문자를 프로퍼티 값으로 갖는 유사 배열 객체이면서 이터러블이다. 따라서 배열과 유사하게 인덱스를 사용히여 각 문자에 접근할 수 있다.

```js
console.log(str0bj[0]); // R
```

<br/>

단, 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.

```js
// 문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
strObj[0] = "S";
console.log(strObj); // 'Roh'
```

<br/>

String 생성자 함수의 인수로 문자열이 아닌 값을 전달하면 인수를 문자열로 강제 변환한 후, `[[StringData]]` 내부 슬롯에 변환된 문자열을 할당한 String 래퍼 객체를 생성한다.

```js
let strObj = new String(123);
console.log(str0bj);
// String {0: "1", 1: ''2", 2: "3", length: 3, [[PrimitiveValue]]: "123"}

strObj = new String(nul1);
console.log(str0bj);
// String {0: "n", 1: ''u", 2: "l", : "l", length: 4, [[PrimitiveValue]J: "null"}
```

<br/>

`new` 연산자를 시용하지 않고 String 생성자 함수를 호출하면 <ins>String 인스턴스가 아닌 문자열을 반환</ins>한다. 이를 이용하여 명시적으로 타입을 변환하기도 한다.

```js
// 숫자 타입 => 문자열 타입
String(1); // -> "1"
String(NaN); // -> "NaN"
String(Infinity); // -> "Infinity

// 불리언 타입 => 문자열 타입
String(true); // -> "true"
String(false); // -> "false"
```

<br/><br/>

# length 프로퍼티

`length` 프로퍼티는 문자열의 문자 개수를 반환한다.

```js
"Hello".length; // ->5
"안녕하세요!".length; // -> 6
```

String 래퍼 객체는 배열과 마찬가지로 `length` 프로퍼티를 갖는다. 그리고 인덱스를 나타내는 숫자를 프로퍼티 키로, 각 문자를 프로퍼티 값으로 가지므로 String 래퍼 객체는 유사 배열 객체다.

<br/><br/>

# String 메서드

String 객체에는 원본 String 래퍼 객체(String 메서드를 호출한 String 래퍼 객체)를 직접 변경하는 메서드는 존재하지 않는다. 즉, String 객체의 메서드는 언제나 새로운 문자열을 반환한다.

문자열은 변경 불가능(immutable)한 원시 값이기 때문에, String 래퍼 객체도 읽기 전용(readonly) 객체로 제공된다.

<br/>

### String.prototype.indexOf

`indexOf` 메서드는 대상 문자열(메서드를 호출한 문자열)에서 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = "Hello World";

// 문자열 str에서 'l’을 검색하여 첫 번째 인덱스를 반환한다.
str.indexOf("l"); // -> 2

// 문자열 str에서 'or'를 검색하여 첫 번째 인덱스를 반환한다.
str.indexOf("or"); // -> 7

// 문자열 str에서 'x'를 검색하여 첫 번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.
str.indexOf("x"); // -> -1
```

<br/>

### String.prototype.search

`search` 메서드는 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = "Hello world";

// 문자열 str에서 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다.
str.search(lol); // -> 4
str.search(lxl); // -> -1
```

<br/>

### String.prototype.includes

ES6에서 도입된 `includes` 메서드는 대상 문자열에 인수로 전달받은 문자열이 포함되어 있는지 확인하여 그 결과를 `true` 또는 `false`로 반환한다.

```js
const str = "Hello world";

str.includes("Hello"); // -> true
str.includes(" "); // -> true
str.includes("x"); // -> false
str.includes(); // -> false
```

`includes` 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
const str = "Hello world";

// 문자열 str의 인덱스 갖쿠터 'l'이 포함되어 있는지 확인
str.includes("l", 3); // -> true
str.includes("H", 3); // -> false
```

<br/>

### String.prototype.startsWith

ES6에서 도입된 `startsWith` 메서드는 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 `true` 또는 `false`로 반환한다.

```js
const str = "Hello world";
// 문자열 str이 'He’로 시작하는지 확인
str.startsWith("He"); // -> true

// 문자열str이 'x'로 시작하는지 확인
str.startsWith("x"); // -> false
```

`startsWith` 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
// 문자열 str의 인덱스 5부터 시작하는 문자열이 ' ’로 시적하는지 확인
str.startsWith(" ", 5); // -> true
```

<br/>

### String.prototype.endsWith

ES6에서 도입된 `endsWith` 메서드는 대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 `true` 또는 `false`로 반환한다.

```js
const str = "Hello world";

// 문자열 str이 'ld’로 끝나는지 확인
str.endsWith("ld"); // -> true
// 문자열 str이 'x'로 끝나는지 확인
str.endsWith("x"); // -> false
```

`endsWith` 메서드의 2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.

```js
// 문자열 str의 처음부터 5자리까지('Hello')가 'lo'로 끝나는지 확인
str.endsWith("lo", 5); // -> true
```

<br/>

### String.prototype.charAt

`charAt` 메서드는 대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환한다.

```js
const str = "Hello";

for (let i = 0; i < str.length; i++) {
  console.log(str.charAt(i)); // H e l l o
}
```

인덱스는 문자열의 범위, 즉 0 ~ (문자열 길이 —1) 사이의 정수이어야 한다. 인덱스가 문자열의 범위를 벗어난 정수인 경우, 빈 문자열을 반환한다.

```js
// 인덱스가 문자열의 범위(0 ~ str.length-1)를 벗어난 경우 빈 문자열을 반환한다.
str.charAt(5); // -> ’’
```

<br/>

`charAt` 메서드와 유사한 문자열 메서드는 `String.prototype.charCodeAt`과 `String.prototype.codePointAt`이 있다.

<br/>

### String.prototype.substring

`substring` 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환한다.

```js
const str = "Hello World";

// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.
str.substring(1, 4); // -> ell
```

<br/>

### String.prototype.slice

`slice` 메서드는 `substring` 메서드와 동일하게 동작한다. 단, `slice` 메서드에는 음수인 인수를 전달할 수 있다. 음수인 인수를 전달하면 대상문자열의 가장 뒤에서부터 시작하여 문자열을 잘라내어 반환한다.

```js
const str = "hello world";

// substring과 slice 메서드는 동일하게 동작한다.
// 0번째부터 5번째 이전 문자까지 잘라내어 반환
str.substring(0, 5); // -> 'hello'
str.slice(0, 5); // -> 'hello'

// 인덱스가 2인 문자부터 마지막 문자까지 잘라내어 반환
str.substring(2); // -> 'llo world'
str.slice(2); // -> 'llo world'

// 인수 < 0 또는 NaN인 경우 0으로 취급된다.
str.substring(-5); // - 'hello world'
// slice 매서드는 음수인 인수를 전달할 수 있다. 뒤에서 5자리를 잘라내어 반환한다.
str.slice(-5); // - 'world'
```

<br/>

### String.prototype.toUpperCase

`toUpperCase` 메서드는 대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.

```js
const str = "Hello World!";
str.toUpperCase(); // -> 'HELLO WORLD!'
```

<br/>

### String.prototype.toLowerCase

`toLowercase` 메서드는 대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.

```js
const str = "Hello World!";
str.tolowerCase(); // -> 'hello world!'
```

<br/>

### String.prototype.trim

`trim` 메서드는 대상 문자열 앞뒤에 공백 문자가 있을 경우 이를 제거한 문자열을 반환한다.

```js
const str = " foo ";
str.trim(); // -> 'foo'
```

<br/>

### String.prototype.repeat

ES6에서 도입된 `repeat` 메서드는 대상 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반환한다.

인수로 전달받은 정수가 0이면 빈 문자열을 반환하고, 음수이면 `RangeError`를 발생시킨다. 인수를 생략하면 기본값 0이 설정된다.

```js
const str = "abc";

str.repeat(); // -> ''
str.repeat(0); // -> ''
str.repeat(1); // -> 'abc'
str.repeat(2); // -> 'abcabc '
str.repeat(2.5); // -> 'abcabc' (2.5 ➔ 2)
str.repeat(-1); // -> RangeError: Invalid count value
```

<br/>

### String.prototype.replace

`replace` 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환한 문자열을 반환한다.

```js
const str = "Hello world";

// str에서 첫 번째 인수 'world'를 검색하여 두 번째 인수 'Roh'로 치환한다.
str.replace("world", "Roh"); // -> 'Hello Roh'
```

<br/>
검색된 문자열이 여럿 존재할 경우 첫 번째로 검색된 문자열만 치환한다.

```js
const str = "Hello world world";
str.replace("world", "Roh"); // -> 'Hello Roh world'
```

<br/>

### String.prototype.split

`split` 메서드는 대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다.

인수로 빈 문자열을 전달하면 각 문자를 모두 분리하고, 인수를 생락하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.

```js
const str = "How are you doing?";

// 공백으로 구분(단어로 구분)하여 배열로 반환한다.
str.split(" "); // -> ["How", "are", "you",. "doing?"]

// \s는 여러 가지 공백 문자(스페이스, 탭 등)를 의마한다. 즉, [\t\r\n\v\f]와 같은 의미다.
str.split(/\s/); // -> ["How", "are", "you", "doing?"]

// 인수로 빈 문자열을 전달하면 각 문자를 모두 분리한다.
str.split(" ");
// -> ["H", "o", "w", " ", "a", "r", "e", " ", "y", "o", "u", " ", "d", "o", "i", "n", "g", "?"]

// 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.
str.split(); // -> ["How are you doing?"]
```

<br/><br/><br/>

<h1 align="center">33.Symbol</h1>

<br/>

# 심벌이란?

심벌(symbol)은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다.

심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들이 위해 사용한다.

<br/><br/>

# 심벌 값의 생성

## Symbol 함수

심벌 값은 Symbol 함수를 호출하여 생성한다. 다른 원시값(문자열, 숫자, 불리언, undefined, null)은 리터럴 표기법을 통해 값을 생성할 수 있지만 심벌 값은 Symbol 함수를 호출하여 생성해야 한다.

이때 생성된 심벌 값은 외부로 노출되 않아 확인할 수 없으며, <ins>다른 값과 절대 중복되지 않는 유일무이한 값</ins>이다.

```js
// Symbol 함수를 호출하여 유일무이한 심벌 값을 생성한다.
const mySymbol = Symbol();
console.log(typeof mySymbol); // symbol

// 심벌 값은 외부로 노출되지 않아 확인할 수 없다.
console.log(mySymbol); // Symbol()
```

언뜻 보면 생성자 함수로 객체를 생성하는 것처럼 보이지만 Symbol 함수는 String, Number, Boolean 생성자 함수와는 달리 `new` 연산자와 함께 호출하지 않는다.

`new` 연산자와 함께 생성자 함수 또는 클래스를 호출하면 객체(인스턴스)가 생성되지만 심벌 값은 변경 불가능한 원시 값이다.

```js
new Symbol(); // TypeError: Symbol is not a constructor
```

<br/>

Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설명(de­scription)으로 디버깅 용도로만 사용되며, 심벌 값 생성에 어떠한 영향도 주지 않는다. 즉, 심벌 값에 대한 설명이 같더라도 생성된 심벌 값은 유일무이한 값이다.

```js
// 심벌 값에 대한 설명이 같더라도 유일무이한 심벌 값을 생성한다.
const mySymbol1 = Symbol("mySymbol");
const mySymbol2 = Symbol("mySymbol");

console.log(mySymbol1 === mySymbol2); // false
```

<br/>

심벌 값도 문자열, 숫자, 불리언과 같이 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다. 다음 예제의 `description` 프로퍼티와 `toString` 메서드는 `Symbol.prototype`의 프로퍼티다.

```js
const rnySymbol = Symbol(" mySymbol");

// 심벌도 래퍼 객체를 생성한다
console.log(mySymbol.description); // mySymbol
console.log(mySymbol.toString()); // Symbol(mySymbol)
```

<br/>

심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.

```js
const mySymbol = Symbol();

// 심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.
console.log(mySymbol + "");
// TypeError: Cannot convert a Symbol value to a string
console.log(+mySymbol);
// TypeError: Cannot convert a Symbol value to a string
```

<br/>

## Symbol.for / Symbol.keyFor 메서드

`Symbol.for` 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리(global symbol registry)에서 해당 키와 일치하는 심벌 값을 검색한다.

- 검색에 성공하면 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환한다.
- 검색에 실패하면 새로운 심벌 값을 생성하여 Symbol.for 메서드의 인수로 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌 값을 반환한다.

```js
// 전역 심벌 레지스트리에 mySymbol이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for("mySymbol");

// 전역 심벌 레지스트리에 mySymbol이라는 키로 저장된 심벌 값이 있으면 해당 심벌 값을 반환
const s2 = Symbol.for("mySymbol");
console.log(s1 === s2); // true
```

<br/>

Symbol 함수는 호출될 때마다 유일무이한 심벌 값을 생성한다. 이때 자바스크립트 엔진이 관리하는 심벌 값 저장소인 전역 심벌 레지스트리에서 심벌 값을 검색할 수 있는 키를 지정할수 없으므로 전역 심벌 레지스트리에 등록되어 관리되지 않는다.

하지만, `Symbol.for` 메서드를 사용하면 애플리케이션 전역에서 중복되지 않는 유일무이한 상수인 심벌 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유할 수 있다.

<br/>

`Symbol.keyFor` 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

```js
// 전역 심벌 레자스트리에 mySymbol이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for(" mySymbol");
// 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출
Symbol.keyFor(s1); // -> mySymbol

// Symbol 함수를 호출하여 생성한 심벌 값은 전역 심벌 레지스트리에 등록되어 관리되지 않는다.
const s2 = Symbol("foo");
// 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출
Symbol.keyFor(s2); // -> undefined
```

<br/><br/>

# 심벌과 상수

```js
// 위, 아래, 왼쪽, 오른쪽을 나타내는 상수를 정의한다.
// 이때 값 1, 2, 3, 4에는 특별한 의미가 없고 상수 이름에 의미가 있다.
const Direction = { UP: 1, DOWN: 2, LEFT: 3, RIGHT: 4 };

// 변수에 상수를 할당
const myDirection = Direction.UP;

if (myDirection === Direction.UP) {
  console.log("You are going UP.");
}
```

위 예제와 같이 값에는 특별한 의미가 없고 상수 이름 자체에 의미가 있는 경우가 있다. 이때 문제는 상수 값 1,2,3,4가 변경될 수 있으며, 다른 변수 값과 중복될 수도 있다는 것이다.

이런한 경우 변경/중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일무이한 심벌 값을 사용할 수 있다.

```js
// 위, 아래, 왼쪽, 오른쪽을 나타내는 상수를 정의한다.
// 중복될 가능성이 없는 심벌 값으로 상수 값을 생성한다.
const Direction = {
  UP: Symbol("up"),
  DOWN: Symbol("down"),
  LEFT: Symbol("left"),
  RIGHT: Symbol("right"),
};

const myDirection = Direction.UP;

if (myDirection === Direction.UP) {
  console.log("You are going UP. ");
}
```

<br/>

> ✍🏻 **enum**
>
> enum은 명명된 숫자 상수의 집합으로 열거형이라고 부른다. 자바스크립트는 enum을 지원하지 않지만, C, 자바, 파이썬 등 여러 프로그래밍 언어와 타입스크립트에서는 enum을 지원한다.
>
> 자바스크립트에서 enum을 흉내 내어 사용하려면 다음과 같이 객체의 변경을 방지하기 위해 객체를 동결하는 `Object.freeze` 메서드와 심벌 값을 사용한다.
>
> ```js
> // JavaScript enum
> // Direction 객체는 불변 객체이며 프로퍼티 값은 유일무이한 값이다.
> const Direction = Object.freeze({
>   UP: Symbol("up"),
>   DOWN: Symbol("down"),
>   LEFT: Symbol("left"),
>   RIGHT: Symbol("right"),
> });
>
> const myDirection = Direction.UP;
>
> if (myDirection === Direction.UP) {
>   console.log("You are going UP ");
> }
> ```

<br/>

<br/><br/>

# 심벌과 프로퍼티 키

객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값으로 만들 수 있으며, 동적으로 생성할 수도 있다.

심벌 값으로 프로퍼티 키를 동적 생성하여 프로퍼티를 만들어 보자. 심벌 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심벌 값에 대괄호를 사용해야 한다. 프로퍼티에 접근할 때도 마찬가지로 대괄호를 사용해야 한다.

```js
const obj = {
  [Symbol.for("mySymbol")]: 1,
};

obj[Symbol.for("mySymbol")]; // -> 1
```

<br/>

심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다. 기존 프로퍼티 카와 충돌하지 않는 것은 물론, 미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없다.

<br/><br/>

# 심벌과 프로퍼티 은닉

심벌 값을 프로퍼티 키로 사용하여ㅠ 생성한 프로퍼티는 `for...in` 문이나 `Object.keys`, `Object.getOwnPropertyNames` 메서드로 찾을 수 없다.

이처럼 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 생성하면 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있다.

```js
const obj = {
  //  심벌 값으로 프로퍼티 키를 생성
  [Symbol("mySymbol")]: 1,
};

for (const key in obj) {
  console.log(key); // 아무것도 출력되지 않는다.
}

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
```

<br/>

하지만, 프로퍼티를 완전하게 숨길 수 있는 것은 아니다. ES6에서 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

```js
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol("mySymbol ")]: 1,
};

// getOwnPropertySymbols 메서드는 인수로 전달한 객체의 심벌 프로퍼티 키를 배열로 반환한다.
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]

// getOwnPropertySymbols 메서드로 심벌 값도 찾을 수 있다.
const symbolKeyl = Object.getOwnPropertySymbols(obj)[0];
console.log(obj[symbolKeyl]); // 1
```

<br/><br/>

# 심벌과 표준 빌트인 객체 확장

일반적으로 표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하여 확장하는 것은 권장하지 않는다. 표준 빌트인 객체는 읽기 전용으로 사용하는 것이 좋다.

```js
Array.prototype.sum = function () {
  return this.reduce((acc, cur) => acc + cur, 0);
};

[1, 2].sum(); // -> 3
```

<br/>

그 이유는 개발자가 직접 추가한 메서드와 미래에 표준 사양으로 추가될 메서드의 이름이 중복될 수 있기 때문이다. 예를 들어, `Array.prototype.find` 메서드가 ES6에 도입되기 이전에 Array.prototype에 사용자 정의 find 메서드를 직접 추가했다면 이름이 중복되어 이전에 추가했던 사용자 정의 find 메서드가 덮어쓴다. 표준 빌트인 메서드를 시용자 정의 메서드가 덮어쓴다면 문제가 된다.

하지만 중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 표준 사양의 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다.

```js
// 심벌 값으로 프로퍼티 키를 동적 생성하면 다른 프로퍼티 키와 절대 충돌하지 않아 안전하다.
Array.prototype[Symbol.for("sum")] = function () {
  return this.reduce((acc, cur) => ace + cur, 0);
};

[1, 2][Symbol.for("sum")](); // -> 3
```

<br/><br/>

# Well-known Symbol

자바스크립트가 기본 제공하는 빌트인 심벌 값이 있다. 빌트인 심벌 값은 Symbol 함수의 프로퍼티에 할당되어 있다.

자바스크립트가 기본 제공하는 빌트인 심벌 값은 ECMAScript 사양에서 **Well-known Symbol**이라 부른다. Well-known Symbol은 자바스크립트 엔진의 내부 알고리즘에 사용된다.

예를 들어, `Array`, `String`, `Map`, `Set`, `TypedArray`, `arguments`, Nodelist, `HTMLCollection`과 같이 `for...of` 문으로 순회가 가능한 빌트인 이터러블은 Well-known Symbol인 `Symbol.iterator`를 키로 갖는 메서드를 가지며, `Symbol.iterator` 메서드를 호출하면 이터레이터를 반환하도록 ECMAScript 사양에 구정되어 있다.

<br/>

만약 빌트인 이터러블이 아닌 일반 객체를 이터러블처럼 동작하도록 구현하고 싶다면 이터레이션 프로토콜을 따르면 된다. 즉, ECMAScript 사양에 규정되어 있는 대로 Well-known Symbol인 Symbol.iterator를 키로 갖는 메서드를 객체에 추가하고 이터레이터를 반환하도록 구현하면 그 객체는 이터러블이 된다.

<br/>

```js
const iterable = {
  // Symbol.iterator 메서드를 구현하여 이터러블 프로토콜을 준수
  [Symbol.iterator]() {
    let cur = 1;
    const max = 5;

    // Symbol.iterator 메서드는 next 매서드를 소유한 이터레이터를 반환
    return {
      next() {
        return { value: curt++, done: cur > max + 1 };
      },
    };
  },
};

for (const num of iterable) {
  console.log(num); // 1 2 3 4 5
}
```

이때 이터레이션 프로토콜을 준수하기 위해 일반 객체에 추가해야 하는 메서드의 키 `Symbol.iterator`는 기존 프로퍼티 키 또는 미래에 추가될 프로퍼티 키와 절대로 중복되지 않을 것이다.

이처럼 심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다.

<br/><br/><br/>

<h1 align="center">34.이터러블</h1>

<br/>

블로그 링크로 대체.

[JavaScript: 이터러블(iterable)과 이터레이터(iterator)](https://chamdom.blog/js-iterable/)

<br/><br/><br/>

<h1 align="center">35.스프레드 문법</h1>

<br/>

ES6에서 도입된 스프레드 문법은 하나로 문쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

**스프레드 문법**을 사용할 수 있는 대상은 `for…of` 문으로 순회할 수 있는 이터러블에 한정된다.

```js
console.log(...[1, 2, 3]); // 1 2 3

console.log(..."Hello"); // H e l l o

console.log(
  ...new Map([
    ["a", "1"],
    ["b", "2"],
  ])
); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 });
// TypeError: Found non-callable @@iterator
```

<br/>

스프레드 문법의 결과는 값이 아니다. 이는 스프레드 문법이 피연산자를 연산하여 값을 생성하는 연산자가 아님을 의미한다. 따라서 **_스프레드 문법의 결과는 변수에 할당할 수 없다._**

```js
// 스프레드 문법의 결과는 값이 아니다.
const list = ...[1, 2, 3]; // SyntaxError: Unexpected token ...
```

<br/><br/>

# 함수 호출문의 인수 목록에서 사용하는 경우

스프레드 문법이 제공되기 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달하고 싶은 경우 `Function.prototype.apply` 를 사용했다.

```js
var arr = [1, 2, 3];

var max = Math.max.apply(null, arr); // -> 3

// 스프레드 문법 사용
const max = Math.max(...arr); // -> 3
```

<br/>

## Rest 파라미터와 스프레드 문법의 차이

Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 …을 붙이는 것이다.

스프레드 문법은 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적이 값들의 목록을 만드는 것이다. 따라서 Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다.

```js
// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.
function foo(...rest) {
  console.log(rest); // 1, 2, 3 -> [ 1, 2, 3 ]
}

// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.
// [1, 2, 3] -> 1, 2, 3
foo(...[1, 2, 3]);
```

<br/><br/>

# 배열 리터럴 내부에서 사용하는 경우

스프레드 문법을 배열 리터럴에서 사용하면 ES5에서 사용하던 기존의 방식보다 더욱 간결하고 가독성 좋게 표현할 수 있다.

<br/>

### concat

ES5에서 2개의 배열을 1개의 배열로 결합하고 싶은 경우 배열 리터럴만으로 해결할 수 없고 `concat` 메서드 를사용해야한다.

```js
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]
```

스프레드 문법을 사용하면 별도의 메서드를 시용히지 않고 배열 리터럴만으로 2개의 배열을 1개의 배열로 결합할수있다.

```js
// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]
```

<br/>

### splice

```js
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

/*
apply 메서드의 2번째 인수(배열)는 apply 메서드가 호출한 splice 메서드의 인수 목록이다.
apply 메서드의 2번째 인수 [1, 0].concat(arr2)는 [1, 0, 2, 3]으로 평가된다.
따라서 splice 메서드에 apply 메서드의 2번째 인수 [1, 0, 2, 3]이 해체되어 전달된다.
즉, arr1[1]부터 0개의 요소를 제거하고 그 자리(arr1[1])에 새로운 요소(2, 3)를 삽입한다.
*/
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));
console.log(arr1); // [1, 2, 3, 4]
```

```js
// ES6
const arr1 = [1, 4];
const arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4]
```

<br/>

### 배열 복사

```js
// ES5
var origin = [1, 2];
var copy = origin.slice();

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

```js
// ES6
const origin = [1, 2];
const copy = [...origin];

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

<br/>

### 이터러블을 배열로 변환

ES5에서 <ins>이터러블 또는 유사 배열 객체를 배열로 변환하려면</ins> `Function.prototype.apply` 또는 `Function.prototype.call` 메서드를 사용하여 `slice` 메서드를 호출해야 한다.

```js
// ES5
function sum() {
  // 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
  var args = Array.prototype.slice.call(arguments);

  return args.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3)); // 6
```

```js
// 이터러블이 아닌 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

const arr = Array.prototype.slice.call(arrayLike); // -> [1, 2, 3]
console.log(Array.isArray(arr)); // true
```

<br/>

**스프레드 문법**을 사용하면 간편하게 이터러블을 배열로 변환할 수 있다. `arguments` 객체는 이터러블이면서 유사 배열 객체다.

```js
// ES6
function sum() {
  // 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

위 예제보다 나은 방법은 **Rest 파라미터**를 사용하는 것이다.

```js
// Rest 파라미터 args는 함수에 전달된 인수들의 목록을 배열로 전달받는다.
const sum = (...args) => args.reduce((pre, cur) => pre + cur, 0);

console.log(sum(1, 2, 3)); // 6
```

<br/><br/><br/>

<h1 align="center">36.디스트럭처링 할당</h1>

<br/>

**디스트럭처링 할당(구조 분해 할당)** 은 구조화된 배열과 같은 이터러블 또는 객체를 **destructuring**(비구조화, 구조 파괴)하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.

<br/><br/>

# 배열 디스트럭처링 할당

```js
// ES5
var arr = [1, 2, 3];

var one = arr[0];
var two = arr[1];
var three = arr[2];

console.log(one, two, three); // 1 2 3
```

배열 디스트럭처링 할당의 대상은 이터러블이어여 하며, 할당 기준은 배열의 인덱스다.

```js
// ES6
const arr = [1, 2, 3];

const [one, two, three] = arr;

console.log(one, two, three); // 1 2 3
```

<br/>

배열 디스트럭처링 할당을 위해서는 연산자 왼쪽의 변수는 **배열 리터럴 형태**로 선언한다. 그리고 우변에 이터러블을 할당하는데, 우변이 이터러블이 아니면 에러가 발생한다.

```js
const [x, y]; // SyntaxError: Missing initializer in destructuring declaration

const [a, b] = {}; // TypeError: {} is not iterable
```

<br/>

배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.

```js
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3

// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
console.log(e, f, g); // 1 2 3
```

<br/><br/>

# 객체 디스트럭처링 할당

```js
// ES5
const user = { firstName: "Kihoon", lastName: "Roh" };

var firstName = user.firstName;
var lastName = user.lastName;

console.log(firstName, lastName); // Kihoon Roh
```

객체 디스트럭처링 할당의 대상은 객체이어야 하며, **할당 기준은 프로퍼티 키**다. 즉, 순서는 의미가 없고 선언된 변수 이름과 프로퍼티 키가 일치하면 할당된다.

```js
const user = { firstName: "Kihoon", lastName: "Roh" };

// ES6 객체 디스트럭처링 할당
// 변수 lastName, firstName을 선언하고 user 객체를 디스트럭처링하여 할당한다.
// 이때 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.
const { lastName, firstName } = user;

console.log(firstName, lastName); // Kihoon Roh
```

<br/>

## 프로퍼티 축약 표현

```js
const { lastName, firstName } = user;
// 위와 아래는 동치다.
const { lastName: lastName, firstName: firstName } = user;
```

객체 리터럴 형태로 선언한 `lastName`, `firstName`은 **프로퍼티 축약 표현**을 통해 선언한 것이다. 따라서 객체의 프로퍼치 키와 다른 변수 이름으로 값을 할당받으려면 다음과 같이 변수를 선언한다.

```js
const user = { firstName: "Kihoon", lastName: "Roh" };

const { lastName: ln, firstName: fn } = user;

console.log(fn, ln); // Kihoon Roh
```

<br/>

객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다.

```js
const { firstName = "Kihoon", lastName } = { lastName: "Roh" };
console.log(firstName, lastName); // Kihoon Roh

const { firstName: fn = "kIHOON", lastName: ln } = { lastName: "Roh" };
console.log(fn, ln); // Kihoon Roh
```

<br/>

객체 디스트럭처링 할당은 객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```js
const str = "Hello";
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5

const todo = { id: 1, content: "HTML", completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

객체 디스트럭처링 할당은 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.

```js
function printTodo({ content, completed }) {
  console.log(`할일 ${content}은 ${completed ? "완료" : "비완료"} 상태입니다.`);
}

printTodo({ id: 1, content: "HTML", completed: true });
// 할일 HTML은 완료 상태입니다.
```

<br/>

배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.

```js
const todos = [
  { id: 1, content: "HTML", completed: true },
  { id: 2, content: "CSS", completed: false },
  { id: 3, content: "JS", completed: false },
];

// todos 배열의 두 번째 요소인 객체로부터 id 프로퍼티만 추출한다.
const [, { id }] = todos;
console.log(id); // 2
```

<br/>

중첩 객체의 경우는 다음과 같이 사용한다.

```js
const user = {
  name: "Roh",
  address: {
    zipCode: "03068",
    city: "Incheon",
  },
};

// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출한다.
const {
  address: { city },
} = user;
console.log(city); // 'Seoul'
```

<br/>

객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터나 Rest 요소와 유사하게 Rest 프로퍼티 ...을 사용할 수 있다. Rest 프로퍼티는 Rest 파라미터나 Rest 요소와 마찬가지로 반드시 마지막에 위치해야 한다.

```js
// Rest 프로퍼티
const { x, ...rest } = { x: 1, y: 2, z: 3 };

console.log(x, rest); // 1 {y: 2, z: 3}
```

<br/><br/><br/>

<h1 align="center">37.Set과 Map</h1>

<br/>

# Set

`Set` 객체는 중복되지 않는 유일한 값들의 집합이다. `Set`은 수학적 집합을 구현하기 위한 자료구조다. 따라서 `Set`을 통해 교집합, 차집합, 합집합, 여집합 등을 구현할 수 있다.

<br/>

## Set 객체의 생성

Set 객체는 Set 생성자 함수로 생성한다. Set 생성자 함수에 인수를 전달하지 않으면 빈 Set 객체가 생성된다.

```js
const set = new Set();
console.log(set); // Set(0) {}
```

**_Set 생성자 함수는 이터러블을 인수로 받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다._**

```js
const set1 = new Set([1, 2, 3, 3]);
console.log(set1); // Set(3) {1, 2, 3}

const set2 = new Set("hello");
console.log(set2); // Set(4) {"h", "e", "l", "o"}
```

`Set` 객체의 특성을 이용해 배열의 중복된 요소를 제거할 수 있다.

```js
// 배열의 중복 요소 제거
const uniq = (array) => array.filter((v, i, self) => self.indexOf(v) === i);
console.log(uniq([2, 1, 2, 3, 4, 3, 4])); // [2, 1, 3, 4]

// Set을 사용한 배열의 중복 요소 제거
const uniq = (array) => [...new Set(array)];
console.log(uniq([2, 1, 2, 3, 4, 3, 4])); // [2, 1, 3, 4]
```

<br/>

## 요소 개수 확인

`Set` 객체의 요소 개수를 확인할 때는 `Set.prototype.size` 프로퍼티를 사용한다.

```js
const set = new Set([1, 2, 3, 3]);
console.log(set.size); // 3

// 위와 아래는 동치다.
const { size } = new Set([1, 2, 3, 3]);
console.log(size); // 3
```

`size` 프로퍼티는 `getter` 함수만 존재하는 프로퍼티다. 따라서 `size` 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.

<br/>

## 요소 추가

`Set` 객체에 요소를 추가할 때는 `Set.prototype.add` 메서드를 사용한다.

```js
const set = new Set();
console.log(set); // Set(0) {}

set.add(1);
console.log(set); // Set(1) {1}
```

`add` 메서드는 새로운 요소가 추가된 `Set` 객체를 반환한다. 따라서 `add` 메서드를 연속적으로 호출할 수 있다.

```js
const set = new Set();

set.add(1).add(2);
console.log(set); // Set(2) {1, 2}
```

<br/>

**일치 비교 연산자(===)** 를 사용하면 `NaN`과 `NaN`을 다르다고 평가한다. 하지만 `Set` 객체는 `NaN`과 `NaN`을 같다고 평가하여 중복 추가를 허용하지 않는다.

```js
const set = new Set();

console.log(NaN === NaN); // false
console.log(0 === -0); // true

// NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다.
set.add(NaN).add(NaN);
console.log(set); // Set(1) {NaN}

// +0과 -0을 같다고 평가하여 중복 추가를 허용하지 않는다.
set.add(0).add(-0);
console.log(set); // Set(2) {NaN, 0}
```

<br/>

`Set` 객체는 객체나 배열, 함수 등 자바스크립트의 모든 값을 요소로 저장할 수 있다.

```js
const set = new Set();

set
  .add(1)
  .add("a")
  .add(true)
  .add(undefined)
  .add(null)
  .add({})
  .add([])
  .add(() => {});

console.log(set);
// Set(8) { 1, 'a', true, undefined, null, {}, [], [Function (anonymous)] }
```

<br/>

## 요소 존재 여부 확인

`Set` 객체에 특정 요소가 존재하는지 확인하려면 `Set.prototype.has` 메서드를 사용한다. `has` 메서드는 **특정 요소의 존재 여부를 나타내는 불리언 값을 반환**한다.

```js
const set = new Set([1, 2, 3]);

console.log(set.has(2)); // true
console.log(set.has(4)); // false
```

<br/>

## 요소 삭제

`Set` 객체의 특정 요소를 삭제하려면 `Set.prototype.delete` 메서드를 사용한다. `delete` 메서드는 **삭제 성공 여부를 나타내는 불리언 값을 반환**한다.

**`Set` 객체는 순서에 의미가 없다.** 즉, 인덱스를 갖지 않는다. 따라서 `delete` 메서드에 삭제하려는 **요소값을 전달**해야 한다.

```js
const set = new Set([1, 2, 3]);

set.delete(2);
console.log(set); // Set(2) {1, 3}

set.delete(1);
console.log(set); // Set(1) {3}
```

`delete` 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환하기 때문에 연속적으로 호출할 수 없다.

```js
const set = new Set([1, 2, 3]);

set.delete(1).delete(2); // TypeError: set.delete(...).delete is not a function
```

<br/>

## 요소 일괄 삭제

`Set` 객체의 모든 요소를 일괄 삭제하려면 `Set.prototype.clear` 메서드를 사용한다. `clear` 메서드는 언제나 `undefined`를 반환한다.

```js
const set = new Set([1, 2, 3]);

set.clear();
console.log(set); // Set(0) {}
```

<br/>

## 요소 순회

`Set` 객체의 요소를 순회하려면 `Set.prototype.forEach` 메서드를 사용한다.

`Array.prototype.forEach` 메서드와 유사하게 동작하며, 콜백 함수가 전달받는 인수 3가지는 다음과 같다.

- **첫 번째 인수:** 현재 순회 중인 요소값
- **두 번째 인수:** 현재 순회 중인 요소값
- **세 번째 인수:** 현재 순회 중인 Set 객체 자체

<br/>

첫 번째 인수와 두 번째 인수는 같은 값이다. 이처럼 동작하는 이유는 `Array.prototype.forEach` 메서드와 인터페이스를 통일하기 위함이며 다른 의미는 없다.

`Set` 객체는 **순서에 의미가 없어** 배열과 같이 인덱스를 갖지 않기 때문에 두 번째 인수로 인덱스를 전달받지 않는다.

```js
const set = new Set([1, 2, 3]);

set.forEach((v1, v2, set) => console.log(v1, v2, set));
/*
1 1 Set(3) {1, 2, 3}
2 2 Set(3) {1, 2, 3}
3 3 Set(3) {1, 2, 3}
*/
```

<br/>

**_Set 객체는 이터러블이다._** 따라서 `for…of` 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링의 대상이 될 수 있다.

```js
const set = new Set([1, 2, 3]);

// Set 객체는 이터러블이다.
console.log(Symbol.iterator in set); // true

// Set 객체는 for...of 문으로 순회할 수 있다.
for (const value of set) {
  console.log(value); // 1 2 3
}

// Set 객체는 스프레드 문법의 대상이 될 수 있다.
console.log([...set]); // [1, 2, 3]

// Set 객체는 배열 디스트럭처링 할당의 대상이 될 수 있다.
const [a, ...rest] = [...set];
console.log(a, rest); // 1, [2, 3]
```

`Set` 객체는 요소의 순서에 의미를 갖지 않지만, **_Set 객체를 순회하는 순서는 요소가 추가된 순서를 따르다._** 이는 ECMAScript 시양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.

<br/>

## 집합 연산

### 교집합

```js
Set.prototype.intersection = function (set) {
  return new Set([...this].filter((v) => set.has(v)));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

// setA와 setB의 교집합
console.log(setA.intersection(setB)); // Set(2) {2, 4}
// setB와 setA의 교집합
console.log(setB.intersection(setA)); // Set(2) {2, 4}
```

<br/>

### 합집합

```js
Set.prototype.union = function (set) {
  return new Set([...this, ...set]);
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

// setA와 setB의 합집합
console.log(setA.union(setB)); // Set(4) {1, 2, 3, 4}
// setB와 setA의 합집합
console.log(setB.union(setA)); // Set(4) {2, 4, 1, 3}
```

<br/>

### 차집합

```js
Set.prototype.difference = function (set) {
  return new Set([...this].filter((v) => !set.has(v)));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

// setA에 대한 setB의 차집합
console.log(setA.difference(setB)); // Set(2) {1, 3}
// setB에 대한 setA의 차집합
console.log(setB.difference(setA)); // Set(0) {}
```

<br/>

### 부분 집합과 상위 집합

집합 A가 집합 B에 포함되는 경우$(A \subseteq B)$ 집합 A는 집합 B의 **부분 집합**이며, 집합 B는집합 A의 **상위 집합**이다.

```js
// this가 subset의 상위 집합인지 확인한다.
Set.prototype.isSuperset = function (subset) {
  const supersetArr = [...this];
  return [...subset].every((v) => supersetArr.includes(v));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

// setA가 setB의 상위 집합인지 확인한다.
console.log(setA.isSuperset(setB)); // true
// setB가 setA의 상위 집합인지 확인한다.
console.log(setB.isSuperset(setA)); // false
```

<br/><br/>

# Map

`Map` 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. `Map` 객체는 객체와 유사하지만 다음과 같은 차이가 있다.

| **구분**               | **객체**                | **Map 객체**          |
| ---------------------- | ----------------------- | --------------------- |
| 키로 사용할 수 있는 값 | 문자열 또는 심벌 값     | 객체를 포함한 모든 값 |
| 이터러블               | X                       | O                     |
| 요소 개수 확인         | Object.keys(obj).length | map.size              |

<br/>

## Map 객체의 생성

`Map` 객체는 Map 생성자 함수로 생성한다.

```js
const map = new Map();
console.log(map); // Map(0) {}
```

**_Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다._**

```js
const map = new Map([
  ["key1", "value1"],
  ["key1", "value2"],
]);
console.log(map); // Map(1) { 'key1' => 'value2' }
```

<br/>

## 요소 개수 확인

`Map` 객체의 요소 개수를 확인할 때는 `Map.prototype.size` 프로퍼티를 사용한다.

```js
const map = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);
console.log(map.size); // 2
```

`size` 프로퍼티는 `getter` 함수만 존재하는 접근자 프로퍼티다. 따라서 `size` 프로퍼티에 숫자를 할당하여 `Map` 객체의 요소 개수를 변경할 수 없다.

<br/>

## 요소 추가

`Map` 객체에 요소를 추가할 때는 `Map.prototype.set` 메서드를 사용한다.

```js
const map = new Map();
console.log(map); // Map(0) {}

map.set("key1", "value1");
console.log(map); // Map(1) {"key1" => "value1"}
```

**_set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다. 따라서 set 메서드는 연속적으로 호출할 수 있다._**

```js
const map = new Map();

map.set("key1", "value1").set("key2", "value2");

console.log(map); // Map(2) {"key1" => "value1", "key2" => "value2"}
```

객체는 문자열 또는 심벌 값만 키로 사용할 수 있지만, `Map` 객체는 키 타입에 제한이 없다.

```js
const map = new Map();

const kim = { name: "Kim" };
const roh = { name: "Roh" };

// 객체도 키로 사용할 수 있다.
map.set(roh, "fe-developer").set(kim, "be-developer");

console.log(map);
// Map(2) { { name: 'Roh' } => 'fe-developer', { name: 'Kim' } => 'be-developer'}
```

<br/>

## 요소 취득

`Map` 객체에서 특정 요소를 취득하려면 `Map.prototype.get` 메서드를 사용한다. `get` 메서드의 인수로 키를 전달하면 `Map` 객체에서 인수로 전달한 키를 갖는 값을 반환한다.

```js
const map = new Map();

map.set("roh", "fe-developer").set("kim", "be-developer");

console.log(map.get("roh")); // fe-developer
console.log(map.get("key")); // undefined
```

<br/>

## 요소 존재 여부 확인

`Map` 객체에서 특정 요소가 존재하는지 확인하려면 `Map.prototype.has` 메서드를 사용한다. `has` 메서드는 존재 여부를 불리언 값으로 반환한다.

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);

console.log(map.has("roh")); // true
console.log(map.has("key")); // false
```

<br/>

## 요소 삭제

`Map` 객체의 요소를 삭제하려면 `Map.prototype.delete` 메서드를 사용한다. `delete` 메서드는 삭제 성공 여부를 불리언 값으로 반환한다.

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);

map.delete("kim");
console.log(map); // Map(1) { 'roh' => 'fe-developer' }
```

`delete` 메서드는 불리언 값을 반환하기 때문에 `set` 메서드와 달리 연속적으로 호출할 수 없다.

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);

map.delete("roh").delete("kim");
//TypeError: map.delete(...).delete is not a function
```

<br/>

## 요소 일괄 삭제

`Map` 객체의 요소를 일괄 삭제하려면 `Map.prototype.clear` 메서드를 사용한다.

`clear` 메서드는 언제나 `undefined`를 반환한다.

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);

map.clear();
console.log(map); // Map(0) {}
```

<br/>

## 요소 순회

`Map` 객체의 요소를 순회하려면 `Map.prototype.forEach` 메서드를 사용한다.

`Array.prototype.forEach` 메서드와 유사하게 동작한며 콜백 함수가 전달받는 인수 3가지는 다음과 같다.

- **첫 번째 인수:** 현재 순회 중인 요소값
- **두 번째 인수:** 현재 순회 중인 요소값
- **세 번째 인수:** 현재 순회 중인 Map 객체 자체

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);
map.forEach((v, k, map) => console.log(v, k, map));

/*
fe-developer roh Map(2) { 'roh' => 'fe-developer', 'kim' => 'be-developer' }
be-developer kim Map(2) { 'roh' => 'fe-developer', 'kim' => 'be-developer' }
*/
```

<br/>

`Map` 객체는 이터러블이다. 따라서 `for…of` 문으로 순회할 수 있고, 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수 있다.

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);

// Map 객체는 Map.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다.
console.log(Symbol.iterator in map); // true

// 이터러블인 Map 객체는 for...of 문으로 순회할 수 있다.
for (const entry of map) {
  console.log(entry); // [ 'roh', 'fe-developer' ] [ 'kim', 'be-developer' ]
}

// 이터러블인 Map 객체는 스프레드 문법의 대상이 될 수 있다.
console.log([...map]);
// [ [ 'roh', 'fe-developer' ], [ 'kim', 'be-developer' ] ]

// 이터러블인 Map 객체는 배열 디스트럭처링 할당의 대상이 될 수 있다.
const [a, b] = map;
console.log(a, b);
// [ 'roh', 'fe-developer' ] [ 'kim', 'be-developer' ]
```

<br/>

`Map` 객체는 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.

| **Map 메서드**        | **설명**                                                                                |
| --------------------- | --------------------------------------------------------------------------------------- |
| Map.prototype.keys    | Map 객체에서 요소키를 값으로 갖는 이터러블이면서 이터레이터인 객체를 반환한다.          |
| Map.prototype.values  | Map 객체에서 요소값을 값으로 갖는 이터러블이면서 이터레이터인 객체를 반환한다.          |
| Map.prototype.entries | Map 객체에서 요소키와 요소값를 값으로 갖는 이터러블이면서 이터레이터인 객체를 반환한다. |

<br/>

```js
const map = new Map([
  ["roh", "fe-developer"],
  ["kim", "be-developer"],
]);

for (const key of map.keys()) {
  console.log(key); // roh  kim
}

for (const value of map.values()) {
  console.log(value); // fe-developer  be-developer
}

for (const entry of map.entries()) {
  console.log(entry);
  // [ 'roh', 'fe-developer' ] [ 'kim', 'be-developer' ]
}
```
