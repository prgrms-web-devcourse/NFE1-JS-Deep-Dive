# 09Ch-타입 변환과 단축 평가

## 📚 타입 변환이란?

- 자바스크립트의 모든 값은 타입이 존재
- 명시적 타입 변환(타입 캐스팅)

  - 개발자가 의도적으로 값의 타입을 변환하는 것
  - 개발자의 타입 변경 의지가 코드에 명백히 보임

  ```tsx
  var example = 99;

  var str = example.toString();
  console.log(typeof str, str); // string 99

  console.log(typeof example, example); // number 99
  ```

- 암묵적 타입 변환(타입 강제 변환)

  - 개발자의 의도와 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 타입이 자동 변환 되는 것
  - 개발자의 타입 변경 의지가 코드에 명백하지 않음

  ```tsx
  var example = 99;

  var str = example + "";
  console.log(typeof str, str); // string 99
  console.log(typeof example, example); // number 10
  ```

- 기존 원시 값을 변경하는 것이 아닌 다른 타입의 새로운 원시 값을 생성한다. 즉, 기존 원시 값은 변경되지 않는다
- 코드 예측을 할 수 있는 것이 중요함
  → 코드 작성시 암묵적 타입 변환의 발생 여부, 발생시 어떤 타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식이 어떻게 평가될 것인지 예측이 가능해야함
  → 예측과 다른 경우 오류 생산 가능성이 증가하기 때문

## 📚 암묵적 타입 변환

<aside>
💡

자바스크립트 엔진은 표현식을 평가할 때 개발자의 의도와는 상관없이 데이터 타입을 강제 변환하는 경우가 있다

</aside>

- 암묵적 타입 변환시 원시 타입 중 하나로 타입을 자동으로 변환한다

  ```tsx
  "20" + 24; // '2024'

  10 * "10"; // 100

  !0; // true
  ```

### 문자열 타입 변환

> 문자열을 연결하는 연산자의 모든 피연산자는 모두 문자열 타입으로 암묵적 타입 변환을 한다

- 연산자 표현식의 피연산자만이 암묵적 타입 변환의 대상이 되는 것은 아니며, 자바스크립트 엔진이 표현식을 평가시 코드 문맥에 부합하도록 암묵적 타입 변환을 실행한다

```tsx
// example
Nan + '' // 'NaN'
Infinity + '' // 'Infinity'
true + '' // 'true'
undefined + '' // 'undefined'
[] + '' // ""
[10, 20] + '' // '10,20'
```

### 숫자 타입 변환

> 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 숫자 타입으로 변환할 수 없는 경우 표현식의 평가 결과는 `NaN`이 된다.

```tsx
1 - "1"; // 0
1 * "10"; // 10
1 / "one"; // NaN
```

- 비교 연산자는 크기를 비교하므로 피연산자 중 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환을 실행한다

```tsx
// example
+"" + // 0
  "0" + // 0
  true + // 1
  null; // 0
```

- 객체, 빈 배열이 아닌 배열, undefined는 변환되지 않아 `NaN`이 된다

### 불리언 타입 변환

> 조건식의 평과 결과를 불리언 타입으로 암묵적 타입 변환을 한다

```tsx
if ("") console.log("1");
if (true) console.log("2");
if ("str") console.log("4");
if (null) console.log("5");

// 2 4
```

- 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분
  - 즉, 불리언 값으로 평가되는 경우 Truhy는 값은 true, Falsy 값은 false로 암묵적 타입 변환
- false로 평가되는 Falsy 값
  - false
  - undefined
  - null
  - 0, -0
  - NaN
  - ‘’(빈 문자열)
- Falsy 값 이외 모든 값은 모두 Truthy 값, 즉 true로 평가됨

## 📚 명시적 타입 변환

<aside>
💡

표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출, 빌트인 메서드 사용, 암묵적 타입 변환을 이용과 같은 다양한 방법이 존재한다

</aside>

### 문자열 타입 변환

1. String 생성자 함수를 new 연산자 없이 호출 `String(1) // 1`
2. Object.prototype.toString 메서드 사용 `(Infinity).toString() // 'Infinity'`
3. 문자열 연결 연산자 이용 `1 + ‘’ // ‘1’`

### 숫자 타입 변환

1. Number 생성자 함수를 new 연산자 없이 호출 `Number('-1') // -1`
2. parseInt, parseFloat 함수를 사용(문자열만 숫자 타입으로 변환 가능) `parseInt('0') // 0`
3. - 단항 산술 연산자 이용 `+'10' // 10` `+true // 1`
4. - 산술 연산자 이용 `'0' * 1 // 0`

### 불리언 타입 변환

1. Boolean 생성자 함수를 new 연산자 없이 호출 `Boolean('x') // true` `Boolean('') // false`
2. ! 부정 논리 연산자를 두 번 사용 `!!'x' // true` `!!'' // false` `!!NaN // false` `!!Infinity // true`

## 📚 단축 평가

### 논리 연산자를 사용한 단축 평가

- 논리합(||) 또는 논리곱(&&)연산자 표현식의 평가결과는 불리언 값이 아닐 수도 있다. 논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다
- **단축 평가는** 논리 연산의 결과를 결정하는 피연산자를 타입 변환 없이 그대로 반환하는 것을 의미한다
  - 단축 평가 사용시 if문 대체 가능
- `논리곱(&&) 연산자`는 두 개의 피연산자가 모두 true인 경우 true를 반환하며 좌항에서 우항으로 평가가 진행된다

  ```tsx
  true || anything; // true
  false || anything; // anything
  true && anything; // anything
  false && anything; // false

  "Cat" || "Dog"; // 'Cat'
  false || "Dog"; // 'Dog'
  "Cat" || false; // 'Cat'

  "Cat" && "Dog"; // Dog
  false && "Dog"; // false
  "Cat" && false; // false
  ```

  - 사용되는 유용한 패턴들
    1. 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조하는 경우
    2. 함수 매개변수에 기본값을 설정하는 경우
       - 함수 호출시 인수를 전달하지 않는 경우 매개변수에 undefined가 할당되는데, 단축 평가 사용함으로 매개변수의 기본값을 설정하여 undefined 발생으로 인한 에러를 방지할 수 있음

- `옵셔널 체이닝 연산자` 는 옵셔널 체이닝 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어감
  ```tsx
  var elem = null;
  // elem이 null 또는 undefined이면 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
  var value = elem?.value;
  console.log(value); // undefined
  ```
  - 좌항 피연산자가 false로 평가되는 Falsy 값(false, undefined, nulll, 0, -0, NaN, ‘’)이라도 null 또는 undfined가 아니면 우항의 프로퍼티 참조를 이어감
- `null 병합 연산자` ??는 좌항의 피연산자가 null 또는 undfined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환
  - 변수에 기본값 설정시 유용

# 10Ch-객체 리터럴

## 📚 객체란?

> 자바스크립트는 객체 기반의 프로그래밍 언어이며, 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체이다

### 원시 타입과 객체 타입

- 변수를 위해선 임시적인 저장 공간인 메모리 구조를 알아야함
- 원시 타입은 단일 메모리에 할당 되지만, 객체 타입은 메모리 주소가 할당됨
  - 변수는 변수가 지정된 주소를 참조하는 것이다
- `원시 타입` 변경 불가능한 값으로, 원시 값을 변수에 할당하면 메모리 공간에는 실제 값이 저장됨(원시 값 자체의 변경 ≠ 변수 값 변경)
  - 원시 타입은 값이 변경시 항상 새로운 메모리에 할당됨
  - 읽기 전용의 값
  - 재할당 이외에 변수 값을 변경할 수 있는 방법은 없음
    - cf) 객체를 변수에 할당하면 메모리에는 참조값이 저장됨
  - `값에 의한 전달`: 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달됨
  - `참조에 의한 전달`: 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨
- `객체타입` 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조로, 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음
- 자바스크립트에서 사용될 수 있는 모든 값은 프로퍼티 값으로 사용될 수 있음
  - 함수 역시 자바스크립트에서는 `일급 객체`이므로 프로퍼티가 될 수 있음
    - 프로퍼티: 객체의 상태를 나타내는 값(data)
  - 프로퍼티 값이 함수인 경우에는 이를 `메서드`라고 함
    - 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)
- `클래스 기반` 객체지향 언어에서의 객체 생성
  - 클래스를 사전에 정의하고 필요한 시점에서 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성
- `프로토타입 기반` 객체지향 언어에서의 객체 생성 방법(JS 해당)

  - 객체 리터럴: 중괄호 내에 0개 이상의 프로퍼티를 정의하며, 변수에 할당되는 시점에 JS 엔진이 객체 리터럴을 해석하여 객체를 생성

    ```tsx
    let person = {
      name: "정혜인",
    // Key를 따옴표로 감싸지 않으면, 자바스크립트 엔진은 식별자로 해석
      sayHello: () => {
        console.log(`이름은 ${this.name}`);
      },


    console.log(typeof person); //object
    console.log(person); //{name: "정혜인", sayHello: f}
    ```

    - `name`은 문자열 `"정혜인"`을 값으로 갖는 데이터 프로퍼티
    - `sayHello`는 함수(메서드)를 값으로 가지는 메서드 프로퍼티
    - 코드 블록은 세미콜론을 붙이지 않으나, 객체 리털은 값으로 평가되는 표현식이므로 세미콜론을 붙여야함
    - 프로퍼티 key는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값, 프로퍼티 value는 자바스크립트에서 사용할 수 있는 모든 값

  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스(ES6)

- 프로퍼티 접근 방법

  ```tsx
  let person = {
    name: "정혜인",
  };

  console.log(person.name); // 정혜인
  console.log(person["name"]); // 정혜인
  ```

# 11Ch-원시 값과 객체의 비교

- 원시 타입(primitive type): 변경 불가능한 값으로, 원시 값을 변수에 할당하면 메모리 공간에는 실제 값이 저장됨(원시 값 자체의 변경 ≠ 변수 값 변경)
  - 원시 타입은 값이 변경시 항상 새로운 메모리에 할당됨
  - 읽기 전용의 값
  - 재할당 이외에 변수 값을 변경할 수 있는 방법은 없음
    - cf) 객체를 변수에 할당하면 메모리에는 참조값이 저장됨
  - `값에 의한 전달`: 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달됨
  - `참조에 의한 전달`: 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨

|                           | 원시 타입                                                      | 객체 타입                                                        |
| ------------------------- | -------------------------------------------------------------- | ---------------------------------------------------------------- |
| 값의 가변성               | 변경 **불가능**한 값으로, 원시 값은 원시 타입의 값을 의미      | 변경 **가능**한 값으로 객체는 객체(참조) 타입의 값을 의미        |
| 저장되는 값               | 할당된 메모리 공간에는 실제 값이 저장됨                        | 할당된 메모리 공간에는 참조 값이 저장됨                          |
| **다른 변수로 값 할당시** | 원본의 원시 값이 복사되어 전달되며, 이를 값에 의한 전달이라 함 | 원본의 참조 값이 복사되어 전달되며, 이를 참조에 의한 전달이라 함 |

## 📚 원시값

- 원시 타입의 값, 즉 **원시 값**은 **변경 불가능**한 값을 의미
- 한 번 생성된 원시 값은 읽기 전용(read only)값 이기에 변경할 수 없음
- `변수`는 하나의 값을 저장하기 위해 확보한 메모리 공간 or 메모리 공간을 식별하기 위해 붙인 이름
- `값`은 변수에 저장된 데이터
- `변경 불가능하다` 의 의미란?
  - 변경 불가능하다는 것은 변수가 아니라 `값에 대한 진술` 로, "원시 값은 변경 불가능하다."
  - `원시 값 자체를 변경할 수 없다 → O`
  - `변수 값을 변경할 수 없다 → X`
- 변수(variable)
  - 변수는 언제든지 `재할당`을 통해 변수 값을 변경(교체)할 수 있음
- 상수(constant)
  - 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라 할 수 있음
  - 상수는 단 한 번만 할당이 허용하므로 변수 값을 변경할 수 없음
- 원시값을 재할당하는 경우 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수가 새롭게 재할당한 원시 값을 가리키므로 변수가 참조하던 메모리 공간의 주소가 바뀜
  - **변수에 할당된 원시 값이 변경 불가능한 값이기 때문에** 변수 값을 변경하기 위해서 **원시 값을 재할당** 할 경우 `새로운 메모리 공간 확보 → 재할당 값 저장 → 변수가 참조하던 메모리 공간의 주소 변경`과 같은 순서로 재할당

## 📚 불변성

> 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경하는 것을 의미

- 불변성을 갖는 원시 값을 할당한 변수의 값을 변경하는 유일한 방법으론 `재할당` 이 있음

## 📚 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면 할당받은 변수에는 할당되는 `변수의 원시 값이 복사되어 전달되는 것`을 의미
- 즉, 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달됨

<aside>
💡

주의할 점은 값이 아닌 **메모리 주소**를 전달한다는 것

- 변수에는 값이 전달되는 것이 아닌 메모리 주소가 전달되기 때문이다
- 즉, 변수와 같은 식별자는 값이 아닌"메모리 주소를 기억하고 있음을 알 수 있다

⇒ 한 변수에 원시 값을 갖는 변수를 할당하면, 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어, 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것을 의미한다

</aside>

- cf) `참조에 의한 전달`: 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨

## 📚 객체

- **객체의 특징**
  - 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가 및 삭제할 수 있음
  - 프로퍼티의 값에도 제약이 없음
  - 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없음
- 객체는 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**(reference value)에 접근할 수 있으며, 참조 값은 생성된 객체가 저장된 메모리 공간의 주소를 의미한다
- **원시 값을 할당한 변수 →** "변수는 @값을 갖는다.", "변수의 값은 @다."
- **객체를 할당한 변수 →** "변수는 객체를 참조하고 있다.", "변수는 객체를 가리키고(Point) 있다."
- 객체 특징에 따른 성능 정리
- 객체의 생성 & 관리 방식은 매우 복잡하며 비용이 많이 든다
  - 프로퍼티의 동적인 추가 및 갱신, 삭제가 가능하기 때문
  - 메모리의 효율적 소비가 어렵고 성능이 나빠짐
- 메모리 효율적 사용을 위해, 객체 복사 비용 절약을 통한 성능 향상을 위해 객체는 **변경 가능한 값**으로 설계됨

## 📚 Shallow Copy(얕은 복사)와 Deep Copy(깊은 복사)

- Shallow Copy(얕은 복사)
  - 동일한 메모리 주소를 참조하는 할당 방식이다.

```jsx
const obj1 = obj2;
console.log(obj1 === obj2); //true
```

- Deep Copy(깊은 복사)
  - 다른 메모리 주소를 가지도록 하는 할당 방식이다.
  - 이때, 할당하는 객체가 1차원 객체인지 2차원 이상 객체인지에 따라 깊은 복사인지의 여부가 결정된다.
  - 1차원 객체인 경우, 객체 전부가 깊은 복사를 진행한다. 하지만 2차원 이상 객체인 경우, 객체 중 1차원 객체만 깊은 복사를 진행하고 2차원 이상 객체는 얕은 복사를 진행한다.
  - 2차원 이상 객체 역시 깊은 복사를 하고 싶은 경우, 직접 값을 할당하거나 JSON,parse, JSON,stringfy를 활용하여 할당해야 한다.
- 1차원 객체 복사
  - 이때, 2차원 이상 객체의 경우 일부만 깊은 복사를 진행한다.

```jsx
const obj1 = { ...obj2 };
const obj1 = object.assign({}, obj2);
const obj1 = Array.from(obj2);
```

- 2차원 객체 복사

```jsx
const obj1 = JSON.parse(JSON.stringfy(obj2));
```

# 12Ch-함수

## 📚 함수란?

- 함수란 일련의 과정을 문(Statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 매개변수(Parameter) , 인수(Argument, 입력) , 반환값(Return Value)을 갖는다
- 이는 함수 정의(Function Definition)를 통해 생성, 함수 호출(Function Call/Invoke)을 통해 명시적으로 함수의 실행을 지시해야함
- 중복 억제와 높은 재사용성으로 유지보수의 편의성을 높이고, 실수를 줄여 코드의 신뢰성 을 높임
- 적절한 함수명을 통해 코드의 가독성 을 향상시킬 수 있음

| 구성 요소                                                                  | 설명                                                                                                 |
| -------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 함수 이름                                                                  | 함수 몸체 안에서만 참조할 수 있는 식별자로 생략이 가능함                                             |
| 유무에 따라 기명 함수, 무명/익명 함수라 칭함                               |
| 매개변수 목록                                                              | 호출할 때 전달한 인수가 순서대로 할당됨                                                              |
| 함수 몸체 내에서 변수와 동일하게 취급되며, 식별자 네이밍 규칙을 준수해야함 |
| 함수 몸체                                                                  | 함수가 호출될 때 실행할 문들을 실행 단위로 정의한 코드 블록으로, 함수 몸체는 함수 호출에 의해 실행됨 |

## 📚 함수 정의

- 함수 선언문
  ```tsx
  function add(x, y) {
    return x + y;
  }
  ```
- 함수 표현식
  ```tsx
  var add = function (x, y) {
    return x + y;
  };
  ```
- Function 생성자 함수
  ```tsx
  var add = new Function("x", "y", "return x + y");
  ```
- 화살표 함수(ES6)
  ```tsx
  var add = (x, y) => x + y;
  ```

### 코드의 문맥에 따른 자바스크립트 엔진의 함수 해석

- `{ }` 은 `코드 블록` 혹은 `객체 리터럴` 일 수도 있음 → `{ }은 중의적 표현`
  - `{ }` 이 `단독`으로 존재 → 자바스크립트 엔진은 `{ } 을 블록문으로 해석`
  - `{ }` 이 `값으로 평가`되어야 할 문맥에서 `피연산자` 로 사용될 경우 자바스크립트 엔진은 `{ }을 객체 리터럴로 해석`
- 함수도 비슷
  - `함수 리터럴` 이 단독으로 사용되면 `함수 선언문`으로 해석
  - `함수 리터럴` 이 값으로 평가되어야 하는 문맥에서 `함수 리터럴 표현식` 으로 해석

## 📚 함수 호출

- 매개변수와 인수
  - 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급됨
  - 인수는 값으로 평가될 수 있는 표현식으로 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없음
  - 함수가 호출되면 매개변수가 생성되고, undefined로 초기화 된 후 인수가 할당된다.
  - 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
- 반환문
  - return 키워드와 표현식(반환값)으로 이뤄지며, 이를 통해 실행 결과를 함수 외부로 반환이 가능함
  - 함수 호출은 표현식이며, return 키워드가 반환한 평가 결과인 반환값으로 평가됨
  - 반환값을 명시적으로 지정하지 않는 경우와 반환문이 생략되는 경우에 undefined를 반환함
  - 반환문은 함수 몸체 내부에서만 사용할 수 있으나, Node.js 환경에서는 파일별로 독립적인 파일 스코프를 가져 에러가 발생하진 않음

## 📚 참조에 의한 전달과 외부 상태의 변경

- 원시 타입의 인수는 값 자체가 복사되어 매개변수로 전달되기 때문에 함수 내부에서 변경해도 원본에는 영향이 없음
- 참조 타입의 인수는 참조 값이 복사되어 매개변수로 전달된다. 때문에 함수 내부에서 변경하면 참조 값에 의해 원본이 변경되는 **부수 효과(Side Effect)** 가 발생한다.
- 객체를 **불변 객체(Immutable Object)** 로 만들어 사용하는 것을 통해 해결할 수 있으며, 필요에 따라 객체의 **방어적 복사(Defensive Copy, 깊은 복사를 통해 새로운 객체를 생성)** 하고 재할당을 통해 교체해 부수 효과를 없애는 것이 가능하다
