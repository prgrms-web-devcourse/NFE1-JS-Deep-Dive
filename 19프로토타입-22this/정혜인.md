# 19ch 프로토타입

- 자바스크립트는 **프로토타입 기반**의 객체지향으로 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 `멀티 패러다임 프로그래밍 언어`
- JS는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 `모든 것`이 객체라고 할 수 있다. 원시 타입의 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체에 해당

## 📚 객체지향 프로그래밍

프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

- 실세계의 실체(사물이나 개념)를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작
- 실체는 특징이나 성질을 나타내는 속성을 지니고 있음
- `추상화`: 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것

```jsx
// 이름과 주소 속성을 갖는 객체
const person = {
  name: "jeong",
  address: "seoul",
};

console.log(person); // {name: 'jeong', address: 'seoul'}
```

- `객체`란, 즉 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 의미하며 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이라 할 수 있음

## 📚 상속과 프로토타입

- `상속`: 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 의미
- JS는 프로토타입을 기반으로 상속을 구현하고, 기존의 코드를 적극적으로 재사용함으로 불필요한 코드 중복을 제거함

```jsx
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    // 원주율을 나타내는 상수
    return Math.PI * this.radius ** 2;
  };
}

// 인스턴스 생성
const circle1 = new Circle(1);
const circle1 = new Circle(2);

// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는
// getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유
// -> 메서드를 하나만 생성해서 모든 인스턴스가 공유해서 사용하는 것이 바람직
console.log(circle1.getArea === circle2.getArea); // false

console.log(circle1.getArea()); // 3.141592...
console.log(circle2.getArea()); // 12.56637...
```

이처럼 모든 인스턴스가 동일한 생성자 함수에 의해 생성된 메서드를 중복 소유하는 것은 불필요한 메모리 낭비로 이어짐 + 인스턴스 생성시마다 메서드를 생성하므로 퍼포먼스에 악영향을 끼침

⇒ 프로토타입을 기반으로 상속을 구현

```jsx
function Circle(radius) {
	this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
// 공유해서 사용할 수 있도록 프로토타입에 추가
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어있음
Circle.prototype.getArea = functino () {
	return Math.PI * this.radius ** 2;
}

// 인스턴스 생성
const circle1 = new Circle(1);
const circle1 = new Circle(2);

// Circle 생성자 함수가 생성한모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받음
// , Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유함
console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.141592...
console.log(circle2.getArea()); // 12.56637...
```

Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위(부모) 객체 역할을 하는 Circle prototype의 모든 프로퍼티와 메서드를 상속받음

## 📚 프로토타입 객체

객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용됨

- 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공
- 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용 가능
- 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이에 저장되는 프로토타입은 객체 생성 방식에 의해 결정됨
- 모든 객체는 하나의 프로토타입을 갖고, 모든 프로토타입은 생성자 함수와 연결되어있음
- \_ _proto_ \_ 접근자 프로퍼티를 통해 자신의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근이 가능함
- 모든 객체는 \_ _proto_ \_ 접근자 프로퍼티를 통해 자신의 프로토타입 내부 슬롯에 간접적으로 접근 가능
- 내부 슬롯은 프로퍼티가 아님
- JS는 원칙적으로 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않음
- \_ _proto_ \_는 getter/setter 함수와 같은 접근자 함수를 통해 프로토타입을 취득하거나 할당함
- \_ _proto_ _접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티로, 모든 객체는 상속을 통해 Object.prototype._ _proto_ \_ 접근자 프로퍼티를 사용할 수 있음
- 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야함
  - 순환 참조의 체인이 만들어지면 체인 종점이 존재하지 않으므로, 프로퍼티 검색시 무한 루프에 빠짐 → 프로토타입을 교체할 수 없도록 \_ _proto_ \_ 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체할 수 있도록 구현해야함
- 모든 객체가 \_ _proto_ \_ 접근자 프로퍼티를 사용할 수 있는 것은 아니므로 직접 사용은 권장하지 않음
- \_ _proto_ \_ 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우 Object.getPrototypeOf 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 Object.setPrototypeOf 메서드 사용을 권장
- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴

```jsx
// 함수 객체는 prototype 프로퍼티를 소유함
(function () {}).hasOwnProperty("prototype"); // true

// 일반 객체는 prototype 프로퍼티를 소유하지 않음
({}).hasOwnProperty("prototype"); // false
```

- prototype 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킴
- 화살표 함수와 ES6 메서드 축약 표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않음
- 모든 객체가 지닌 \_ _proto_ \_ 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리키나, 사용하는 주체는 다름
  | 구분                          | 소유        | 값                | 사용 주체   | 사용 목적                                                                    |
  | ----------------------------- | ----------- | ----------------- | ----------- | ---------------------------------------------------------------------------- |
  | \_ _proto_ \_ 접근자 프로퍼티 | 모든 객체   | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용                      |
  | prototype 프로퍼티            | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |
- 모든 프로토타입은 constructor 프로퍼티를 지니며, prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킴
  - 즉, 이 연결은 함수 객체가 생성될 때 이루어짐

## 📚 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결됨
- 리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정지을 수 없음
- 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 지님
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재함
- 리터럴 표기법에 의해 생성된 객체는 함수에 의해 생성도니 객체는 아니나, 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다. 즉, 객체로서 동일한 특성을 가짐

## 📚 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성됨
- 생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있음
- 화살표 함수나 ES6의 메서드 축약 표현으로 정의하지 않고 일반 함수로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있음
- 즉, constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성됨
- 즉, non-constructor는 프로토타입이 생성되지 않음
- 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 지님
- 빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며, 생성된 프로토타입의 프로토타입은 언제나 Object.prototype임
- 빌트인 생성자 함수도 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성됨
- 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재함
- 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당됨
- `프로토타입 체인`: 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는 것
- 프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype에 해당함
- Object.prototype을 프로토타입 체인의 종점이라하며, [[Prototype]] 내부 슬롯의 값은 null을 지님
  - 프로퍼티를 검색할 수 없는 경우 undefined를 반환
- 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 객체의 프로퍼티를 검색 ⇒ 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이라 할 수 있음
- 스코프 체인은 식별자 검색을 위한 메커니즘
- 스코프 체인과 프로토타입 체인은 서로 연관없이 별도로 동작하는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용됨
- 프로토타입이 소유한 프로퍼티를 포로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부름
- `프로퍼티 섀도잉`: 상속 관계에 의해 프로퍼티가 가려지는 현상
- 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능

## 📚 프로토타입의 교체

- 프로토타입은 임의의 다른 객체로 변경이 가능 = 부모 객체인 프로토타입을 동적으로 변경할 수 있음
- 객체 간의 상속 관계를 동적으로 변경 가능
- 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체 가능
- 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없음
- 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴됨
- 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살림
- 프로토타입으로 교체한 객체에는 constructor 프로퍼티가 없으므로 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴됨
- 프로토타입은 직접 교체하는 것보단 `직접 상속`이 더 편리하고 안전함

## 📚 instanceof 연산자

우변에 생성자 함수를 가리키는 식별자를 피연사로 받으며, 우변의 피연산자가 함수가 아닌 경우 TypeError가 발생

```jsx
객체 instanceof 생성자 함수
```

- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가되고, 그렇지 않은 경우에는 false로 평가됨
- instanceof 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인함

## 📚 직접 상속

- Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성
- Object.create 메서드의 첫 번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달함
- 두번째 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이루어진 객체를 전달하며, 이 객체의 형식은 Object.defineProperties 메서드의 두번째 인수와 동일함
- Object.create 메서드는 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성하는데, 즉 객체를 생성하면서 직접적으로 상속을 구현하는 것과 같으며 장점은 이와 같음
  - new 연산자가 없이도 객체 생성이 가능
  - 프로토타입을 지정하면서 객체 생성이 가능
  - 객체 리터럴에 의해 생성된 객체도 상속을 받을 수 있음
- Object.create 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있으므로 Object.create의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않음

## 📚 정적 프로퍼티/메서드

정적 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 의미

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`hi! my name is ${this.name}`);
};

// 정적 프로퍼티
Person.staticProp = "static prop";

// 정적 메서드
Person.staticMethod = function () {
  console.log(`staticMethod`);
};

const me = new Person("Lee");

// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출함
Person.staticMethod(); // staticMethod

// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출이 불가능
// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해얗ㅁ
me.staticMethod(); // TypeError: me.staticMethod is not a function
```

- Person 생성자 함수는 객체이므로 자신의 프로퍼티/메서드 소유가 가능
- 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출이 불가능
- 생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메서드에 접근이 가능하지만, 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메서드가 아니므로 인스턴스를 접근 할 수 없음
- 인스턴스/프로토타입 메서드 내에서 this 사용이 없다면 그 메서드는 정적 메서드로 변경이 가능
- 인스턴스를 참조할 필요가 없다면 정적 메서드로 변경하여도 동작
- 프로토타입 메서드를 호출하려면 인스턴스를 생성해야 하지만 정적 메서드는 인스턴스를 생성하지 않아도 호출이 가능함

# 20ch strict mode

- 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 JS 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킴
- ESLint와 같은 린트 도구를 통해 strict mode와 유사한 효과를 얻을 수 있음

## 📚 strict mode 적용

전역의 선두 또는 함수 몸체의 선두에 ‘`use strict`';를 추가 → 스크립트 전체에 적용됨

## 📚 사용시 피해야하는 점

- 전역에 strict mode 적용 피하기
  - 스크립트 단위로 적용이 되면서 다른 스크립트에 영향을 주지 않고 일부 스크립트에 한정되어 적용이 될 수 있음 → 외부 서드파티 라이브러리를 사용하는 경우 라이브러리가 non-strict mode인 경우도 있기에 바람직하지 않음
- 함수 단위로 strict mode 적용 피하기
  - strict mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 마찬가지로 문제가 발생할 수 있음

## 📚 strict mode가 발생시키는 에러

- 암묵적 전역
  - 선언하지 않은 변수를 참조하면 ReferenceError가 발생함
- 변수, 함수, 매개변수의 삭제
  - delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생함
- 매개변수 일므의 중복
  - 중복된 매개변수 이름 사용시 SyntaxError 발생
- with 문의 사용

## 📚 strict mode 적용에 의한 변화

- 일반 함수의 this
  - 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩 됨. 일반 함수 내부에서는 this를 사용할 필요가 없으며, 에러가 발생하지 않음
- arguments 객체
  - 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않음

# 21ch 빌트인 객체

## 📚 자바스크립트 객체의 분류

- `표준 빌트인 객체`
  - 애플리케이션 전역의 공통 기능을 제공함
  - 자바스크립트 실행 환경과 관계없이 언제난 사용 가능
  - 전역 객체의 프로퍼티로서 제공됨
  - 별도의 선언 없이 전역 변수처럼 언제나 참조 가능
- `호스트 객체`
  - 자바스크립트 실행 환경에서 추가로 제공하는 객체를 의미
- `사용자 정의 객체`
  - 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 의미

## 📚 표준 빌트인 객체

- Object, string, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여 개의 표준 빌트인 객체를 제공
- Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체에 해당함
- 생성자 함수 객체인 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체로, 프로토타입 메서드와 정적 메서드를 제공하며 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공

## 📚 원시값과 래퍼 객체

- 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시값인 문자열이 마치 객체처럼 동작함
  - 원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해주기 때문
- `래퍼 객체`: 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체
- 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용이 가능하며, 표준 빌트인 객체인 String, Number, Boolean, Symbol의 프로토타입 메서드 또는 프로퍼티를 참조할 수 있음
  → String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 문자열, 숫자, 불리언 인스턴스를 생성할 필요가 없으며 권장하지 않음
- 따라서 문자열, 숫자, 불리언, 심벌 이외의 원시값, 즉 null과 undefined는 래퍼 객체를 생성하지 않음

## 📚 전역 객체

코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체로, 어떤 객체에도 속하지 않은 최상위 객체를 의미

- 전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 가짐
- 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체를 의미
- 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유하는 것을 의미
- 전역 객체는 개발자가 의도적으로 생성할 수 없음. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않음
- 전역 객체의 프로퍼티를 참조할 때 window(또는 global) 생략이 가능
- `빌트인 전역 프로퍼티`: 전역 객체의 프로퍼티를 의미하며, 주로 애플ㄹ케이션 전역에서 사용하는 값을 제공
- `빌트인 전역 함수`: 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드

# 22ch this

## 📚 this 키워드

- 메서드는 자신이 속한 객체의 프로퍼티를 참조하기 위해 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야함
- 생성자 함수로 인스턴스를 생성하려면 우선적으로 생성자 함수가 존재해야함
- `this`는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수를 의미하며, `this`를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있음
- this는 JS 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있음
- 함수 호출시 arguments 객체와 this가 암묵적으로 함수 내부에 전달됨
- 즉, this 바인딩은 함수 호출 방식에 의해 동적으로 결정됨
- JS의 this는 함수가 호출되는 방식에 따라 this에 바인딩 될 값, 즉 this 바인딩이 동적으로 결정됨
- this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체의 메서드 또는 생성자 함수 내부에서만 의미가 있음
  ⇒ strict mode가 적용된 일반 함수 내부의 this에는 `undefined`가 바인딩됨

## 📚 함수 호출 방식과 this 바인딩

this 바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정됨
