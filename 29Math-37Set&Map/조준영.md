[29. Math](#29-math)

[30. date](#30-date)

[31. regexp](#31-regexp)

[32. string](#32-string)

[33. 7번째 데이터 타입 Symbol](#33-7번째-데이터-타입-symbol)

[34. 이터러블](#34-이터러블)

[35. 스프레드 문법](#35-스프레드-문법)

[36. 디스트럭처링 할당](#36-디스트럭처링-할당)

[37. Set과 Map](#37-set과-map)

# 29. Math

**표준 빌트인 객체인 `Math` 는 수학적인 상수와 함수를 위한 프로퍼티와 메서드를 제공한다.**

- `Math` 는 생성자 함수가 아니므로 정적 프로퍼티와 정적 메서드만 제공한다.

## 29.1 Math 프로퍼티

### Math.PI

**원주율 PI 값 (3.141592653589793..)을 반환한다.**

### Math 메서드

### Math.abs

**`Math.abs` 는 인수로 전달된 숫자의 `절대값을 반환` 한다.**

- 절댓값은 반드시 0 또는 양수이어야 한다.

### Math.round

**`Math.round` 메서드는 인수로 전달된 숫자의 소수점 이하를 `반올림한 정수를 반환` 한다.**

### Math.ceil

**`Math.ceil` 메서드는 인수로 전달된 숫자의 소수점 이하를 `올림한 정수를 반환` 한다.**

### Math.floor

**`Math.floor` 메서드는 인수로 전달된 숫자의 소수점 이하를 `내림한 정수를 반환` 한다.**

### Math.sqrt

**`Math.sqrt` 메서드는 인수로 전달된 숫자의 `제곱근을 반환` 한다.**

### Math.random

**`Math.random` 메서드는 `임의의 난수(랜덤 숫자)를 반환` 한다.**

- `Math.random` 메서드가 반환한 난수는 0에서 1미만의 **실수**다.
  - 0은 포함되지만 1은 포함되지 않는다.

### Math.pow

**`Math.pow` 메서드는 첫 번째 인수를 밑으로, 두 번째 인수를 지수로 거듭제곱한 결과를 반환한다.**

- `Math.pow` 메서드 대신 ES7에서 도입된 지수 연산자를 사용하면 가독성이 더 좋다.

### Math.max

**`Math.max` 메서드는 전달받은 인수 중에서 가장 큰 수를 반환한다.**

- 인수가 전달되지 않으면 `-Infinity` 를 반환한다.

### Math.min

**`Math.min` 메서드는 전달받은 인수 중에서 가장 작은 수를 반환한다.**

- 인수가 전달되지 않으면 `Infinity` 를 반환한다.

# 30. Date

표준 빌트인 객체인 `Date` 는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수다.

## 30.1 Date 생성자 함수

### new Date()

**`Date` 생성자 함수를 인수 없이 `new` 연산자와 함께 호출하면 현재 날짜와 시간을 가지는 `Date` 객체를 반환한다.**

- `Date` 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다.
- `Date` 객체를 콘솔에 출력하면 기본적으로 날짜와 시간 정보를 출력한다.

### new Date(milliseconds)

`Date` 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 `1970년 1월 1이 00:00:00(UTC)` 를 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 `Date` 객체를 반환한다.

### new Date(dateString)

`Date` 생성자 함수에 날짜와 시간을 나타내는 문자열을 인수로 전달하면 지정된 날짜와 시간을 나타내는 `Date` 객체를 반환한다.

- 이때 인수로 전달한 문자열은 `Date.parse` 메서드에 의해 해석 가능한 형식이어야 한다.

### new Date(year, month[, day, hour. minute. second. millisecond])

`Date` 생성자 함수에 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날짜와 시간을 나타내는 `Date` 객체를 반환한다.

- 이때 연, 월은 반드시 지정해야 한다.
- 지정하지 않은 옵션 정보는 0 또는 1로 초기화 된다.

| 인수        | 내용                                 |
| ----------- | ------------------------------------ |
| year        | 연을 나타내는 1990년 이후의 정수     |
| month       | 월을 나타내는 0 ~ 11까지의 정수      |
| day         | 일을 나타내는 1 ~ 31까지의 정수      |
| hour        | 시를 나타내는 0 ~ 23까지의 정수      |
| minute      | 분을 나타내는 0 ~ 59까지의 정수      |
| second      | 초를 나타내는 0 ~ 59까지의 정수      |
| millisecond | 밀리초를 나타내는 0 ~ 999까지의 정수 |

# 31. RegExp

## 31.1 정규 표현식이란?

**정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어(formal language)다.**

- 정규 표현식은 문자열을 대상으로 **패턴 매칭 기능**을 제공한다.
- 반복문과 조건문 없이 패턴을 정의하고 테스트하는 것으로 간단히 체크할 수 있다.

## 31.2 정규 표현식의 생성

**정규 표현식 객체를 생성하기 위해서는 정규 표현식 리터럴과 `RegExp` 생성자 함수를 사용할 수 있다.**

- 일반적으로 정규 표현식 리터럴을 사용한다.
  - 정규 표현식 리터럴은 패턴과 플래그로 구성된다.

```jsx
const target = "is this all there is?";

// 패턴: is
// 플래그: i => 대소문자를 구별하지 않고 검색한다.
const regexp = /is/i;

// test 메서드는 target 문자열에 대해 정규 표현식 regexp의 패턴을 검색하여 매칭 결과를
// 불라언 값으로 반환한다.
regexp.test(target); // -> true
```

- `RegExp` 생성자 함수를 사용하여 `RegExp` 객체를 생성할 수도 있다.

```jsx
// pattern: 정규 표현식의 패턴
// flags: 정규 표현식의 플래그 (g, i, m, u, y)
```

```jsx
const target = "is this all there is?";

const regexp = new RegExp(/is/i); // ES6
// const regexp = new RegExp(/is/, 'i');
// const regexp = new RegExp('is', 'i');

regexp.test(target); // -> true
```

## 31.3 RegExp 메서드

### RegExp.prototype.exec

**`exec` 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다.**

- 매칭 결과가 없는 경우 `null` 을 반환한다.

```jsx
const target = "Is this all there is?";
const regExp = /is/;

regExp.exec(target);
// -> ["is", index: 5, input: "is this all there is?", groups: undefined]
```

### RegExp.prototype.test

**`test` 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환한다.**

```jsx
const target = "Is this all there is?";
const regExp = /is/;

regExp.test(target); // true
```

### String.prototype.match

**`String` 표준 표준 빌트인 객체가 제공하는 `match` 메서드는 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.**

```jsx
const target = 'Is this all there is?;
const regExp = /is/;

target.match(rexExp);;
```

- `exec` 메서드는 문자열 내의 모든 패턴을 검색하는 `g` 플래그를 지정해도 첫 번째 결과만 반환한다.
- `math` 메서드는 `g` 플래그가 지정되면 모든 매칭 결과를 배열로 반환한다.

## 31.4 플래그

**패턴과 함께 정규 표현식을 구성하는 플래그는 정규 표현식의 검색 방식을 설명하기 위해 사용한다.**

| 플래그 | 의미        | 설명                                                           |
| ------ | ----------- | -------------------------------------------------------------- |
| i      | Ignore case | 대소문를 구별하지 않고 패턴을 검색한다.                        |
| g      | Global      | 대상 문자열 내에서 패턴과 일치하는 모든 문자열은 전역 검색한다 |
| m      | Multi line  | 문자열의 행이 바뀌더라도 패턴 검색을 계속한한다.               |

- 플래그는 옵션이므로 선택적으로 사용할 수 있으며, 순서와 상관없이 하나 이상의 플래그를 통해 동시에 설정할 수도 있다.
- 플래그를 사용하지 않은 경우 대소문자를 구별해서 패턴을 검색한다.
  - 매칭 대상이 1개 이상 존재해도 첫 번째 매칭한 대상만 검색하고 종료한다.

## 31.5 패턴

**정규 표현식은 패턴(일정한 규칙)을 가진 문자열을 집합을 표현하기 위해 사용하는 형식 언어다.**

- 정규 표현식은 패턴과 플래그로 구성된다.
- 패턴은 문자열의 일정한 규칙을 표현하기 위해 사용한다.
- 플래그는 정규 표현식의 검색 방식을 설정하기 위해 사용한다.
- 패턴은 `/` 로 열고 닫으며 문자열의 따옴표는 생략한다.

### 문자열 검색

**정규 표현식을 생성하는 것만으로 검색이 수행되지 않는다. `RegExp` 메서드를 사용하여 검색 대상 문자열과 정규 표현식의 매칭 결과를 구하면 검색이 수행된다.**

### 임의의 문자열 검색

**`.` 은 임의의 문자 한 개를 의미한다. 문자의 내용은 무엇이든 상관 없다.**

```jsx
const target = "is this all there is?";

// 임의의 3자리 문자열을 대소문자 구별하여 전역 검색한다.
const regExp = /.../g;

target.match(regExp);
// -> ["Is ", "thi", "s a", "ll ", "the", "re ", "is?"]
```

### 반복 검색

**`{m,n}` 은 앞선 패턴이 `최소 m번`, `최대 n번` 반복되는 문자열을 의미한다.**

- 콤마 뒤에 공백이 있으면 정상 동작 하지않는다.

```jsx
const target = "A AA B BB Aa Bb AAA";

// 'A'가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{1,2}/g;

target.match(regExp);
// -> ["A", "AA", "A", "AA", "A"]
```

- `{n}` 은 앞선 패턴이 `n` 번 반복되는 문자열을 의미한다.
  - `{n}` 은 {n,n}과 같다.
- `{n,}` 은 앞선 패턴이 최소 n번 이상 반복되는 문자열이다.
- `+` 는 앞선 패턴이 최소 한 번 이상 반복되는 문자열을 의미한다.
  - `{1,}` 와 같다.
- `?` 는 앞선 패턴이 최대 한 번 이상 반복되는 문자열을 의미한다.
  - `{0,1}` 과 같다.

### OR 검색

**`|` 는 `or` 의 의미를 갖는다.**

### NOT 검색

**`[…]` (대괄호) 내의 `^` 은 `not` 의 의미를 갖는다.**

### 시작 위치로 검색

**`[…]` (대괄호) 밖의 `^` 은 문자열의 시작을 의미한다.**

### 마지막 위치로 검색

**`$` 는 문자열의 마지막을 의미한다.**

# 32. String

**표준 빌트인 객체인 `String` 은 원시 타입인 문자열을 다룰 때 유용한 프로퍼티와 메서드를 제공한다.**

## 32.1 String 생성자 함수

**표준 빌트인 객체인 `String` 객체는 생성자 함수 객체다.**

- `new` 연산자와 함께 호출하여 `String` 인스턴스를 생성할 수 있다.
- 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.
- `new` 연산자를 사용하지 않고 `String` 생성자 함수를 호출하면 `String` 인스턴스가 아닌 문자열을 반환한다.
  - 이를 이용해 명시적으로 타입을 반환하기도 한다.

## 32.2 length 프로퍼티

**`length` 프로퍼티는 문자열의 문자 개수를 반환한다.**

## 32.3 String 메서드

배열에는 원본 배열(배열 메서드를 호출한 배열)을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.

- **문자열은 변경 불가능한 원시 값이기 때문에 `String` 래퍼 객체도 읽기 전용 객체로 제공된다.**

### String.prototype.indexOf

**`indexOf` 메서드는 대상 문자열에서 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환한다.**

- 검색에 실패하면 `-1` 을 반환한다.
- 두 번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.
- 특정 문자열이 존재하는지 확인할 때 유용하다.
- ES6에서 도입된 `String.prototype.includes` 메서드를 사용하면 가독성이 더 좋다.

### String.prototype.search

**`search` 메서드는 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다.**

- 검색에 실패하면 `-1` 을 반환한다.

### String.prototype.includes

**ES6에서 도입된 `includes` 메서드는 대상 문자열에 인수로 전달받은 문자열이 포함되어 있는지 확인하여 그 결과를 `true` 또는 `false` 로 반환한다.**

- 두 번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

### String.prototype.startWith

**ES6에서 도입된 `startWith` 메서드는 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 `true` 또는 `false` 로 반환한다.**

- 두 번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

### String.prototype.endWith

**ES6에서 도입된 `endWith` 메서드는 대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 `true` 또는 `false` 로 반환한다.**

- 두 번째 인수로 검색할 문자열의 길이를 전달할 수 있다.

### String.prototype.charAt

**`charAt` 메서드는 대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환한다.**

- 인덱스가 문자열의 범위를 벗어난 정수인 경우 빈 문자열을 반환한다.
- 비슷한 메서드는 `String.prototype.charCodeAt` 과 `String.prototype.codePointAt` 이 있다.

### String.prototype.substring

**`substring` 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환한다.**

- 두 번째 인수는 생략할 수 있으며, 이때 마지막 문자까지 부분 문자열을 반환한다.
- 첫 번째 인수는 두 번째 인수보다 작은 정수이어야 한다.
  - 첫 번째 인수가 두 번째 인수보다 큰 경우 두 인수는 교환된다.
  - 인수가 `0` 또는 `NaN` 인 경우 0으로 취급된다.
  - 인수가 문자열의 길이보다 큰 경우 인수는 문자열의 길이로 취급된다.

```jsx
const str = "Hello World";

// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.
str.substring(1, 4); // -> ell
```

### String,prototoype.slice

**`slice` 메서드는 `substring` 메서드와 동일하게 동작한다.**

- `slice` 메서드에는 음수인 인수를 전달할 수 있다.
- 음수인 인수를 전달하면 대상 문자열의 가장 뒤에서부터 시작하여 문자열을 잘라내어 반환한다.

### String.prototoype.toUpperCase

**`toUpperCase` 메서드는 대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.**

### String.prototype.toLowerCase

**`toLowerCase` 메서드는 대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.**

### String.prototype.trim

**`trim` 메서드는 대상 문자열 앞뒤에 공백 문자가 있을 경우 이를 제거한 문자열을 반환한다.**

- `String.prototype.replace` 메서드에 정규 표현식을 인수로 전달하여 공백 문자를 제거할 수도 있다.

### String.prototoype.repeat

**ES6에서 도입된 `repeat` 메서드는 대상 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반환한다.**

- 인수로 전달받은 정수가 0이면 빈 문자열을 반환하고, 음수이면 `RangeError` 를 발생시킨다.
- 인수를 생략하면 기본값이 0으로 설정된다.

### String.prototype.replace

**`replace` 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환한 문자열을 반환한다.**

- 검색된 문자열이 여럿 존재할 경우 첫 번째로 검색된 문자열만 치환한다.

### String.prototype.split

**`split` 메서드는 대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 `배열` 을 반환한다.**

- 인수로 빈 문자열을 전달하면 각 문자를 모두 분리한다.
- 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.
- 두 번째 인수로 배열의 길이를 지정할 수 있다.

# 33. 7번째 데이터 타입 Symbol

## 33.1 심벌이란?

**심벌(Symbol)은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다.**

- 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.
  - 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.

## 33.2 심벌 값의 생성

### Symbol 함수

**심벌 값은 `Symbol` 함수를 호출하여 생성한다.**

- 생성된 심벌 값은 외부로 노출되지 않아 확인할 수 없으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.
- `new` 연산자와 함께 호출하면 에러가 발생한다.
- `Symbol` 함수에는 선택적으로 문자열을 인수로 전달할 수 있다.
  - 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되며, 심벌 값 생성에 영향을 주지 않는다.

```jsx
// Symbol 함수를 호출하여 유일무이한 심벌 값을 생성한다.
const mySymbol = Symbol();
console.log(typeof mySymbol); // symbol

// 심벌 값은 외부로 노출되지 않아 확인할 수 없다.
console.log(mySymbol); // Symbol()
```

### Symbol.for / Symbol.keyFor 메서드

**`Symbol.for` 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.**

- 검색에 성공하면 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환한다.
- 검색에 실패하면 새로운 심벌 값을 생성하여 `Symbol.for` 메서드의 인수로 전달된 키로 전역 심벌레지스트리에 저장한 후, 생성된 심벌 값을 반환한다.

**`Symbol.keyFor` 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.**

## 33.3 심벌과 함수

**변경/중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일무이한 심벌 값을 사용할 수 있다.**

## 33.4 심벌과 프로퍼티 키

객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값으로 만들 수 있으며, 동적으로 생성할 수도 있다.

- 심벌 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심벌 값에 대괄호를 사용해야 한다.
- 프로퍼티에 접근할 때도 마찬가지로 대괄호를 사용해야 한다.
- **심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다.**

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol.for("mySymbol")]: 1,
};

obbj[Symbol.for("mySymbol")]; // -> 1
```

## 33.5 심벌과 프로퍼티 은닉

**심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 생성하면 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있다.**

- ES6에서 도입된 `Object.getOwnPropertySymbols` 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

## 33.6 심벌과 표준 빌트인 객체 확장

일반적으로 표준 빌트인 객체에서 사용자 정의 메서드를 직접 추가하여 확장하는 것은 권장하지 않는다.

- 표준 빌트인 객체는 읽기 전용으로 사용하는 것이 좋다.
  - 미래에 표준 사양으로 추가될 메서드의 이름이 중복될 수있기 때문이다.
  - 표준 빌트인 메서드를 사용자 정의 메서드가 덮어쓴다면 문제가 된다.

## 33. 7 Well-Known Symbol

**빌트인 심벌 값은 `Symbol` 함수의 프로퍼티에 할당되어 있다.**

- 자바스크립트가 기본 제공하는 빌트인 심벌 값은 ECMAScript 사양에서는 `Well-Known Symbol` 이라 부른다.
  - 자바스크립트 엔진의 내부 알고리즘에 사용된다.

# 34. 이터러블

## 34.1 이터레이션 프로토콜

**ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.**

- 이터레이션 프로토콜에는 `이터러블 프로토콜` 과 `이터레이터 프로토콜` 이 있다.
  - **이터러블 프로토콜(iterable protocol)**
    - 이터레이터를 리턴하는 [Symbol.iterator]() 메서드를가진 객체이다.
    - 이터러블 프로토콜을 준수한 객체를 `이터러블` 이라 한다.
  - **이터레이터 프로토콜(iterator protocol)**
    - 이터레이터를 반환한다.
    - 이터레이터는 `next` 메서드를 소유하며 `next` 메서드를 호출하면 이터러블을 순회하며 `value` 와 `done` 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.
    - 이터레이터 프로토콜을 준수한 객체를 `이터레이터` 라 한다.

### 이터러블

**이터러블 프로토콜을 준수한 객체를 이터러블이라한다.**

- `Symbol.iterator` 를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.
- 배열은 `Array.prototoype` 의 `Symbol.iterator` 메서드를 상속받는 이터러블이다.
  - 이터러블은 `for ... of` 문으로 순회할 수 있다.
  - 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.

### 이터레이터

**이터러블의 `Symbol.iterator` 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.**

- 이터러블의 `Symbol.iterator` 메서드가 반환한 이터레이터는 `next` 메서드를 갖는다.
- `next` 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 **이터레이터 리절트 객체**를 반환한다.
  - `value` 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내며 `done` 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.

## 34.2 빌트인 이터러블

**이터레이션 프로토콜을 준수한 객체인 빌트인 이터러블을 제공한다.**

- 표준 빌트인 객체들은 빌트인 이터러블이다.

| 빌트인 이터러블 | Symbol.iterator 메서드                |
| --------------- | ------------------------------------- |
| Array           | Array.prototype[Symbol.iterator]      |
| String          | String.prototype[Symbol.iterator]     |
| Map             | Map.prototpye[Symbol.iterator]        |
| Set             | Set.prototpye[Symbol.iterator]        |
| TypedArray      | TypedArray.prototpye[Symbol.iterator] |
| arguments       | arguments.prototpye[Symbol.iterator]  |
| DOM 컬렉션      | NodeList.prototpye[Symbol.iterator]   |

HTMLCollectio.prototpye[Symbol.iterator] |

## 34.3 for … of 문

**`for ... of` 문은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.**

```jsx
for (변수선언문 of 이터러블) { ... }

for (변수선언문 in 객체) { ... }
```

- `for ... in` 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 `true` 인 프로퍼티를 순회하며 열거한다.
  - 이때 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.
- `for ... of` 문은 내부적으로 이터레이터의 `next` 메서드를 호출하여 이터러블을 순회하며 `next` 메서드가 반환한 이터러레이터 리절트 객체의 `value` 프로퍼티 값을 `for ... of` 문의 변수에 할당한다.
  - `done` 프로퍼티 값이 `false` 이면 이터러블의 순회를 계속하고 `true` 이면 이터러블의 순회를 순화시킨다.

## 34.3 이터러블과 유사 배열 객체

**유사 배열 객체는 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 `length` 프로퍼티를 갖는 객체를 말한다.**

- `length` 프로퍼티를 갖기 때문에 `for` 문으로 순회할 수 있고 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.
- 유사 배열 객체는 이터러블이 아닌 일반 객체다.
  - 유사 배열 객체에는 `Symbol.iterator` 메서드가 없기 때문에 `for ... of` 문으로 순회할 수 없다.
- `arguments` , `NodeList` , `HTMLCollection` 은 유사 배열 객체이면서 이터러블이다.
  - ES6에서 이터러블이 도입되면서 유사 배열 객체에 `Symbol.iterator` 메서드를 구현하여 이터러블이 되었다.
  - 배열도 마찬가지로 ES6에서 이터러블이 도입되면서 이터러블이 되었다.
- ES6에서 도입된 `Array.from` 메서드를 사용하여 배열로 간단히 변환할 수 있다.
  - 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.

## 34.5 이터레이션 프로토콜의 필요성

**이터러블은 `for ... of 문` , `스프레드 문법` , `배열 디스트럭처링 할당` 과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 할 수 있다.**

- 만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다.
- 하지만 다양한 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 된다.
- 이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 **데이터 소비자와 데이터 공급자를 연결하는 인터페이스역할을 한다.**

# 35. 스프레드 문법

**ES6에서 도읍된 스프레드(전개) 문법 `...` 은 하나로 뭉쳐져 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.**

- 스프레드 문법을 사용할 수 있는 대상은 `Array` , `String` , `Map` , `Set` , `DOM 컬렉션` , `arguments` 와 같이 `for ... of` 문으로 순회헐 수 있는 이터러블에 해당한다.
- 스프레드 문법의 결과는 값이 아니다.
  - 스프레드 문법의 결과는 변수에 할당할 수 없다.
- 스프레드 문법은 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.
  - 함수 호출문의 인수 목록
  - 배열 리터럴 요소 목록
  - 객체 리터럴의 프로퍼티 목록

## 35.1 함수 호출문의 인수 목록에서 사용하는 경우

**요소들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수목록으로 전달해야 하는 경우가 있다.**

```jsx
const arr = [1, 2, 3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
const max = Math.max(arr); // -> NaN
Math.max(1); // -> 1
Math.max(1, 2); // -> 2
Math.max(); // -> Infinity

Math.max([1, 2, 3]); // -> NaN

const max1 = Math.max(...arr); // -> 3
```

- `[1, 2, 3]` 을 펼쳐서 `Math.max` 의 인수로 전달해야 한다.
  - 스프레드 문법을 사용하면 더 간결하고 가독성이 좋다.

## 35.2 배열 리터럴 내부에서 사용하는 경우

스프레드 문법을 배열 리터럴에서 사용하면 ES5에서 사용하던 기존의 방식보다 더 간결하고 가독성 좋게 표현할 수 있다.

### concat

ES5에서 2개의 배열을 1개의 배열로 결합하고 싶은 경우 배열 리터럴만으로 해결할 수 없고 `concat` 메서드를 사용해야 한다.

```jsx
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]
```

```jsx
// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]
```

### splice

ES5에서 어떤 배열의 중간에 다른 배열의 요소들을 추가하거나 제거하려면 `splice` 메서드를 사용해야 한다.

- 이때 `splice` 메서드의 세 번째 인수로 배열을 전달하면 배열 자체가 추가된다.

```jsx
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

// 세 번째 인수 arr2를 해체하여 전달해야 한다.
// 그렇지 않으면 arr1에 arr2 배열 자체가 추가된다.
arr.splice(1, 0, arr2);

// 기대한 결과는 [1, [2, 3], 4]가 아니라 [1, 2, 3, 4]이다.
console.log(arr1); // [1, [2, 3], 4]
```

- `Function.prototype.apply` 메서드를 사용하여 `splice` 메서드를 호출해야 한다.

```jsx
// ES6
const arr1 = [1, 4];
const arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4];
```

### 배열 복사

ES5에서 배열을 복사하려면 `slice` 메서드를 사용한다.

```jsx
// Es5
var origin = [1, 2];
var copy = origin.slice();

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

```jsx
// ES6
const origin = [1, 2];
const copy = [...origin];

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

- 원본 배열의 각 요소를 얕은 복사하여 새로운 복사본을 생성한다.

### 이터러블을 배열로 변환

ES5에서 이터러블을 배열로 변환하려면 `Function.prototype.apply` 또는 `Function.prototype.call` 메서드를 사용하여 `slice` 메서드를 호출해야 한다.

- 이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 ES6에서 도입된 `Array.from` 메서드를 사용한다.

## 35.3 객체 리터럴 내부에서 사용하는 경우

**객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다.**

- ES6 이전에서 도입된 `Object.assign` 메서드를 사용하여 여러 개의 객체를 병합하거나 특정 프로퍼티를 변경 또는 추가했다.
- 스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다.

```jsx
// 스프레드 프로퍼티
// 객체 복사(얕은 복사)
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2}
console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4}
```

# 36. 디스트럭처링 할당

**디스트럭처링 할당(구조 분해 할당)은 구조화된 배열과 같은 이터러블 또는 객체를 비구조화 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.**

- 배열과 같은 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용하다.

## 36.1 배열 디스트럭처링 할당

- ES5에서 구조화된 배열을 디스트럭처링하여 1개 이상의 변수에 할당하는 방법

```jsx
// ES5
var arr = [1, 2, 3];

var one = arr[0];
var two = arr[1];
var three = arr[2];

console.log(one, two, three); // 1 2 3
```

- ES6의 배열 디스트럭처링 할당은 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당한다.
  - **배열 디스트럭처링 할당의 대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다.**
  - 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.
  - 디스트럭처링 할당을 위해 변수에 기본값을 설정할 수 있다.

```jsx
const arr = [1, 2, 3];

// ES6 배열 디스트럭처링 할당
const [one, two, three] = arr;

console.log(one, two, three); // 1 2 3
```

## 36.2 객체 디스트럭처링 할당

**ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링 하여 변수에 할당하기 위해서는 프로퍼티 키를 사용해야 한다.**

```jsx
// ES5
var user = { firstName: "Ungmo", lastName: "Lee" };

var firstName = user.firstName;
var lastName = user.lastName;

console.log(firstName, lastName); // Ungmo Lee
```

- 할당 기준은 프로퍼타 키다.

```jsx
// ES6
var user = { firstName: "Ungmo", lastName: "Lee" };

const { lastName, firstName } = user;

console.log(firstName, lastName); // Ungmo Lee
```

# 37. Set과 Map

## 37.1 Set

**`Set` 객체는 중복되지 않는 유일한 값들의 집합이다.**

- `Set` 객체는 배열과 유사하지만 차이가 있다.
- `Set` 을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.

| 구분                                 | 배열 | Set 객체 |
| ------------------------------------ | ---- | -------- |
| 동일한 값을 중복하여 포함할 수 있다. | O    | X        |
| 요소 순서에 의미가 있다.             | O    | X        |
| 인덱스로 요소에 접근할 수 있다.      | O    | X        |

## Set 객체의 생성

`Set` 객체는 `Set` 생성자 함수로 생성한다.

- `Set` 생성자 함수에 인수를 전달하지 않으면 빈 `Set` 객체가 생성된다.
- **`Set` 생성자 함수는 이터러블을 인수로 전달받아 `Set` 객체를 생성한다.**
- **이터러블의 중복된 값은 `Set` 객체 요소로 저장되지 않는다.**

```jsx
const set = new Set();
console.log(set); // Set(0) {}
```

### 요소 개수 확인

**`Set` 객체의 요소 개수를 확인할 때는 `Set.prototype.size` 프로퍼티를 사용한다.**

- 프로퍼티에 숫자를 할당하여 `Set` 객체의 요소 개수를 변경할 수 없다.

### 요소 추가

`Set` 객체에 요소를 추가할 때는 `Set.prototype.add` 메서드를 사용한다.

### 요소 존재 여부 확인

**`Set` 객체의 특정 요소가 존재하는지 확인하려면 `Set.prototype.has` 메서드를 사용한다.**

- 특정 존재 여부를 나타내는 불리언 값을 반환한다.

### 요소 삭제

**`Set` 객체의 특정 요소를 삭제하려면 `Set.prototype.delete` 메서드를 사용한다.**

- `delete` 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다.
- 인덱스가 아니라 삭제하려는 요소값을 인수로 전달해야 한다.

### 요소 일괄 삭제

**`Set` 객체의 모든 요소를 일괄 삭제하려면 `Set.prototype.clear` 메서드를 사용한다.**

- `undefined` 를 반환한다.

### 요소 순회

**`Set` 객체의 요소를 순회하려면 `Set.prototype.forEach` 메서드를 사용한다.**

- 콜백 함수의 인수
  - 첫 번째 인수: 현재 순회 중인 요소값
  - 두 번째 인수: 현재 순회 중인 요소값
  - 세 번째 인수: 현재 순회 중인 `Set` 객체 자체
- `Set` 객체는 이터러블이다.
  - 따라서 `for ... of` 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링의 대상이 될 수도 있다.

## 37.2 Map

**`Map` 객체는 키와 값의 쌍으로 이루어진 컬렉션이다.**

- `Map` 객체는 객체와 유사하지만 다음과 같은 차이가 있다.

| 구분                   | 객체                    | Map 객체              |
| ---------------------- | ----------------------- | --------------------- |
| 키로 사용할 수 있는 값 | 문자열 또는 심벌 값     | 객체를 포함한 모든 값 |
| 이터러블               | X                       | O                     |
| 요소 개수 확인         | Object.keys(obj).length | map.size              |

### Map 객체의 생성

`Map` 객체는 생성자 함수로 생성한다.

- **`Map` 생성자 함수는 이터러블을 인수로 전달받아 `Map` 객체를 생성한다.**
  - **이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.**

### 요소 개수 확인

**`Map` 객체의 요소 개수를 확인할 때는 `Map.prototype.size` 프로퍼티를 사용한다.**

### 요소 추가

**`Map` 객체에 요소를 추가할 때는 `Map.prototype.set` 메서드를 사용한다.**

- 중복된 키를 갖는 요소가 존재할 수 없기 때문에 중복된 키를 갖는 요소를 추가하면 값이 덮어써진다.

### 요소 취득

**`Map` 객체에서 특정 요소를 취득하려면 `Map.prototype.get` 메서드를 사용한다.**

- `get` 메서드의 인수로 키를 전달하면 `Map` 객체에서 인수로 전달한 키를 갖는 값을 반환한다.
- 인수로 전달한 키를 갖는 요소가 존재하지 않으면 `undefined` 를 반환한다.

### 요소 존재 여부 확인

**`Map` 객체에 특정 요소가 존재하는지 확인하려면 `Map.prototype.has` 메서드를 확인한다.**

- 특정 요소의 존재 여부를 나타내는 불리언 값을 반환한다.

### 요소 삭제

**`Map` 객체의 요소를 삭제하려면 `Map,prototype.delete` 메서드를 사용한다.**

- 삭제 성공 여부를 나타내는 불리언 값을 반환한다.
- 존재하지 않는 키로 `Map` 객체의 요소를 삭제하려면 에러 없이 무시된다.

### 요소 일괄 삭제

**`Map` 객체의 요소를 일괄 삭제하려면 `Map.prototype.clear` 메서드를 사용한다.**

- `undefined` 를 반환한다.

### 요소 순회

**`Map` 객체의 요소를 순회하려면 `Map.prototype.forEach` 메서드를 사용한다.**

- `forEach` 메서드의 콜백 함수는 3개의 인수를 전달받는다.
  - 첫 번째 인수: 현재 순회중인 요소 값
  - 두 번째 인수: 현재 순회중인 요소 키
  - 세 번째 인수: 현재 순회중인 Map 객체
- `Map` 객체는 이터러블이다.
  - 따라서 `for ... of` 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.

| Map 메서드            | 설명                                                                                           |
| --------------------- | ---------------------------------------------------------------------------------------------- |
| Map.prototype.keys    | Map 객체에서 요소키를 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다.          |
| Map.prototype.values  | Map 객체에서 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다.          |
| Map.prototype.entries | Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |
