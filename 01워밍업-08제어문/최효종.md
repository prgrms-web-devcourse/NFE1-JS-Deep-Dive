# 변수란 무엇인가? 왜 필요한가?

프로그램에서 변수가 필요하며, 이는 데이터를 저장하고 관리하는 핵심 개념이다.<br>
변수를 사용하면 메모리 주소를 직접적으로 다루지 않고, 값을 저장하고 다시 사용할 수 있게 된다.

## 자바스크립트에서 계산이 어떻게 이루어지는가?

10 + 20 같은 연산을 실행하면, 자바스크립트 엔진은 해당 수식을 해석하고 결과값을 메모리에 저장한다. <br>
값이 저장된 위치에 대한 직접적인 접근은 오류 발생 가능성이 크기 때문에, 프로그래밍 언어는 이러한 작업을 안전하게 처리하기 위해 변수를 사용한다.

## 변수의 역할

값이 저장된 위치에 대한 직접적인 접근은 오류 발생 가능성이 크기 때문에, 프로그래밍 언어는 이러한 작업을 안전하게 처리하기 위해 변수를 사용한다. <br>
변수는 값이 저장된 메모리 위치를 가리키는 상징적인 이름으로, 프로그래머가 쉽게 이해하고 사용할 수 있도록 돕는다.<br>
변수를 사용하여 메모리의 값을 재사용하고 참조하는 것이 가능하다.

## 식별자

식별자는 변수, 함수, 클래스 등 메모리 상에 저장된 값이나 기능을 구별할 수 있는 고유한 이름을 말한다. 프로그램에서 사용되는 식별자는 특정 메모리 주소와 연결되어, 그 메모리에 저장된 값을 참조할 수 있게 한다.<br>
식별자는 단순히 값을 기억하는 것이 아니라, 값이 저장된 메모리 위치를 기억하는 역할을 한다. 이를 통해 개발자는 메모리 주소를 직접 다루지 않고, 식별자를 통해 안전하게 값에 접근할 수 있다. 자바스크립트와 같은 프로그래밍 언어에서는 식별자를 사용하여 변수를 선언하고, 이 선언된 변수의 값을 언제든지 참조할 수 있다.<br>
<br>
따라서 식별자는 프로그래밍에서 값을 재사용하고 관리하는 중요한 메커니즘으로 작용하며, 명확한 이름을 통해 코드의 가독성을 높이는 역할도 한다.<br>

## 변수 선언

변수 선언이란 변수를 생성하는 것을 말한다. 변수를 생성할 때는 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 해준다. 변수를 선언함으로써 확보된 메모리 공간은 해제되기 전까지는 다른 곳에서 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.<br>
<br>
변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. ES6에서 let, const 키워드가 도입되기 이전까지는 var 키워드만 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였다. var 키워드는 함수 레벨 스코프를 지원하고, let, const는 블록 레벨 스코프를 지원하기 때문에 더 안전하게 변수를 사용할 수 있다.(중요)<br>
<br>
변수를 선언하면 자바스크립트 엔진은 해당 변수 이름을 메모리에 등록하고, 그 변수에 암묵적으로 undefined 값을 할당하여 초기화한다. 이 과정을 통해 메모리 공간은 확보되며, 변수를 사용할 준비가 완료된다.<br>
<br>
변수를 선언하지 않고 사용할 경우, 자바스크립트 엔진은 해당 식별자를 찾지 못해 ReferenceError가 발생한다. 이는 변수를 반드시 선언한 후에 사용해야 한다는 것을 의미한다.<br>
<br>

## 값의 할당

값을 할당할 때는 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당하는 역할을 한다. 예를 들어, var score = 80;는 score라는 변수에 80이라는 값을 할당하는 것이다.<br>
<br>
변수 선언은 런타임 이전에 실행되고, 값의 할당은 런타임에 실행된다. 따라서 var score;라는 변수 선언이 먼저 실행되고, 이후에 score = 80;과 같은 값의 할당이 이루어진다. 그 결과, 변수가 처음 선언될 때는 undefined로 초기화되었다가, 이후에 값이 할당되면서 새로운 값으로 변경된다.<br>

### undefined의 처리

undefined의 처리
변수에 값을 할당할 때, 기존에 할당된 undefined 값이 저장된 메모리 공간을 지우고 새로운 메모리 공간을 확보하여 새 값을 저장하는 것이 아니라, 기존 메모리 공간에 값을 덮어쓴다. 예를 들어, score = 80;이라는 값이 할당되면, 메모리 공간에 있던 undefined 값이 사라지고 80이 저장된다.<br>
<br>
이러한 점을 고려할 때, 변수 선언과 값 할당이 각각 어떻게 작동하는지 이해하는 것이 중요하다.

### const 키워드

const 키워드는 ES6에서 도입되었으며, 한 번 할당된 변수를 다시 재할당하는 것이 금지된다. 이를 통해 값을 변경할 수 없는 변수를 만들 수 있으며, 상수를 선언할 때 주로 사용된다. 예를 들어, const foo = 10; 이후에 foo = 100;을 실행하려고 하면 TypeError가 발생한다.

### 값의 재할당

재할당은 이미 값이 할당된 변수에 새로운 값을 할당하는 것을 의미한다. 예를 들어, var score = 80; 이후에 score = 90;이라는 코드가 있을 때, 기존에 저장된 값인 80을 지우고 새로운 값 90이 할당된다. var로 선언된 변수는 언제든지 재할당이 가능하다.

반면, const로 선언된 변수는 재할당이 불가능하다. 한 번 값이 할당된 이후에는 해당 값을 변경할 수 없으며, 이를 상수라고 부른다.

### 가비지 컬렉터

변수에 재할당이 이루어지면 기존에 저장되어 있던 값은 더 이상 필요하지 않게 되는데, 자바스크립트 엔진은 이러한 불필요한 값을 자동으로 메모리에서 해제한다. 이를 가비지 컬렉터가 수행하며, 메모리 누수를 방지하는 역할을 한다.

결론적으로, const는 변수를 상수로 만들며 재할당이 불가능하고, var로 선언된 변수는 재할당이 가능하다. 메모리 관리 측면에서는 가비지 컬렉터가 필요 없는 값을 자동으로 처리해 준다.

## 🧐 CH04 예시문제

1. 자바스크립트에서 변수를 선언하고 값이 할당될 때, 메모리 상에 어떻게 저장되는지 설명하세요. 또한, undefined 값이 처음에 변수에 할당되는 이유를 설명하시오.

<details>
    <summary>해설</summary>
    1. 변수 선언:
변수를 선언하면 자바스크립트 엔진은 해당 변수를 메모리에 등록합니다. 이때, 자바스크립트는 선언된 변수를 일단 undefined로 초기화합니다. 이 과정은 `호이스팅(hoisting)` 이라는 메커니즘으로 설명되며, 코드 실행 전에 모든 변수 선언이 코드 상단으로 끌어올려지기 때문에, 변수를 선언하기 전에 그 변수에 접근하면 undefined 값이 반환됩니다. 
<br><br>
    2. 값의 할당
변수 선언 후, 값을 할당할 때는 `할당 연산자(=)` 를 사용하여 변수를 메모리 상에 저장합니다. 이때, 변수는 메모리 주소와 연결되어 있고, 값은 그 메모리 주소에 저장됩니다.
<br>
메모리에 저장된 값은 새로운 값이 할당될 때 덮어쓰기가 이루어집니다. 자바스크립트 엔진은 새로운 값을 저장하기 위해 기존 값을 지우지 않고, 해당 메모리 주소에 있는 데이터를 덮어씁니다. 이 덮어쓰기 방식은 자바스크립트의 가비지 컬렉터(Garbage Collector)에 의해 관리됩니다. 즉, 더 이상 참조되지 않는 값은 메모리에서 자동으로 해제되며, 메모리 누수를 방지합니다.
<br><br>
    3. undefined가 처음에 할당되는 이유:<br>
자바스크립트는 호이스팅 과정에서 변수를 선언만 하고, 값이 할당되지 않았을 경우 그 변수를 undefined로 초기화합니다. 이는 메모리 상에서 해당 변수를 사용할 준비가 되었음을 의미하며, 선언은 되었으나 값이 아직 할당되지 않았음을 나타냅니다.
<br>
undefined는 자바스크립트에서 변수가 선언되었지만 아직 값이 설정되지 않았음을 명확히 하며, 프로그램이 오류를 발생시키지 않고 안정적으로 실행되도록 돕는 역할을 합니다.
<br><br>

</details>
<br><br>

2. 자바스크립트에서 var, let, const 키워드를 사용하여 변수를 선언할 때, `각 키워드가 영향을 미치는 스코프(scope)`에 대해 설명하세요.<br>
또한, `각 키워드가 변수의 메모리 할당 방식과 변수 재할당 가능 여부에서 어떻게 다르게 동작하는지` 설명하시오.<br><br>
<details>
    <summary>해설</summary>
        <li>var</li>
        영향을 미치는 스코프: var는 함수 스코프를 따릅니다. 이는 변수가 선언된 함수 내에서만 유효하며, 함수 외부에서는 접근할 수 없습니다.<br> 하지만 var는 블록(if, for, while 등) 내에서도 함수 전체에서 유효하기 때문에, 의도치 않게 변수가 재선언되어 문제를 일으킬 수 있습니다. <br>이로 인해 var는 전역 변수로 선언된 경우, 다른 코드와 충돌할 가능성이 커집니다.<br><br>
        메모리 할당 방식: var는 코드 실행 전에 호이스팅되어 최상단으로 끌어올려집니다. 초기값은 undefined로 설정됩니다.<br> 즉, 변수를 선언하기 전에 접근할 수 있으나 그 값은 undefined입니다.
        <br><br>
        재할당 가능 여부: var로 선언된 변수는 언제든지 재할당이 가능합니다. 동일한 이름으로 여러 번 선언할 수 있으며, 그 값도 덮어쓰기가 가능합니다.
        <br><br>
        <li>let</li>
        영향을 미치는 스코프: let은 블록 스코프를 따릅니다. let으로 선언된 변수는 해당 블록 내부에서만 유효하며, 블록을 벗어나면 접근할 수 없습니다. <br>이로 인해 let은 동일한 변수명이 블록 내부에서 재선언되지 않고, 블록 바깥과의 충돌을 방지합니다. 이를 통해 코드의 안정성과 가독성이 높아집니다.
        <br><br>
        메모리 할당 방식: let은 호이스팅되지만, 선언 전에 변수에 접근할 수 없습니다. 이를 Temporal Dead Zone(TDZ)이라고 하며, 변수가 선언되기 전에는 사용할 수 없습니다. 이 메커니즘을 통해 선언 전 접근을 막아, 잠재적인 오류를 방지합니다.
        <br><br>
        재할당 가능 여부: let으로 선언된 변수는 재할당이 가능합니다. 하지만 동일한 블록 내에서 동일한 이름으로 변수를 다시 선언할 수는 없습니다.
        <br><br>
        <li>const</li>
        영향을 미치는 스코프: const 역시 블록 스코프를 따릅니다. const로 선언된 변수는 블록 내에서만 유효하며, 블록 바깥에서는 접근할 수 없습니다. const는 let과 마찬가지로 변수가 선언된 블록 바깥에서는 접근할 수 없으므로, 변수의 재선언이나 외부 간섭을 방지하는 데 유리합니다.

</details>
<br><br>

# 표현식과 문

## 값

### 값의 정의:

값은 식이 평가(evaluate)된 결과를 의미하며, 평가된 식의 결과로 값이 생성된다.<br>

### 메모리 저장:

모든 값은 데이터 타입을 가지며 메모리에 2진수 형태로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석된다.<br>

### 변수와 값의 할당:

변수는 하나의 값을 저장하기 위한 메모리 공간으로, 변수가 기억하는 것은 평가된 값이다. 예를 들어, var sum = 10 + 20; 에서 변수 sum에 저장된 값은 30이며, 10 + 20이 아니라 그 평가된 결과인 30이 저장된다.<br>
<br>

## 리터럴

### 리터럴의 정의

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.<br>
예를 들어, 숫자 3은 단순한 아라비아 숫자가 아니라 숫자 리터럴로, 자바스크립트 코드에서 이를 기입하면 엔진이 이를 평가해 숫자 값 3을 생성한다.

### 리터럴의 종류와 예시

리터럴은 다양한 타입의 값을 생성할 수 있다. <br>다음은 리터럴의 여러 종류와 예시다:
<br><br>
정수 리터럴: 100<br>
부동소수점 리터럴: 10.5<br>
2진수 리터럴: 0b01000001<br>
8진수 리터럴: 00101<br>
16진수 리터럴: 0x41<br>
문자열 리터럴: 'Hello', "World"<br>
불리언 리터럴: true, false<br>
null 리터럴: null<br>
undefined 리터럴: undefined<br>
객체 리터럴: { name: 'Lee', address: 'Seoul' }<br>
배열 리터럴: [1, 2, 3]<br>
함수 리터럴: function() {}<br>
정규 표현식 리터럴: /[A-Z]+/g<br>
<br><br>

## 표현식

**표현식(Expression)** 은 값으로 평가될 수 있는 코드 조각을 말한다. 예를 들어, 10, score = 100 같은 식이 표현식이다.<br>
**문(Statement)** 은 독립적으로 실행 가능한 완전한 작업 단위를 의미한다. 예를 들어, 변수 선언이나 할당 같은 작업이 문이다.
<br><br>

### 표현식의 예

단순 표현식: 리터럴이나 변수 이름과 같이 단순히 값을 나타내는 표현식이다.<br>
예: 10, score, person.name, arr[1]<br>
연산자 표현식: 연산자를 사용해 값을 조합하거나 계산하는 표현식이다.<br>
예: 10 + 20, sum = 10, sum != 10<br>
함수/메서드 호출 표현식: 함수나 메서드를 호출하는 표현식이다.<br>
예: square(), person.getName()
<br><br>

## 문

**문(statement)** 은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 문은 토큰(token)이라는 더 이상 나눌 수 없는 코드의 기본 요소로 구성되며, 예를 들어 키워드, 식별자, 연산자, 리터럴 등이 토큰에 해당된다.

### 문과 명령문

문은 컴퓨터에 내리는 명령으로, 실행되면 특정 작업을 수행하게 된다. 예를 들어, 변수를 선언하거나, 값을 할당하거나, 특정 조건에 따라 코드를 실행하는 등의 작업을 포함한다.

### 문 예시

변수 선언문: var x;<br>
할당문: x = 5;<br>
함수 선언문: function foo() {}<br>
조건문: if (x > 1) { console.log(x); }<br>
반복문: for (var i = 0; i < 2; i++) { console.log(i); }<br>

### 표현식과 문의 차이

1. 표현식(Expression)
   정의: 값으로 평가될 수 있는 코드 조각이다. 즉, 표현식이 실행되면 값을 반환한다.

예시:

- 10 + 20 → 30 (숫자 값을 반환)
- "Hello" + "World" → "HelloWorld" (문자열을 반환)<br>
- x > 1 → true 또는 false (불리언 값을 반환)
  표현식은 결과적으로 항상 하나의 값을 만들어낸다. 이 값은 숫자, 문자열, 불리언, 객체 등이 될 수 있다.<br>

특징: 표현식은 프로그램의 다른 부분에서 값으로 사용될 수 있다. 예를 들어, 변수에 할당되거나 함수의 인자로 전달될 수 있다.<br>

2. 문(Statement)
   정의: 프로그램에서 어떤 작업을 수행하는 명령이다. 문은 표현식처럼 값을 반환하는 것이 아니라, 작업을 수행한다.

예시:

- var x = 10; (변수 선언과 할당 작업을 수행)<br>
- if (x > 1) { console.log("x가 1보다 큽니다."); } (조건문을 실행)<br>
- for (var i = 0; i < 10; i++) { console.log(i); } (반복문을 실행)<br>
- 문은 어떤 일을 수행하지만, 그 자체로 값을 반환하지 않는다.<br>

# 데이터 타입

## 숫자 타입

자바스크립트는 정수형과 실수형을 구분하지 않고, 모든 숫자를 64비트 부동소수점 형식으로 처리한다. 즉, 정수와 실수를 따로 구분하는 데이터 타입이 존재하지 않는다.<br>
정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 동일하게 부동소수점 형식으로 메모리에 저장된다. 자바스크립트는 이러한 리터럴을 모두 10진수로 해석한다.
<br><br>

```
var integer = 10;    // 정수
var double = 10.12;  // 실수
var negative = -20;  // 음의 정수
```

### 특별한 숫자 값

숫자 타입에는 세 가지 특별한 값이 있다:

- Infinity: 양의 무한대
- Infinity: 음의 무한대
- NaN: 숫자가 아닌 값 (Not-a-Number), 산술 연산이 불가능할 때 발생

```
console.log(10 / 0);      // Infinity
console.log(10 / -0);     // -Infinity
console.log(1 * 'String'); // NaN
```

### NaN과 대소문자 구분

자바스크립트는 대소문자를 구별하므로 NaN, nan, NAN 등은 서로 다른 것으로 인식된다. NaN은 특별한 숫자 값이지만, nan이나 NAN은 정의되지 않은 변수로 에러가 발생한다.

## 문자열 타입

문자열(string) 타입은 텍스트 데이터를 나타내는 데 사용되며, 자바스크립트에서는 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.<br>
문자열은 작은따옴표(' '), 큰따옴표(" ") 또는 백틱( )으로 감싸서 표현할 수 있다. 자바스크립트에서 가장 일반적으로 사용하는 표기법은 작은따옴표다.
<br><br>

```
var string;
string = '문자열';  // 작은따옴표
string = "문자열";  // 큰따옴표
string = `문자열`;  // 백틱(ES6)
```

자바스크립트 엔진은 문자열을 따옴표로 감싸지 않으면 키워드나 식별자로 인식하기 때문에 항상 문자열은 따옴표로 감싸야 한다. 예를 들어, 따옴표로 감싸지 않은 hello는 식별자(변수나 함수의 이름을 작성할 때 사용하는 이름)로 해석된다.

## 템플릿 리터럴

ES6부터 템플릿 리터럴이라는 새로운 문자열 표기법이 도입되었다. 템플릿 리터럴은 멀티라인 문자열, 표현식 삽입 등을 지원해 편리한 문자열 처리가 가능하다.<br>
템플릿 리터럴 예시

```
var template = `Template literal`;
console.log(template);  // Template literal
```

### 멀티라인 문자열

- 일반 문자열에서는 줄바꿈이 허용되지 않지만, 템플릿 리터럴을 사용하면 줄바꿈과 공백이 허용된다.
- 백슬래시(\)를 사용해 다양한 이스케이프 시퀀스도 사용 가능하다.

```
\n	개행 (줄 바꿈)
\t	탭 (수평)
\', \"	작은/큰 따옴표
\\	백슬래시
\uXXXX	유니코드 문자를 나타냄
```

템플릿 리터럴을 사용하면 여러 줄로 작성된 문자열을 그대로 사용할 수 있으며, 줄바꿈과 공백이 그대로 출력된다.
<br>
결론적으로 템플릿 리터럴은 더 유연한 문자열 처리를 가능하게 하며, 멀티라인 지원과 이스케이프 시퀀스를 활용한 다양한 표현이 가능하다.

### 표현식 삽입

문자열은 **문자열 연산자 +** 를 사용해 연결할 수 있다. + 연산자는 피연산자 중 하나 이상이 문자열일 때 문자열 연결 연산자로 동작한다.

```
var first = 'Ung-mo';
var last = 'Lee';
console.log('My name is ' + first + ' ' + last + '.');
// 출력: My name is Ung-mo Lee.
```

주의: 표현식 삽입은 반드시 템플릿 리터럴 안에서 사용해야 하며, 일반 문자열에서는 사용할 수 없다.<br>
<br>
수식 삽입 예시<br>

```
console.log(`1 + 2 = ${1 + 2}`);
// 출력: 1 + 2 = 3
```

## 불리언 타입

- 불리언 타입은 논리적 참(true)과 거짓(false)을 나타내는 데이터 타입이다. 불리언 타입의 값은 true와 false 두 가지뿐이다.
- 불리언 값은 주로 조건문에서 프로그램의 흐름을 제어하는 데 사용된다.

```
var foo = true;
console.log(foo);  // true

foo = false;
console.log(foo);  // false
```

## undefined 타입

- undefined 타입의 값은 undefined가 유일하다.
- 자바스크립트에서 변수를 선언만 하고 값을 할당하지 않으면 해당 변수는 암묵적으로 undefined로 초기화된다. 이는 변수가 메모리 공간을 할당받았지만 초기값이 없는 상태를 의미한다.

```
var foo;
console.log(foo);  // undefined
```

선언과 정의

- undefined는 의도적으로 할당된 값이 아닌 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.
- 다른 언어에서는 변수 선언과 정의가 명확히 구분되지만, 자바스크립트에서는 선언과 정의가 동시에 이루어진다. 즉, 변수를 선언할 때 이미 정의된 상태로 취급된다.
  <br>
  이러한 undefined의 특성 때문에 값이 할당되지 않은 변수에 접근하려고 하면 undefined가 반환된다.

## null 타입

- null 타입의 값은 null이 유일하다. 자바스크립트에서는 대소문자를 구분하므로 null, Null, NULL은 서로 다르다.
- null은 변수가 값이 없다는 것을 명시적으로 표현하기 위해 사용된다. 이는 변수가 이전에 참조하던 값을 더 이상 참조하지 않음을 의미한다.

```
var foo = 'Lee';
// 'Lee'를 참조하는 foo 변수를 더 이상 사용하지 않음
foo = null;
```

이때, 변수 foo는 이제 더 이상 값을 참조하지 않으며, 자바스크립트 엔진은 가비지 컬렉션을 통해 해당 메모리 공간을 회수할 수 있다.<br>
null은 값이 없다는 것을 의도적으로 표시할 때 사용되며, 함수가 유효한 값을 반환할 수 없는 경우에도 명시적으로 null을 반환할 수 있다.<br>
예를 들어, document.querySelector 메서드는 조건에 부합하는 HTML 요소가 없으면 null을 반환한다.<br>
<br>
null은 변수나 객체가 더 이상 유효하지 않다는 것을 명시적으로 나타내며, 이는 메모리 관리와 값의 상태를 표현할 때 자주 사용된다.

## 심벌 타입

- 심벌(Symbol) 타입은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입이다.
- 심벌 값은 유일무이하며, 다른 값과 중복되지 않기 때문에 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다.
- 심벌은 Symbol() 함수를 호출해 생성하며, 생성된 심벌 값은 외부에 노출되지 않고, 같은 심벌 값을 다시 생성할 수 없다.

```
var key = Symbol('key');
console.log(typeof key);  // symbol

var obj = {};
obj[key] = 'value';
console.log(obj[key]);  // value
```

심벌은 주로 객체의 키로 사용되며, 다른 키들과 충돌할 위험이 없다.<br>
심벌 타입은 객체의 프로퍼티 키로 사용할 수 있으며, 심벌로 생성된 키는 다른 값들과 중복되지 않는다.

## 데이터 타입이 필요한 이유

1. 값을 저장할 때 확보해야 할 메모리 공간의 크기를 결정하기 위해.
2. 값을 참조할 때 한 번에 읽어들일 메모리 공간의 크기를 결정하기 위해.
3. 메모리에 저장된 값을 어떻게 해석할지 결정하기 위해.

## 동적 타이핑

자바스크립트는 **동적 타이핑(dynamic typing)** 언어로, 변수를 선언할 때 명시적으로 데이터 타입을 지정하지 않는다. 자바스크립트의 변수는 값을 할당하는 시점에 해당 값에 맞는 데이터 타입으로 동적으로 결정된다.
<br><br>
자바스크립트에서는 변수에 할당된 값에 따라 타입이 결정되며, 언제든지 타입을 변경할 수 있다. 이를 동적 타이핑이라고 하며, 정적 타이핑 언어와는 다르게 변수가 값을 할당하는 시점에 타입이 결정된다.

### 정적 타이핑과 비교

C나 자바 같은 정적 타이핑(static typing) 언어에서는 변수를 선언할 때 데이터 타입을 명시해야 하며, 한 번 선언된 타입은 변경할 수 없다.<br>

- 예시 (C 언어, 타입스크립트)

```
// c언어
int num;  // 정수형 변수 선언
// 타입스크립트
let age: number;  // 정수형 변수 선언
age = 25;         // 정상적인 숫자 할당
```

반면 자바스크립트는 동적 타이핑 언어로, 변수에 어떤 값이든 할당할 수 있으며 변수의 타입이 언제든지 동적으로 변경될 수 있다.

## 동적 타이핑 언어와 변수

동적 타이핑 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 이러한 편리함은 데이터 타입을 신경 쓰지 않고 프로그래밍할 수 있다는 장점을 제공한다. 하지만 이 편리함에는 위험이 따른다.

### 동적 타이핑 언어의 문제점

- 변수의 타입 변경: 동적 타이핑 언어에서는 변수가 할당된 값에 따라 타입이 언제든지 변경될 수 있기 때문에, 복잡한 프로그램에서는 변수가 어떤 타입인지 추적하기 어렵다. 이는 예기치 않은 오류를 발생시킬 수 있다.
  <br><br>
- 유연성 vs 신뢰성: 동적 타이핑 언어는 유연성을 높여주지만, 그만큼 신뢰성이 떨어질 수 있다. 데이터 타입을 미리 체크하지 않으면, 실행 중에 발생하는 오류를 예방하기 어려워진다.

### 변수 사용에 대한 조언

- 변수는 꼭 필요한 경우에만 제한적으로 사용한다.
- 변수의 유효 범위를 최소화한다. 가능하면 변수를 지역적으로 선언하고 전역 변수 사용을 피한다.
- 변수 이름을 명확하게 사용해, 변수가 어떤 역할을 하는지 쉽게 이해할 수 있도록 한다.
- 상수 활용: 상수는 값이 변하지 않기 때문에, 안정적인 코드 작성에 기여할 수 있다.

### 결론

동적 타이핑 언어에서는 변수의 사용이 매우 유연하지만, 그로 인해 발생할 수 있는 오류를 피하기 위해서는 변수를 신중하게 사용하고, 명확한 변수 이름과 상수의 활용을 통해 안정적인 프로그램을 작성해야 한다.

## 🧐 CH06 문제

### 문제 1: 동적 타이핑과 변수의 타입 변경

다음 자바스크립트 코드를 실행한 후 typeof 연산자를 사용해 각 변수의 데이터 타입을 확인하려고 합니다. 코드 실행 후 typeof foo의 출력값을 순서대로 적으세요.<br>

```
var foo;
console.log(typeof foo);  // A. ?
foo = 42;
console.log(typeof foo);  // B. ?
foo = 'Hello';
console.log(typeof foo);  // C. ?
foo = true;
console.log(typeof foo);  // D. ?
foo = null;
console.log(typeof foo);  // E. ?
foo = Symbol();
console.log(typeof foo);  // F. ?
```

<details>
    <summary>해설</summary>
    - A. undefined<br>
    - B. number<br>
    - C. string<br>
    - D. boolean<br>
    - E. object<br>
    - F. symbol<br>
</details>

### 문제 2: 정적 타이핑과 타입 오류

다음은 TypeScript 코드입니다. 주어진 코드에서 발생하는 오류와 그 이유를 설명하고, TypeScript로 작성하면 이 에러를 미리 방지할 수 있습니다. 이 문제를 TypeScript로 다시 작성해보세요.

```
let age: number = 30;
age = "Thirty";  // 오류 발생: 이 줄에서 어떤 문제가 발생하나요?
```

<details>
    <summary>해설</summary>
    해결 방법 
```<br>
    let age: string = "Thirty";  // 올바른 코드: 문자열 타입으로 선언
```<br>
    오류 발생 이유: <br>
    age 변수는 number 타입으로 선언되었습니다. TypeScript에서는 변수의 타입이 고정되기 때문에, string 타입인 "Thirty"를 number 타입으로 선언된 age에 할당할 수 없습니다. 따라서 컴파일 단계에서 오류가 발생합니다.<br>
    해설:<br>
    TypeScript는 정적 타입 검사를 제공하므로, 변수에 올바른 타입의 값이 할당되지 않으면 컴파일 시점에서 오류를 발생시킵니다. 그 결과 자바스크립트와 달리 타입스크립트는 런타임 오류가 아닌 컴파일 타임에서 미리 발견할 수 있습니다. <br>

</details>

# 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자라고 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.
<br><br>

- 산술 연산자: 5 \* 4는 두 수를 곱해 20을 만든다.
- 문자열 연결 연산자: 'My name is ' + 'Lee'는 두 문자열을 연결해 'My name is Lee'를 만든다.
- 할당 연산자: color = 'red'는 'red'를 color 변수에 할당한다.
- 비교 연산자: 3 > 5는 두 값을 비교해 false를 반환한다.
- 논리 연산자: true && false는 두 불리언 값을 AND 연산하여 false를 만든다.
- 타입 연산자: typeof 'Hi'는 'Hi'의 데이터 타입을 string으로 반환한다.
  <br>
  피연산자가 "값"이라는 명사 역할을 한다면, 연산자는 "피연산자를 연산하여 새로운 값을 만든다"라는 동사 역할을 한다고 볼 수 있다.

## 산술 연산자

산술 연산자는 주로 숫자 값을 대상으로 덧셈, 뺄셈, 곱셈, 나눗셈 등의 수학적 연산을 수행한다. 예를 들어 5 \* 4는 20이라는 값을 만든다. 이처럼 산술 연산자는 값을 계산하여 반환하는 연산이다. 연산 과정에서 수학적으로 불가능한 연산이 일어나면 NaN (Not-a-Number)을 반환한다.<br><br>

### 연산자와 피연산자

피연산자는 값으로 평가될 수 있는 표현식이며, 연산자의 대상이 된다. 예를 들어 3 > 5는 비교 연산자로, 피연산자인 3과 5의 크기를 비교하여 false 값을 반환한다.

### 문자의 연결

문자열과 더하기 연산자(+)를 사용하면 두 문자열이 연결된다. 예를 들어 'My name is ' + 'Lee'는 'My name is Lee'라는 결과를 만든다. 이처럼 더하기 연산자는 숫자뿐만 아니라 문자열을 연결하는 데도 활용된다.
<br>
연산자는 다양한 종류가 있으며, 각 연산자는 특정한 작업을 수행하고 그 결과 값을 반환한다. 이를 통해 코드는 다양한 수학적, 논리적 작업을 수행할 수 있다.

## 할당 연산자

할당 연산자는 피연산자의 평가 결과를 좌항에 있는 변수에 할당하는 역할을 한다. 이는 변수의 값을 변경할 수 있는 부수 효과가 있는 연산자이다. 또한 할당문은 표현식인 문으로, 값으로 평가되는 특징이 있다.
<br><br>
할당문에서 중요한 것은 할당된 값을 이용해 다른 변수에 연쇄적으로 할당할 수 있다는 점이다. 이는 코드의 간결성을 높이는 데 유용하다.

```
var x = 10; // x에 10을 할당
x += 5;     // x에 5를 더한 값을 다시 x에 할당 (결과: 15)
x -= 5;     // x에서 5를 뺀 값을 다시 x에 할당 (결과: 10)
```

### 동등 비교(==)와 일치 비교(===)

- 동등 비교 (==): 값만 비교하며, 필요시 자동으로 타입을 변환한 후 비교를 진행한다. 예를 들어, 5 == '5'는 true로 평가된다. 하지만 이 방식은 예측이 어려운 경우가 많고, 실수를 유발할 수 있다.
- 일치 비교 (===): 값과 타입 모두를 엄격하게 비교한다. 타입 변환 없이 비교하므로, 5 === '5'는 false로 평가된다. 일치 비교는 예측하기 쉬워 더 안전한 방식이다.

### 부등 비교(!=)와 불일치 비교(!==)

- 부등 비교 (!=): 동등 비교의 반대로 값이 같지 않으면 true를 반환한다.
- 불일치 비교 (!==): 일치 비교의 반대로 값과 타입이 모두 같지 않으면 true를 반환한다.

### NaN 및 특수 케이스

- NaN은 어떤 값과도 일치하지 않으며, 이를 확인하기 위해 isNaN() 함수를 사용해야 한다. 또한, 양수 0과 음수 0은 동일한 값으로 간주된다.

### Object.is 메서드

- Object.is()는 엄격한 비교를 하지만, 특별한 경우로 +0과 -0, 그리고 NaN을 구분하여 비교할 수 있다. 예를 들어, Object.is(NaN, NaN)은 true를 반환한다.

### 대소 관계 비교 연산자

- ">", "<", >=, <= 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

## 삼항 조건 연산자

삼항 조건 연산자는 세 개의 피연산자를 받아, 조건식의 결과에 따라 반환할 값을 결정하는 연산자이다. 자바스크립트에서 유일한 삼항 연산자로, 부수 효과가 없으며, 표현식으로 사용할 수 있다.

```
조건식 ? true일 때 반환할 값 : false일 때 반환할 값
```

## 논리 연산자

- 논리합(||): 두 피연산자 중 하나라도 true이면 true를 반환한다.
- 논리곱(&&): 두 피연산자가 모두 true일 때만 true를 반환한다.
- 논리 부정(!): 피연산자의 논리 값을 반대로 바꾼다. 즉, true는 false로, false는 true로 변환한다.

암묵적 타입변환 : 논리 부정 연산자인 !는 피연산자가 불리언 값이 아닐 경우에도 불리언 값으로 암묵적으로 변환하여 처리한다.

```
!0;        // true (숫자 0은 false로 간주됨)
!'Hello';  // false (문자열은 true로 간주됨)
```

드 모르간의 법칙
논리 연산자들을 좀 더 간결하게 표현하기 위해 드 모르간의 법칙을 사용할 수 있다. 드 모르간의 법칙은 논리곱과 논리합의 부정을 변환할 때 유용하다.

```
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```

## typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환하는 연산자이다. 자바스크립트에서 지원하는 데이터 타입 중 하나인 "string", "number", "boolean", "undefined", "symbol", "object", "function"을 반환한다.

```
typeof '';            // "string"
typeof 1;             // "number"
typeof NaN;           // "number"
typeof true;          // "boolean"
typeof undefined;     // "undefined"
typeof Symbol();      // "symbol"
typeof null;          // "object" (자바스크립트의 오래된 버그)
typeof [];            // "object" (배열도 객체로 취급)
typeof {};            // "object"
typeof new Date();    // "object"
typeof /test/gi;      // "object" (정규 표현식도 객체로 취급)
typeof function() {}; // "function"
```

## 지수 연산자
지수 연산자는 ES7(ECMAScript 2016)에서 도입되었으며, 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 하여 거듭제곱한 값을 반환하는 연산자이다.

### 지수 연산자의 사용법
지수 연산자는 ** 기호를 사용하여 표현한다.

```
2 ** 2;     // 4
2 ** 2.5;   // 5.656854249492381
2 ** 0;     // 1
2 ** -2;    // 0.25
```
이전에는 지수 연산자를 지원하지 않았기 때문에, 지수 연산을 하기 위해서는 Math.pow() 메서드를 사용해야 했다.<br>
하지만 이제 굳이 메서드를 사용할 필요 없이 지수 연산자를 사용하면 된다. <br>지수연산자는 Math.pow() 메서드보다 더 간결하고 가독성이 좋다. 특히 중첩된 지수 계산에서도 괄호를 사용해 쉽게 처리할 수 있다.

