# 변수란 무엇인가? 왜 필요한가?

프로그램에서 변수가 필요하며, 이는 데이터를 저장하고 관리하는 핵심 개념이다.<br>
변수를 사용하면 메모리 주소를 직접적으로 다루지 않고, 값을 저장하고 다시 사용할 수 있게 된다.

## 자바스크립트에서 계산이 어떻게 이루어지는가?

10 + 20 같은 연산을 실행하면, 자바스크립트 엔진은 해당 수식을 해석하고 결과값을 메모리에 저장한다. <br>
값이 저장된 위치에 대한 직접적인 접근은 오류 발생 가능성이 크기 때문에, 프로그래밍 언어는 이러한 작업을 안전하게 처리하기 위해 변수를 사용한다.

## 변수의 역할

값이 저장된 위치에 대한 직접적인 접근은 오류 발생 가능성이 크기 때문에, 프로그래밍 언어는 이러한 작업을 안전하게 처리하기 위해 변수를 사용한다. <br>
변수는 값이 저장된 메모리 위치를 가리키는 상징적인 이름으로, 프로그래머가 쉽게 이해하고 사용할 수 있도록 돕는다.<br>
변수를 사용하여 메모리의 값을 재사용하고 참조하는 것이 가능하다.

## 식별자

식별자는 변수, 함수, 클래스 등 메모리 상에 저장된 값이나 기능을 구별할 수 있는 고유한 이름을 말한다. 프로그램에서 사용되는 식별자는 특정 메모리 주소와 연결되어, 그 메모리에 저장된 값을 참조할 수 있게 한다.<br>
식별자는 단순히 값을 기억하는 것이 아니라, 값이 저장된 메모리 위치를 기억하는 역할을 한다. 이를 통해 개발자는 메모리 주소를 직접 다루지 않고, 식별자를 통해 안전하게 값에 접근할 수 있다. 자바스크립트와 같은 프로그래밍 언어에서는 식별자를 사용하여 변수를 선언하고, 이 선언된 변수의 값을 언제든지 참조할 수 있다.<br>
<br>
따라서 식별자는 프로그래밍에서 값을 재사용하고 관리하는 중요한 메커니즘으로 작용하며, 명확한 이름을 통해 코드의 가독성을 높이는 역할도 한다.<br>

## 변수 선언

변수 선언이란 변수를 생성하는 것을 말한다. 변수를 생성할 때는 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있게 해준다. 변수를 선언함으로써 확보된 메모리 공간은 해제되기 전까지는 다른 곳에서 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.<br>
<br>
변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다. ES6에서 let, const 키워드가 도입되기 이전까지는 var 키워드만 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였다. var 키워드는 함수 레벨 스코프를 지원하고, let, const는 블록 레벨 스코프를 지원하기 때문에 더 안전하게 변수를 사용할 수 있다.(중요)<br>
<br>
변수를 선언하면 자바스크립트 엔진은 해당 변수 이름을 메모리에 등록하고, 그 변수에 암묵적으로 undefined 값을 할당하여 초기화한다. 이 과정을 통해 메모리 공간은 확보되며, 변수를 사용할 준비가 완료된다.<br>
<br>
변수를 선언하지 않고 사용할 경우, 자바스크립트 엔진은 해당 식별자를 찾지 못해 ReferenceError가 발생한다. 이는 변수를 반드시 선언한 후에 사용해야 한다는 것을 의미한다.<br>
<br>

## 값의 할당

값을 할당할 때는 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당하는 역할을 한다. 예를 들어, var score = 80;는 score라는 변수에 80이라는 값을 할당하는 것이다.<br>
<br>
변수 선언은 런타임 이전에 실행되고, 값의 할당은 런타임에 실행된다. 따라서 var score;라는 변수 선언이 먼저 실행되고, 이후에 score = 80;과 같은 값의 할당이 이루어진다. 그 결과, 변수가 처음 선언될 때는 undefined로 초기화되었다가, 이후에 값이 할당되면서 새로운 값으로 변경된다.<br>

### undefined의 처리

undefined의 처리
변수에 값을 할당할 때, 기존에 할당된 undefined 값이 저장된 메모리 공간을 지우고 새로운 메모리 공간을 확보하여 새 값을 저장하는 것이 아니라, 기존 메모리 공간에 값을 덮어쓴다. 예를 들어, score = 80;이라는 값이 할당되면, 메모리 공간에 있던 undefined 값이 사라지고 80이 저장된다.<br>
<br>
이러한 점을 고려할 때, 변수 선언과 값 할당이 각각 어떻게 작동하는지 이해하는 것이 중요하다.

### const 키워드

const 키워드는 ES6에서 도입되었으며, 한 번 할당된 변수를 다시 재할당하는 것이 금지된다. 이를 통해 값을 변경할 수 없는 변수를 만들 수 있으며, 상수를 선언할 때 주로 사용된다. 예를 들어, const foo = 10; 이후에 foo = 100;을 실행하려고 하면 TypeError가 발생한다.

### 값의 재할당

재할당은 이미 값이 할당된 변수에 새로운 값을 할당하는 것을 의미한다. 예를 들어, var score = 80; 이후에 score = 90;이라는 코드가 있을 때, 기존에 저장된 값인 80을 지우고 새로운 값 90이 할당된다. var로 선언된 변수는 언제든지 재할당이 가능하다.

반면, const로 선언된 변수는 재할당이 불가능하다. 한 번 값이 할당된 이후에는 해당 값을 변경할 수 없으며, 이를 상수라고 부른다.

### 가비지 컬렉터

변수에 재할당이 이루어지면 기존에 저장되어 있던 값은 더 이상 필요하지 않게 되는데, 자바스크립트 엔진은 이러한 불필요한 값을 자동으로 메모리에서 해제한다. 이를 가비지 컬렉터가 수행하며, 메모리 누수를 방지하는 역할을 한다.

결론적으로, const는 변수를 상수로 만들며 재할당이 불가능하고, var로 선언된 변수는 재할당이 가능하다. 메모리 관리 측면에서는 가비지 컬렉터가 필요 없는 값을 자동으로 처리해 준다.

## 🧐 CH04 예시문제

1. 자바스크립트에서 변수를 선언하고 값이 할당될 때, 메모리 상에 어떻게 저장되는지 설명하세요. 또한, undefined 값이 처음에 변수에 할당되는 이유를 설명하시오.

<details>
    <summary>해설</summary>
    1. 변수 선언:
변수를 선언하면 자바스크립트 엔진은 해당 변수를 메모리에 등록합니다. 이때, 자바스크립트는 선언된 변수를 일단 undefined로 초기화합니다. 이 과정은 `호이스팅(hoisting)` 이라는 메커니즘으로 설명되며, 코드 실행 전에 모든 변수 선언이 코드 상단으로 끌어올려지기 때문에, 변수를 선언하기 전에 그 변수에 접근하면 undefined 값이 반환됩니다. 
<br><br>
    2. 값의 할당
변수 선언 후, 값을 할당할 때는 `할당 연산자(=)` 를 사용하여 변수를 메모리 상에 저장합니다. 이때, 변수는 메모리 주소와 연결되어 있고, 값은 그 메모리 주소에 저장됩니다.
<br>
메모리에 저장된 값은 새로운 값이 할당될 때 덮어쓰기가 이루어집니다. 자바스크립트 엔진은 새로운 값을 저장하기 위해 기존 값을 지우지 않고, 해당 메모리 주소에 있는 데이터를 덮어씁니다. 이 덮어쓰기 방식은 자바스크립트의 가비지 컬렉터(Garbage Collector)에 의해 관리됩니다. 즉, 더 이상 참조되지 않는 값은 메모리에서 자동으로 해제되며, 메모리 누수를 방지합니다.
<br><br>
    3. undefined가 처음에 할당되는 이유:<br>
자바스크립트는 호이스팅 과정에서 변수를 선언만 하고, 값이 할당되지 않았을 경우 그 변수를 undefined로 초기화합니다. 이는 메모리 상에서 해당 변수를 사용할 준비가 되었음을 의미하며, 선언은 되었으나 값이 아직 할당되지 않았음을 나타냅니다.
<br>
undefined는 자바스크립트에서 변수가 선언되었지만 아직 값이 설정되지 않았음을 명확히 하며, 프로그램이 오류를 발생시키지 않고 안정적으로 실행되도록 돕는 역할을 합니다.
<br><br>

</details>
<br><br>

2. 자바스크립트에서 var, let, const 키워드를 사용하여 변수를 선언할 때, `각 키워드가 영향을 미치는 스코프(scope)`에 대해 설명하세요.<br>
또한, `각 키워드가 변수의 메모리 할당 방식과 변수 재할당 가능 여부에서 어떻게 다르게 동작하는지` 설명하시오.<br><br>
<details>
    <summary>해설</summary>
        <li>var</li>
        영향을 미치는 스코프: var는 함수 스코프를 따릅니다. 이는 변수가 선언된 함수 내에서만 유효하며, 함수 외부에서는 접근할 수 없습니다.<br> 하지만 var는 블록(if, for, while 등) 내에서도 함수 전체에서 유효하기 때문에, 의도치 않게 변수가 재선언되어 문제를 일으킬 수 있습니다. <br>이로 인해 var는 전역 변수로 선언된 경우, 다른 코드와 충돌할 가능성이 커집니다.<br><br>
        메모리 할당 방식: var는 코드 실행 전에 호이스팅되어 최상단으로 끌어올려집니다. 초기값은 undefined로 설정됩니다.<br> 즉, 변수를 선언하기 전에 접근할 수 있으나 그 값은 undefined입니다.
        <br><br>
        재할당 가능 여부: var로 선언된 변수는 언제든지 재할당이 가능합니다. 동일한 이름으로 여러 번 선언할 수 있으며, 그 값도 덮어쓰기가 가능합니다.
        <br><br>
        <li>let</li>
        영향을 미치는 스코프: let은 블록 스코프를 따릅니다. let으로 선언된 변수는 해당 블록 내부에서만 유효하며, 블록을 벗어나면 접근할 수 없습니다. <br>이로 인해 let은 동일한 변수명이 블록 내부에서 재선언되지 않고, 블록 바깥과의 충돌을 방지합니다. 이를 통해 코드의 안정성과 가독성이 높아집니다.
        <br><br>
        메모리 할당 방식: let은 호이스팅되지만, 선언 전에 변수에 접근할 수 없습니다. 이를 Temporal Dead Zone(TDZ)이라고 하며, 변수가 선언되기 전에는 사용할 수 없습니다. 이 메커니즘을 통해 선언 전 접근을 막아, 잠재적인 오류를 방지합니다.
        <br><br>
        재할당 가능 여부: let으로 선언된 변수는 재할당이 가능합니다. 하지만 동일한 블록 내에서 동일한 이름으로 변수를 다시 선언할 수는 없습니다.
        <br><br>
        <li>const</li>
        영향을 미치는 스코프: const 역시 블록 스코프를 따릅니다. const로 선언된 변수는 블록 내에서만 유효하며, 블록 바깥에서는 접근할 수 없습니다. const는 let과 마찬가지로 변수가 선언된 블록 바깥에서는 접근할 수 없으므로, 변수의 재선언이나 외부 간섭을 방지하는 데 유리합니다.

</details>
<br><br>

# 표현식과 문

## 값

### 값의 정의:

값은 식이 평가(evaluate)된 결과를 의미하며, 평가된 식의 결과로 값이 생성된다.<br>

### 메모리 저장:

모든 값은 데이터 타입을 가지며 메모리에 2진수 형태로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석된다.<br>

### 변수와 값의 할당:

변수는 하나의 값을 저장하기 위한 메모리 공간으로, 변수가 기억하는 것은 평가된 값이다. 예를 들어, var sum = 10 + 20; 에서 변수 sum에 저장된 값은 30이며, 10 + 20이 아니라 그 평가된 결과인 30이 저장된다.<br>
<br>

## 리터럴

### 리터럴의 정의

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.<br>
예를 들어, 숫자 3은 단순한 아라비아 숫자가 아니라 숫자 리터럴로, 자바스크립트 코드에서 이를 기입하면 엔진이 이를 평가해 숫자 값 3을 생성한다.

### 리터럴의 종류와 예시

리터럴은 다양한 타입의 값을 생성할 수 있다. <br>다음은 리터럴의 여러 종류와 예시다:
<br><br>
정수 리터럴: 100<br>
부동소수점 리터럴: 10.5<br>
2진수 리터럴: 0b01000001<br>
8진수 리터럴: 00101<br>
16진수 리터럴: 0x41<br>
문자열 리터럴: 'Hello', "World"<br>
불리언 리터럴: true, false<br>
null 리터럴: null<br>
undefined 리터럴: undefined<br>
객체 리터럴: { name: 'Lee', address: 'Seoul' }<br>
배열 리터럴: [1, 2, 3]<br>
함수 리터럴: function() {}<br>
정규 표현식 리터럴: /[A-Z]+/g<br>
<br><br>

## 표현식

**표현식(Expression)** 은 값으로 평가될 수 있는 코드 조각을 말한다. 예를 들어, 10, score = 100 같은 식이 표현식이다.<br>
**문(Statement)** 은 독립적으로 실행 가능한 완전한 작업 단위를 의미한다. 예를 들어, 변수 선언이나 할당 같은 작업이 문이다.
<br><br>

### 표현식의 예

단순 표현식: 리터럴이나 변수 이름과 같이 단순히 값을 나타내는 표현식이다.<br>
예: 10, score, person.name, arr[1]<br>
연산자 표현식: 연산자를 사용해 값을 조합하거나 계산하는 표현식이다.<br>
예: 10 + 20, sum = 10, sum != 10<br>
함수/메서드 호출 표현식: 함수나 메서드를 호출하는 표현식이다.<br>
예: square(), person.getName()
<br><br>

## 문

**문(statement)** 은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다. 문은 토큰(token)이라는 더 이상 나눌 수 없는 코드의 기본 요소로 구성되며, 예를 들어 키워드, 식별자, 연산자, 리터럴 등이 토큰에 해당된다.

### 문과 명령문

문은 컴퓨터에 내리는 명령으로, 실행되면 특정 작업을 수행하게 된다. 예를 들어, 변수를 선언하거나, 값을 할당하거나, 특정 조건에 따라 코드를 실행하는 등의 작업을 포함한다.

### 문 예시

변수 선언문: var x;<br>
할당문: x = 5;<br>
함수 선언문: function foo() {}<br>
조건문: if (x > 1) { console.log(x); }<br>
반복문: for (var i = 0; i < 2; i++) { console.log(i); }<br>

### 표현식과 문의 차이

1. 표현식(Expression)
   정의: 값으로 평가될 수 있는 코드 조각이다. 즉, 표현식이 실행되면 값을 반환한다.

예시:

- 10 + 20 → 30 (숫자 값을 반환)
- "Hello" + "World" → "HelloWorld" (문자열을 반환)<br>
- x > 1 → true 또는 false (불리언 값을 반환)
표현식은 결과적으로 항상 하나의 값을 만들어낸다. 이 값은 숫자, 문자열, 불리언, 객체 등이 될 수 있다.<br>

특징: 표현식은 프로그램의 다른 부분에서 값으로 사용될 수 있다. 예를 들어, 변수에 할당되거나 함수의 인자로 전달될 수 있다.<br>

2. 문(Statement)
   정의: 프로그램에서 어떤 작업을 수행하는 명령이다. 문은 표현식처럼 값을 반환하는 것이 아니라, 작업을 수행한다.

예시:

- var x = 10; (변수 선언과 할당 작업을 수행)<br>
- if (x > 1) { console.log("x가 1보다 큽니다."); } (조건문을 실행)<br>
- for (var i = 0; i < 10; i++) { console.log(i); } (반복문을 실행)<br>
- 문은 어떤 일을 수행하지만, 그 자체로 값을 반환하지 않는다.<br>
