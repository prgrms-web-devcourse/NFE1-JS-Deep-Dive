[45. 프로미스](#45-프로미스)

[46. 제너레이터와 async/await](#46-제너레이터와-asyncawait)

[47. 에러 처리](#47-에러-처리)

[48. 모듈](#48-모듈)

[49. Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축](#49-babel과-webpack을-이용한-es6esnext-개발-환경-구축)

# 45. 프로미스

자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다.

ES6에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입했다. 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

## 45.1 비동기 처리를 위한 콜백 패턴의 단점

### 콜백 헬

비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다.

**비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다.**

- 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.
- `get` 함수가 비동기 함수인 이유는 `get` 함수 내부의 `onload` 이벤트 핸들러가 비동기로 동작하기 때문이다.
  - 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다.
  - 따라서 비동기 함수의 처리 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.
  - 이때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 일반적이다.
  - 필요에 따라 비동기 처리가 성공하면 호출될 때 콜백 함수와 비동기 처리가 실패하면 호출될 콜백 함수를 전달할 수 있다.
- 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상이 발생하는데, 이를 **`콜백 헬(callback hell)`** 이라 한다.
  - 콜백 헬은 가독성을 나쁘게 하며 실수를 유발하는 원인이 된다.

```jsx
// 콜백 헬이 발생하는 전형적인 사례
get("/step1", (a) => {
  get("/step2/{a}", (b) => {
    get("/step3/${b}", (c) => {
      get("/step4/${c}", (d) => {
        console.log(d);
      });
    });
  });
});
```

### 에러 처리의 한계

비동기 처리를 위한 콜백 패턴의 문제점 중 가장 심각한 것은 에러 처리가 곤란하다.

```jsx
try {
  setTimeout(() => {
    throw new Error("Error!");
  }, 1000);
} catch (e) {
  // 에러를 캐치하지 못한다.
  console.log("캐치한에러", e);
}
```

- 비동기 함수인 `setTimeout` 이 호출되면 `setTimeout` 함수의 실행 컨텍스트가 생성되어 콜 스택에 푸시되어 실행된다.
  - `setTimeout` 은 비동기 함수이므로 콜백 함수가 호출되는 것을 기다리지 않고 즉시 종료되어 콜 스택에서 제거된다.
  - 이후 타이머가 완료되면 `setTimeout` 함수의 콜백 함수는 태스크 큐로 푸시되고 콜 스택이 비어져있을 때 이벤트 루프에 의해 골 스택으로 푸시되어 실행된다.
- `setTimeout` 함수의 콜백 함수가 실행될 때 `setTimeout` 함수는 이미 콜 스택에서 제거된 상태다.
  - `setTimeout` 함수의 콜백 함수를 호출한 것이 `setTimeout` 함수가 아니라는 것을 의미한다.
  - `setTimeout` 함수의 콜백 함수 호출자가 `setTimeout` 함수라면 콜 스택의 현재 실행 중인 실행 컨텍스트가 콜백 함수의 실행 컨텍스트일 때, 현재 실행 중인 실행 컨텍스트의 하위 실행 컨텍스트가 `setTimeout` 함수여야 한다.
- **에러는 호출자 방향으로 전파된다.**
  - 즉, 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다.
  - 하지만 `setTimeout` 함수의 콜백 함수를 호출한 것은 `setTimeout` 함수가 아니다.
  - 따라서 `setTimeout` 함수의 콜백 함수가 발생시킨 에러는 `catch` 블록에서 캐치되지 않는다.
- 비동기 처리를 위한 콜백 패턴은 콜백 헬이나 에러 처리가 곤란하므로 ES6에서 프로미스(Promise)가 도입되었다.

## 45.2 프로미스의 생성

**`Promise` 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성한다.**

- ES6에서 도입된 `Promise` 는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체다.
- `Promise` 생성자 함수는 비동기 처리를 수행할 때 콜백 함수를 인수로 전달받는다.
  - 콜백 함수는 `resolve` 와 `reject` 함수를 인수로 전달받는다.

```jsx
// 프로미스 생성
const promise = new Promise((resolve, reject) => {
	// Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행한다.
	if(/* 비동기 처리 성공 */) {
		resolve('result');
	} else { /* 비동기 처리 실패 */
		reject('failure reason');
	}
});
```

- Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다.
- 이때 비동기 처리가 성공하면 콜백 함수의 인수로 전달받은 `resolve` 함수를 호출한다.
- 만약 비동기 처리가 실패하면 `reject` 함수를 호출한다.

| 프로미스의 상태 정보 | 의미                                  | 상태 변경 조건                   |
| -------------------- | ------------------------------------- | -------------------------------- |
| pending              | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
| fulfilled            | 비동기 처리가 수행된 상태(성공)       | resolve 함수 호출                |
| rejected             | 비동기 처리가 수행된 상태(실패)       | reject 함수 호출                 |

- 프로미스는 위와 같이 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 정보를 갖는다.
  - 생성된 직후의 프로미스는 기본적으로 `pendging` 상태다.
  - 이후 비동기 처리가 수행되면 비동기 처리 결과에 따라 프로미스의 상태가 변경된다.
    - 비동기 처리 성공: `resolve` 함수를 호출해 프로미스를 `fulfilled` 상태로 변경한다.
    - 비동기 처리 실패: `reject` 함수를 호출해 프로미스를 `rejected` 상태로 변경한다.
- **프로미스의 상태는 `resolve` 또는 `reject` 함수를 호출하는 것으로 결정된다.**
- **프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.**

## 45.3 프로미스의 후속 처리 메서드

**프로미스의 비동기 처리 상태가 변화하면 이에 따른 후속 처리를 해야한다.**

- 프로미스가 `fulfilled` 상태가 되면 프로미스의 처리 결과를 가지고 무언가를 해야하고, `rejected` 상태가 되면 처리 결과(에러)를 가지고 에러 처리를 해야한다.
- 이를 위해 프로미스는 후속 처리 메서드 `then` , `catch` , `finally` 를 제공한다.
- **프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.**
  - 후속 처리 메서드의 콜백 함수에 프로미스의 처리 결과가 인수로 전달된다.

### Promise.prototype.then

`then` 메서드는 두 개의 콜백 함수를 인수로 전달받는다.

- 첫 번째 콜백 함수는 프로미스가 `fulfilled` 상태(`resolve` 함수가 호출된 상태)가 되면 호출된다.
  - 이때 콜백 함수는 프로미스의 비동기 처리 결과를 인수로 전달받는다.
- 두 번째 콜백 함수는 프로미스가 `frejected` 상태(`reject` 함수가 호출된 상태)가 되면 호출된다.
  - 이때 콜백 함수는 프로미스의 에러를 인수로 전달받는다.
- 즉 첫 번째 콜백 함수는 비동기 처리가 성공했을 때 호출되는 성공 처리 콜백 함수이며, 두 번째 콜백 함수는 비동기 처리가 실패했을 때 호출되는 실패 처리 콜백 함수다.

```jsx
// fulfilled
new Promise((resolve) => resolve("fulfilled")).then(
  (v) => console.log(v),
  (e) => console.log(e)
); // fulfilled

// rejected
new Promise((_, reject) => reject(new Error("rejected"))).then(
  (v) => console.log(v),
  (e) => console.log(e)
); // Error: rejected
```

### Promise.prototype.catch

`catch` 메서드는 한 개의 콜백 함수를 인수로 전달 받는다.

- `catch` 메서드의 콜백 함수는 프로미스가 `rejected` 상태인 경우만 호출된다.

```jsx
// rejected
new Promise((_, reject) => reject(new Error("rejected"))).catch((e) =>
  console.log(e)
); // Error: rejected
```

- `catch` 메서드는 `then(undefined. onRejected)` 와 동일하게 동작한다.
- 따라서 `then` 메서드와 마찬가지로 언제나 프로미스를 반환한다.

### Promise.prototype.finally

`finally` 메서드는 한 개의 콜백 함수를 인수로 전달받는다.

- `finally` 메서드의 콜백 함수는 프로미스의 성공, 실패와 상관없이 무조건 한 번 호출된다.
- 따라서 프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.

```jsx
new Promise(() => {}).finally(() => console.log("finally")); // finally
```

```jsx
// 예제
const promiseGet = (url) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.send();

    xhr.onload = () => {
      if (xhr.status === 200) {
        // 성공적으로 응답을 받으면 resolve 함수를 호출한다.
        resolve(JSON.parse(xhr.response));
      } else {
        // 에러 처리를 위해 reject 함수를 호출한다.
        reject(new Error(xhr.status));
      }
    };
  });
};

// promiseGet 함수는 프로미스를 반환한다.
promiseGet("https:// ~~~~~ url ~~~")
  .then((res) => console.log(res))
  .catch((err) => console.log(err))
  .finally(() => console.log("Bye!"));
```

## 45.4 프로미스의 에러 처리

- 비동기 처리에서 발생한 에러는 `then` 메서드의 두 번째 콜백 함수로 처리할 수 있다.
- 또한, 프로미스의 후속 처리 메서드 `catch` 를 사용해 처리할 수도 있다.

`then` 메서드의 두 번째 콜백 함수는 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져서 가동성이 좋지 않다.

`catch` 메서드를 모든 `then` 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러뿐만 아니라 `then` 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.

**`then` 메서드에 두 번째 콜백 함수를 전달하는 것보다 `catch` 메서드를 사용하는 것이 가독성이 좋고 명확하다.**

**에러 처리는 `then` 보다 `catch` 메서드에서 하는 것을 권장한다.**

## 45.6 프로미스 체이닝

**프로미스 체이닝(promise chaining) `then` , `catch` , `finally` 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다.**

```jsx
const url = 'https:// ~~~~ url ~~';

// id가 1인 post인 userId를 취득
promiseGet(`${url}/posts/1`)
	// 취득한 post의 userId로 user 정보를 취득
	.then({userId} => promiseGet(`${url}/users/${userId}`))
	.then(userInfo => console.log(userInfo)
	.catch(err => console.log(err));
```

후속처리 메서드의 콜백 함수는 다음과 같이 인수를 전달받으면서 호출된다.

| 후속 처리 메서드 | 콜백 함수의 인수                                                           | 후속 처리 메서드의 반환값                  |
| ---------------- | -------------------------------------------------------------------------- | ------------------------------------------ |
| then             | promiseGet 함수가 반환한 프로미스가 resolve한 값                           | 콜백 함수가 반환한 프로미스                |
| then             | 첫 번째 then 메서드가 반환한 프로미스가 resolve한 값                       | 콜백 함수가 반환한 값을 resolve한 프로미스 |
| catch            | proimseGet 함수 또는 앞선 후속 처리 메서드가 반환한 프로미스가 reject인 값 | 콜백 함수가 반환한 값을 resolve한 프로미스 |

- 후속 처리 메서드는 콜백 함수가 반환한 프로미스를 반환한다.
- 프로미스는 프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속 처리를 하므로 비동기 처리를 위한 콜백 패턴에서 발생하던 콜백 헬이 발생하지않는다.

## 45.6 프로미스의 정적 메서드

**`Promise` 는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가질 수 있다.**

### Promise.resolve / Promise.reject

**`Promise.resolve` 와 `Promise.reject` 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.**

- `Promise.resolve` 메서드는 인수로 전달받은 값을 `resolve` 하는 프로미스를 생성한다.
  ```jsx
  // 배열을 resolve하는 프로미스를 생성
  const resolvedPromise = Promise.resolve([1, 2, 3]);
  resolvedPromise.then(console.log); // [1, 2, 3]
  ```
  - 아래의 예제와 동일하게 동작한다.
  ```jsx
  const resolvedPromise = new Promise((resolve) => resolve([1, 2, 3]));
  resolvedPromise.then(console.log); // [1, 2, 3]
  ```
- `Promise.reject` 메서드는 인수로 전달받은 값은 `reject` 하는 프로미스를 생성한다.
  ```jsx
  // 에러 객체를 reject 하는 프로미스를 생성
  const rejectedPromise = Promise.reject(new Error("Error!"));
  rejectedPromise.catch(console.log); // Error: Error!
  ```

### Promise.all

**`Promise.all` 메서드는 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용한다.**

- 앞선 비동기 처리 결과를 다음 비동기 처리가 사용하지 않을 때 사용한다.
  - 여러 개의 비동기 처리를 순차적으로 처리할 필요가 없다.

```jsx
const requestData1 = () =>
  new Promise((resolve) => setTimeout(() => resolve(1), 3000));
const requestData2 = () =>
  new Promise((resolve) => setTimeout(() => resolve(2), 2000));
const requestData3 = () =>
  new Promise((resolve) => setTimeout(() => resolve(3), 1000));

// 세 개의 비동기 처리를 병렬로 처리
Promise.all([requestData1(), requestData2(), requestData3()])
  .then(console.log) // [1, 2, 3] -> 약 3초 소요
  .catch(console.error);
```

- `Promise.all` 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.
- `Promise.all` 메서드는 인수로 전달받은 배열의 모든 프로미스가 모두 `fulfilled` 상태가 되면 종료한다.
- `Promise.all` 메서드가 종료하는 데 걸리는 시간은 가장 늦게 `fulfilled` 상태가 되는 프로미스의 처리 시간보다 조금 더 길다.
- `Promise.all` 메서드드의 인수로 전달받은 배열의 프로미스가 하나라도 `rejected` 상태가 되면 나머지 프로미스가 `fulfilled` 상태가 되는 것을 기다리지 않고 즉시 종료한다.
  - 가장 먼저 `rejected` 상태가 된 프로미스가 `reject` 한 에러가 `catch` 메서드로 전달된다.

### Promise.race

**`Promise.race` 메서드는 `Promise.all` 메서드와 동일하게 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.**

- 가장 먼저 `fulfilled` 상태가 된 프로미스의 처리 결과를 `resolve` 하는 새로운 프로미스를 반환한다.
- 프로미스가 하나라도 `rejected` 상태가 되면 에러를 `reject` 하는 새로운 프로미스를 즉시 반환한다.

```jsx
Promise.race([
  new Promise((resolve) => setTimeout(() => resolve(1), 3000)), // 1
  new Promise((resolve) => setTimeout(() => resolve(2), 2000)), // 2
  new Promise((resolve) => setTimeout(() => resolve(3), 1000)), // 3
])
  .then(console.log) // 3
  .catch(console.log);
```

### Promise.allSettled

**`Promise.allSettled` 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.**

- 전달 받은 프로미스가 모두 `settle` 상태(비동기 처리가 수행된 상태, fulfilled 또는 rejected 상태)가 되면 처리 결과를 배열로 반환한다.

```jsx
Promise.allSettled([
	new Promise(resolve => setTimeout(() => resolve(1), 2000)),
	new Promise((_, reject) => setTimeout(() => reject(new Error('Error!'), 1000)
])
	.then(console.log);

/*
	[
		{status: 'fulfilled', value: 1},
		{status: 'rejected', reason: Error: Error!}
	]
*/
```

- `Promise.allSettled` 메서드가 반환한 배열에는 `fulfilled` 또는 `rejcted` 상태와는 상관없이 인수로 전달받은 모든 프로미스들의 처리 결과가 모두 담겨있다.
  - 프로미스가 `fulfilled` 상태인 경우 비동기 처리 상태를 나타내는 `status` 프로퍼티와 처리 결과를 나타내는 `value` 프로퍼티를 갖는다.
  - 프로미스가 `rejected` 상태인 경우 비동기 처리 상태를 나타내는 `status` 프로퍼티와 에러를 나타내는 `reason` 프로퍼티를 갖는다.

## 45.7 마이크로태스크 큐

```jsx
setTimeout(() => console.log(1), 0);

Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
```

- 프로미스의 후속 처리 메소드는 비동기로 동작하므로 `1 -> 2 -> 3` 의 순으로 출려될 것 같지만, `2 -> 3 -> 1` 순으로 출력된다.
- 프로미스의 후속처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로태스크 큐에 저장되기 때문이다.
- 마이크로태스크 큐는 태스크 큐와는 별도의 큐다.
  - 마이크로 태스크 큐는 후속 처리 메서드의 콜백 함수가 일시 저장된다.
- 비동기 함수의 콜백 함수, 이벤트 핸들러는 `태스크 큐` 에 일시 저장된다.
- 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.
  - 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 가져와 실행한다.
  - 이후 마이크로태스크 큐가 비면 태스크 큐에서 대기하고 있는 함수를 가져와 실행한다.

## 45.8 fetch

**`fetch` 함수는 `XMLHttpRequest` 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이트 WEB API다.**

- `fetch` 함수는 HTTP 응답을 나타내는 `Response` 객체를 래핑한 `Promise` 객체를 반환한다.
- `fetch` 함수가 반환하는 프로미스는 `404 Not Found` , `500 Internal` 와 같은 HTTP 에러가 발생하도 에러를 `reject` 하지 않고 불리언 타입의 `ok` 상태를 `false` 상태로 설정한 `Response` 객체를 `resolve` 한다.

```jsx
const wrongUrl = 'https://~~~~';

// 부적절한 URL이 지정되었기 때문에 404 Not Found에러가 발생한다.
fetch(wrongUrl)
	.then(() => console.log('ok'))
	.catch(() => console.log('error');
```

- `fetch` 는 네트워크 요청이 성공하면(404, 500 에러가 발생했어도) `Promise` 를 `Resolved` 상태로 반환한다.
- 따라서 HTTP 상태 코드를 확인하려면 `response.ok` 또는 `response.state` 를 확인해야 한다.

# 46. 제너레이터와 async/await

## 46.1 제너레이터란?

**ES6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수다.**

- 제너레이터와 일반 함수의 차이점
  - **제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.**
    - 함수 호출자는 함수를 호출한 이후 함수 실행을 제어할 수 없다.
    - 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다.
    - 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도할 수 있다.
  - **제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.**
    - 함수가 실행되고 있는 동안에는 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다.
    - 제너레이터 함수는 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다.
    - 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다.
  - **제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.**
    - 일반 함수를 호출하면 함수 코드를 일괄 실행하고 값을 반환한다.
    - 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터 객체를 반환한다.

## 46.2 제너레이터 함수의 정의

**제너레이터 함수는 `function*` 키워드로 선언한다.** 그리고 하나 이상의 `yield` 표현식을 포함한다.

- `*` 의 위치는 `function` 키워드와 함수 이름 사이라면 어디든 상관없다.
  - 일관성을 유지하기 위해 `function` 키워드 바로 뒤에 붙이는 것을 권장한다.
- 제너레이터 함수는 화살표 함수로 정의할 수 없다.
- 제러레이터 함수는 `new` 연산자와 함께 호출할 수 없다.

## 46.3 제너레이터 객체

**제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다.**

- 제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터이다.
  - 제너레이터 객체는 `Symbol.iterator` 메서드를 상속받는 이터러블이면서 `value` , `done` 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 `next` 메서드를 소유하는 이터레이터다.
  - 제너레이터 객체는 `next` 메서드를 가지는 이터레이터이므로 `Symbol.iterator` 메서드를 호출해서 별도로 이터레이터를 생성할 필요가 없다.

## 46.4 제너레이터의 일시 중지와 재개

**제너레이터는 `yield` 키워드와 `next` 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다.**

- 제너레이터는 함수 호출자에게 제어권을 양도하여 필요한 시점에 함수를 재개할 수 있다.
- 제너레이터 함수를 호출하면 제너레이터 함수의 코드 블록이 실행되는 것이 아니라 제너레이터 객체를 반환한다.
- 제너레이터 객체는 `next` 메서드를 호출하면 제너레이터 함수의 코드 블록을 실행한다.
- `yield` 표현식까지만 실행한다.
- **`yield` 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 `yield` 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.**

```jsx
// 제너레이터 함수
function* genFunc() {
  yield 1;
  yield 2;
  yield 3;
}

// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
// 이터러블이면서 동시에 이터레이터인 제너레이터는 next 메서드를 갖는다.
const generator = genFunc();

// 처음 next 메서드를 호출하면 첫 번째 yield표현까지 실행되고 중지된다.
// next 메서드는 이터레이터이면서 리절트 객체({value, done}) 를 반환한다.
// value 프로퍼티에는 첫 번째 yield 표현식에서 yield된 값 1이 할당된다.
// done 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 false가 할당된다.
console.log(generator.next()); // { value:1, done: false }

// 다시 next 메서드를 호출하면 두 번째 yield 표현식까지 실행되고 일시 중지된다.
console.log(generator.next()); // { value: 2, done: false }

console.log(generator.next()); // { value: 3, done: false }

console.log(generator.next()); // value: undefined, done: true }
```

- **제너레이터의 `next` 메서드를 호출하면 `yield` 표현식까지 실행되고 일시 중지된다.**
  - 이때 함수의 제어권이 호출자로 양도된다.
  - 이후 필요한 시점에 호출자다 또다시 `next` 메서드를 호출하면 일시 중지된 코드부터 실행을 재개하기 시작하고 다음 `yield` 표현식까지 실행되고 또 다시 일시 중지된다.
- **제너레이터 객체의 `next` 메서드는 `value` , `done` 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.**
  - `next` 메서드가 반환한 이터레이터 리절트 객체의 `value` 프로퍼티에는 `yield` 표현식에서 `yield` 된 값이 할당되고 `done` 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 불리언 값이 할당된다.
- 제너레이터 객체의 `next` 메서드에 전달한 인수는 제너레이터 함수의 `yield` 표현식을 할당받는 변수에 할당된다.

## 46.6 async/await

제너레이터를 사용해서 비동기 처리를 동기 처럼 동작하도록 만큰 코드는 가독성이 나쁘다는 문제점이 있다.

- **ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 `async/await` 가 도입되었다.**
- `async/await` 는 프로미스를 기반으로 동작한다.
  - `async/await` 을 사용하면 프로미스의 `then/catch/finally` 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 동기처럼 프로미스를 사용할 수 있다.

### async 함수

**`await` 키워드는 반드시 `async` 함수 내부에서 사용해야한다.**

- `async` 함수는 `async` 키워드를 사용해 정의하며 언제나 프로미스를 반환한다.
- `async` 함수가 명시적으로 프로미스를 반환하지 않더라도 암묵적으로 반환값을 `resolve` 하는 프로미스를 반환한다.
- 클래스의 `constructor` 메서드는 `async` 메서드가 될 수 없다.
  - 클래스의 `constructor` 메서드는 인스턴스를 반환해야 하지만 `async` 함수는 언제나 프로미스를 반환해야 한다.

### await 키워드

**`await` 키워드는 프로미스가 `settled 상태` (비동기 처리가 수행된 상태)가 될 때까지 대기하다가 `settled` 상태가 되면 프로미스가 `resolve` 한 처리 결과를 반환한다.**

- `await` 키워드는 반드시 프로미스 앞에서 사용해야 한다.
- `await` 키워드는 다음 실행을 일시 중지시켰다가 프로미스가 `settled` 상태가 되면 다시 재개한다.

### 에러 처리

**`async/await` 에서 에러 처리는 `try ... catch` 문을 사용할 수 있다.**

- 콜백 함수를 인수로 전달받는 비동기 함수와는 달리 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.
- `HTTP` 통신에서 발생한 네트워크 에러뿐 아니라 `try` 코드 블록 내의 모든 문에서 발생한 일반적인 에러까지 모두 캐치할 수 있다.
- **`async` 함수 내에서 `catch` 문을 사용해서 에러 처리를 하지 않으면 `async` 함수는 발생한 에러를 `reject` 하는 프로미스를 반환한다.**
  - 따라서 `async` 함수를 호출하고 `Promise.prototype.catch` 후속 처리 메서드를 사용해 에러를 캐치할 수도 있다.

# 47. 에러 처리

## 47.1 에러 처리의 필요성

**에러는 언제나 발생할 수 있으며 발생한 에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다.**

- 에러 뿐 아니라 예외적인 상황에 대응하지 않으면 프로그램은 강제 종료될 것이다.
- 하지만 에러나 예외적인 상황은 너무 다양하기 때문에 작성한 코드는 언제나 에러나 예외적인 상황이 발생할 수 있다는 것을 전제하고 대응하는 코드를 작성하는 것이 중요하다.

## 47.2 try … catch … finally 문

기본적으로 에러 처리를 구현하는 방법은 크게 두 가지가 있다.

- 예외적인 상황이 발생하면 반환하는 값을 확인해서 처리하는 방법과 에러 처리 코드를 미리 등록해두고 에러가 발생하면 에러 처리 코드로 점프하도록 하는 방법이 있다.
- `try ... catch ... finally` 문은 활용한 방법을 일반적으로 에러 처리라고 한다.
  - `finally` 문은 불필요하다면 생략 가능하다.
  - `catch` 문도 생략 가능하지만, `try` 문이 의미가 없으므로 생략하지 않는다.

```jsx
try {
  // 실행할 코드 (에러가 발생할 가능성이 있는 코드)
} catch (err) {
  // try 코드 블록에서 에러가 발생하면 이 코드 블록의 코드가 실행된다.
  // err에는 try 코드 블록에서 발생한 Error 객체가 전달된다.
} finally {
  // 에러 발생과 상관없이 반드시 한 번 실행된다.
}
```

- `try ... catch ... finally` 문으로 에러를 처리하면 프로그램이 강제 종료되지 않는다.

## 47.3 Error 객체

**`Error` 생성자 함수는 에러 객체를 생성한다.**

- `Error` 생성자 함수에는 에러를 상세히 설명하는 에러 메시지를 인수로 전달할 수 있다.
- `Error` 생성자 함수가 생성한 에러 객체는 `message` 프로퍼티와 `stack` 프로퍼티를 갖는다.
  - `message` 프로퍼티의 값은 `Error` 생성자 함수에 인수로 전달한 에러 메시지다.
  - `stack` 프로퍼티의 값은 에러를 발생시킨 콜스택의 호출 정보를 나타내는 문자열이며 디버깅 목적으로 사용한다.
- `Error` 생성자 함수를 포함해 7가지의 에러 객체를 생성할 수 있는 `Error` 생성자 함수를 제공한다.
  - 에러 객체의 프로토타입은 모두 `Error.prototype` 을 상속받는다.

| 생성자 함수    | 인스턴스                                                                       |
| -------------- | ------------------------------------------------------------------------------ |
| Error          | 일반적 에러 객체                                                               |
| SyntaxError    | 자바스크립트 문법에 맞지 않는 문을 해석할 때 발생하는 에러 객체                |
| ReferenceError | 참조할 수 없는 식별자를 참조했을 때 발생하는 에러 객체                         |
| TypeError      | 피연산자 또는 인수의 데이터 타입이 유효하지 않을 때 발생하는 에러 객체         |
| RanageError    | 숫자의 허용 범위를 벗어났을 때 발생하는 에러 객체                              |
| URIError       | encodeURI 또는 decodeURI 함수에 부적절한 인술르 전달했을 때 발생하는 에러 객체 |
| EvalError      | eval 함수에서 발생하는 에러 객체                                               |

## 47.4 throw 문

**`Error` 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다.**

- 에러 객체 생성과 에러 발생은 의미가 다르다.
- 에러를 발생시키려면 `try` 코드 블록에서 `throw` 문으로 에러 객체를 던져야 한다.

```jsx
try {
  // 에러 객체를 생성한다고 에러가 발생하는 것은 아니다.
  new Error("something wrong");
} catch (error) {
  console.log(error);
}
```

- `throw` 문의 일반적으로 에러 객체를 지정한다.
  - 에러를 던지면 `catch` 문의 에러 변수가 생성되고 던져진 에러 객체가 할당된다.
  - 또한 `catch` 코드 블록이 실행되기 시작한다.

```jsx
throw 표현식;
```

```jsx
try {
  // 에러 객체를 던지면 catch 코드 블록이 실행되기 시작한다.
  throw new Error("something wrong");
} catch (error) {
  console.log(error);
}
```

## 47.5 에러의 전파

**에러는 호출자 방향으로 전파된다.**

- 즉, 콜 스택 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다.

```jsx
const foo = () => {
  throw Error("foo에서 발생한 에러");
};

const bar = () => {
  foo();
};

const baz = () => {
  bar();
};

try {
  baz();
} catch (err) {
  console.log(err);
}
```

- `foo` 함수가 `throw` 한 에러는 다음과 같이 호출자에게 전파되어 전역에서 캐치된다.
  - `foo 실행 컨텍스트` → `bar 실행 컨텍스트` → `baz 실행 컨텍스트` → `전역 실행 컨텍스트`
- `throw` 된 에러를 캐치하지 않으면 호출자 방향으로 전파된다.
  - 에러를 캐치하여 적절히 대응하면 프로그램을 강제 종료시키지 않고 코드의 실행 흐름을 복구할 수 있다.
  - `throw` 된 에러를 어디에서도 캐치하지 않으면 프로그램은 강제 종료된다.
- 비동기 함수인 `setTimeout` 이나 프로매스 후속 처리 메서드의 콜백 함수는 호출자가 없다는 것이다.
  - 콜백 함수는 태스크 큐나 마이크로태스크 큐에 일시 저장되었다가 콜 스택이 비면 이벤트 루프에 의해 콜 스택으로 푸시되어 실행된다.
  - 이때 콜스택에 푸시된 콜백 함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재하게 된다.
  - 따라서 에러를 전파할 호출자가 존재하지 않는다.

# 48. 모듈

## 48.1 모듈의 일반적 의미

**모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.**

- 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다.
  - 모듈이 성립하려면 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.
- 자신만의 파일 스코프를 갖는 모듈의 모든 자산은 캡슐화되어 다른 모듈에서 접근할 수 없다.
  - 모듈은 개별적 존재로서 애플리케이션과 분리되어 존재한다.
- 하지만 모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 의미가 있다.
  - **따라서 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. 이를 `export` 라 한다.**
- 공개된 모듈의 자산은 다른 모듈에서 재사용 할 수 있다.
  - 공개된 모듈의 자산을 사용하는 모듈을 모듈 사용자라 한다.
  - **모듈 사용자는 모듈이 공개한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용할 수 있다. 이를 `import` 라 한다.**
- 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높일 수 있다.

## 48.2 자바스크립트와 모듈

클라이언트 사이트 자바스크립트는 `script` 태그를 사용하여 외부의 자바스크립트 파일을 로드할 수 있지만 파일마다 독립적인 파일 스코프를 갖지 않는다.

- 자바스크립트 파일을 여러 개의 파일로 분리하여 `script` 태그로 로드해도 분리된 자바스크립트 파일들은 결국 하나의 자바스크립트 파일 내에 있는 것처럼 동작한다.
  - 즉, 모든 자바스크립트 파일은 하나의 전역을 공유한다.
  - 따라서 분리된 자바스크립트 파일들의 전역 변수가 중복되는 등의 문제가 발생할 수 있으며, 이것으로는 모듈을 구현할 수 없다.
- 모듈 문제를 해결하기 위해 제안된 것이 `CommonJS` 와 `AMD(Asynchronous Module Definition)` 다.
- 자바스크립트 런타임 환경인 Node.js는 모듈 시스템의 사실상 표준인 `CommonJS` 를 채택했고 기본적으로 `CommonJS` 사양을 따르고 있다.
- 즉 Node.js는 ECMAScript 표준 사양은 아니지만 모듈 시스템을 지원한다.
  - 따라서 Node.js 환경에서는 파일별로 독립적인 파일 스코프를 갖는다.

## 48.3 ES6 모듈 (ESM)

ES6에서 클라이언트 사이트 자바스크립트에서도 동작하는 모듈 기능을 추가했다.

- ES6 모듈은 앞으로 `ESM` 이라 부른다.
- ES6 모듈의 사용법은 script 태그에 `type="module"` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.
  - 일반적인 자바스크립트 파일이 아닌 ESM임을 명확히 하기 위해 ESM의 파일 확장자는 `mjs` 를 사용할 것을 권장한다.
- ESM에는 클래스와 마찬가지로 기본적으로 `strict mode` 가 적용된다.

### 모듈 스코프

`ESM` 은 독자적인 모듈 스코프를 갖는다.

- ESM이 아닌 일반적인 자바스크립트 파일은 script 태그로 분리해서 로드해도 독자적인 모듈 스코프 갖지 않는다.
  - script 태그로 분리해서 로드된 2개의 자바스크립트 파일은 하나의 자바스크립트 파일 내에 있는 것처럼 동작한다.
  - 즉, 하나의 전역을 공유한다.
  - 따라서 2개의 자바스크립트 두 파일에서, 선언한 변수는 중복 선언되며 의도치 않게 덮어써진다.

### export 키워드

모듈 내부에서 선언한 모든 식별자는 기본적으로 해당 모듈 내부에서만 참조할 수 있다.

- 모듈 내부에서 선언한 식별자를 외부에서 공개하여 다른 모듈들이 재사용할 수 있게 할려면 `export` 키워들르 사용한다.
- `export` 키워드는 선언문 앞에 사용한다.
  - 이로써 변수, 함수, 클랙스 등 모든 식별자를 `export` 할 수 있다.
- 선언문 앞에 매변 `export` 키워드를 붙이는 것이 번거롭다면 `export` 할 대상을 하나라도 객체로 구성하여 한 번에 `export` 할 수도 있다.

### import 키워드

다른 모듈에서 공개한 식별자를 자신의 모듈 스코프 내부로 로드하려면 `import` 키워드를 사용한다.

- 다른 모듈이 `export` 한 식별자 이름으로 `import` 해야 하며 `ESM` 의 경유 확장자 파일을 생략할 수 없다.

# 49. Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축

매년 새롭게 도입되는 ES6 이상의 버전(ES6+)과 제안 단계에 있는 ES 제안 사양(ES.NEXT)은 브라우저에 따라 지원율이 제각각이다.

- 따라서 `ES6+` 와 `ES.NEXT` 의 최신 ECMAScript 사양을 사용하여 프로젝트를 진행하려면 최신 사양으로 작성된 코드를 경우에 따라 구형 브라우저에서 문제 없이 동작시키기 위한 개발 환경을 구축하는 것이 필요하다.
- 트랜스파일러인 `Babel` 과 `Webpack` 을 이용하여 개발 환경을 구축할 수 있다.

## 49.1 Babel

구형 브라우저에서 지원하지 않는 버전일 경우 `Babel` 을 사용하여 사양을 변환할 수 있다.

```jsx
// ES6의 화살표 함수와 ES7의 지수 연산자
[1, 2, 3].map((n) => n ** n);

// ES5
("use strict");

[1, 2, 3].map(function (n) {
  return Math.pwo(n, n);
});
```

## 49.2 Webpack

`Webpack` 은 의조 관계에 있는 자바스크립트, CSS, 이미지 등의 리소스들을 하나(또는 여러 개)의 파일로 번들링하는 모듈 번들러다.

- `Webpack` 을 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요가 필요 없다.
- 여러 개의 자바스크립트 파일을 하나로 번들링하므로 HTML 파일에서 script 태그로 여러 개의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.
