# **13장 스코프**

### **13.1 스코프란?**

> 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는데 이때 식별자가 유효한 범위를 뜻하는 것이 스코프이다.

- **식별자가 유효한 범위**
- **식별자 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 유효 범위**

```jsx
// var는 함수 내부에서 선언한 경우에만 지역변수 !

var var1 = 1; // 코드의 가장 바깥 영역에서 선언한 변수(전역)

if (true) {
  var var2 = 2; // 코드 블록 내에서 선언한 변수(전역)
  if (true) {
    var var3 = 3; // 중첩된 코드 블록 내에서 선언한 변수(전역)
  }
}

function foo() {
  var var4 = 4; // 함수 내에서 선언한 변수(유효 범위: foo() 내부 )
  function bar() {
    var var5 = 5; // 중첩된 함수 내에서 선언한 변수 (유효 범위: bar() 함수 내부 )
  }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```

### **전역 실행 컨텍스트**

### **함수 실행 컨텍스트**

- `var1,2,3`, `foo()`는 전역 컨텍스트에 속하고 `var`는 함수 스코프를 가지므로 코드 블록안에서 선언해도 전역 접근 가능 ⭕️

- `foo()`함수 선언 시 내부에 선언된 `var4`,`var5`는 함수 내부의 스코프에 속하게 되고, var는 함수 스코프를 가지므로 함수 외부에서 접근 불가❌

### **스코프 체인**

Javascript는 스코프 체인을 통해 변수를 찾기에 다음 순서로 진행된다.

1. 전역 스코프에서 변수를 찾는다.
2. (변수를 찾지 못할 시) 해당 변수를 선언한 함수의 스코프에서 찾고, 그 상위 함수로 계속해서 탐색한다.

위 예제에서는 `var4`, `var5`가 함수 내부에만 존재하여 외부에서 접근 할 수 없다.

### **식별자 결정**

```jsx
var x = "global";

function foo() {
  var x = "local";
  console.log(x); // 1. local
}

foo();

console.log(x); // 2. global
```

![13-2.png](/13스코프-18함수&일급객체/image/김혜수/13-2.png)

: 동일한 변수가 여러개일 경우 어떤 x를 참조해야할 지를 결정하는 과정

자바스크립트 엔진이 결정 시 사용하는 규칙 ➡️ **스코프**

<aside>
💬

### **코드의 문맥과 환경**

`렉시컬 환경(lexical environment)` : 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 뜻한다.

(즉, 코드의 문맥은 렉시컬 환경으로 이뤄진다.)

이를 구현한 것이 `실행 컨텍스트(execution context)`이며, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 스코프는 실행컨텍스트와 깊은 관련이 있다.

</aside>

- 위 예제에서 코드의 가장 바깥 영역에 선언된 x 변수는 어디서든 참조할 수 있다.
- 하지만 `foo` 함수 내부에서 선언된 `x` 변수는 `foo` 함수 내부에서만 참조할 수 있고 `foo` 함수 외부에서는 참조할 수 없다.
- 이때 두 개의 `x` 변수는 식별자 이름이 동일하지만 자신이 유효한 범위, **즉 스코프가 다른 별개의 변수다.**

## **13.2 스코프 종류**

코드는 전역(global)과 지역(local)으로 구분할 수 있다.

| 변수      | 설명                                     | 유효 범위                |
| --------- | ---------------------------------------- | ------------------------ |
| 전역 변수 | 코드의 가장 바깥 영역에서 선언된 변수    | 프로그램 전체            |
| 지역 변수 | 함수 또는 코드 블록 내부에서 선언된 변수 | 함수 또는 코드 블록 내부 |

![image.png](/13스코프-18함수&일급객체/image/김혜수/image.png)

- 이때 변수는 자신이 선언된 위치(전역 또는 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다.
- 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 `전역 변수`이고, 지역에서 선언된 변수는 지역 스코프를 갖는 `지역 변수`이다.

## **13.3 스코프 체인**

![image.png](/13스코프-18함수&일급객체/image/김혜수/0043c4fd-93be-4e9b-abee-b68b7ceab4d8.png)

함수는 중첩될 수 있으므로 지역 스코프도 중첩될 수 있다.

→ **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.**

- 모든 스코프는 하나의 계층적 구조로 연결되며, **모든 지역 스코프의 최상위 스코프는 전역 스코프다.**
- 스코프가 계층적 연결된 것을 **스코프 체인** 이라 한다.
- **변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색 한다.**

### **13.3.1 스코프 체인에 의한 변수**

```jsx
var x = "global x";

function outer() {
  var z = "outer's local z";

  console.log(z);
}

outer();

console.log(x); // global x
// console.log(z); -> ReferenceError
```

- 상위 스코프 유효한 변수 → 하위 스코프 자유롭게 참조 가능
- 하위 스코프에서 유효한 변수 → 상위 스코프에서 참조 불가

✚ 함수도 식별자에 할당되기 때문에 스코프를 갖는다.

## **13.4 함수 레벨 스코프**

대부분의 프로그래밍 언어(C나 Java)는 함수 몸체 만이 아니라 모든 코드 블록(if , for, while, try/catch 등)이 지역 스코프를 만든다. 이러한 특성을 `블록 레벨 스코프`라 한다.

**하지만 JS의 `var` 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.**

**→ `함수 레벨 스코프`라 한다.**

```jsx
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
  // 따라서 x는 지역 변수다. 이미 선언된 전역 변수 x가 있으므로 x변수는 중복 선언된다.
  var x = 10;
}

console.log(x); // 10
```

`var` 키워드를 사용할 경우 의도치 않은 전역 변수의 값이 재할당 될 수 있다.

```jsx
var i = 10;

for (var i = 0; i < 5; i++) {
  // 함수가 아니므로 i가 0으로 재할당. . .
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

## **13.5 렉시컬 스코프**

아래 코드를 이해하기 위해서는 상위 스코프 결정방식에 대해 알아야 한다.

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

### **상위 스코프 결정 방식**

| 결정 방식                   | 기준                          | EX (함수 `bar` 의 상위 스코프?) |
| --------------------------- | ----------------------------- | ------------------------------- |
| 동적 스코프                 | 함수를 어디서 **호출**했는가? | 함수 `foo` 와 전역              |
| 정적 스코프 / 렉시컬 스코프 | 함수를 어디서 **정의**했는가? | 전역                            |

대부분의 언어 그리고 Javascript는 `정적 스코프/렉시컬 스코프`를 따른다.
즉, 모든 함수 정의는 평가되어 함수 객체를 생성할 떄, 자신이 정의된 스코프를 상위 스코프로서 기억한다.
**→ 상위 스코프 결정에 영향 X**

1. 함수 선언문으로 정의된 `bar` 함수는 전역 코드가 실행되기 전에 먼저 평가되어 함수 객체를 생성
2. 이때 생성된 `bar` 함수 객체는 자신이 정의된 스코프, 즉 전역 스코프를 기억
3. bar 함수가 호출되면 호출된 곳이 어디인지 관계없이 언제나 자신이 기억하고 있는 전역 스코프를 상위 스코프로 사용한다. → **전역 변수 x의 값 1을 두 번 출력한다.**

# **14장 전역 변수의 문제점**

---

### 14.1.1 지역 변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 가지며, 생성되고 소멸되는 `생명 주기`가 있다.

**전역 변수 생명주기** : 애플리케이션 생명 주기와 일치

**지역 변수 생명 주기** : 함수 호출 시 생성, 함수 종료 시 소멸 → 함수의 생명주기와 일치 !

![image.png](/13스코프-18함수&일급객체/image/김혜수/image%201.png)

**(ex) foo() 호출 시 함수 몸체 순차적 실행 전 x변수의 선언문이 가장 먼저 실행**

1. x 변수 선언
2. undefined로 초기화
3. 함수 몸체를 구성하는 문들 순차적 실행 후 변수 할당문 실행시 x 변수에 값 할당

> 일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸한다.
> 하지만 **누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존**하게 된다. → **클로저**

```jsx
var x = "global";

function foo() {
  console.log(x); // 1
  var x = "local";
}

foo();
console.log(x);

// undefined
// global
```

foo 함수 내부에서 선언된 지역 변수 x는 `1` 시점에 이미 선언되었고 `undefined`로 초기화되어 있다.

→ 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조해 값을 출력한다.

→ 지역 변수는 함수 전체에서 유효하다.

단, 변수 할당문이 실행되기 이전까지는 `undefined` 값을 갖는다.

**호이스팅은 스코프를 단위로 동작한다. → 전역은 전역 전체 유효 / 지역 변수는 함수 전체 유효**

**호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.**

### 14.1.2 전역 변수의 생명주기

<aside>
💬

함수와 달리 전역 코드는 명시적인 호출 없이 실행된다.

</aside>

- 전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
  (=전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치)
- **var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.**

## 14.2 전역 변수의 문제점

### **1. 암묵적 결합**

: 전역 변수를 선언한 의도는 전역, 즉 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다.

→ 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합**

변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

### **2. 긴 생명 주기**

**전역 변수는 생명 주기가 길다.** 따라서 메모리 리소스도 오랜 기간 소비한다.

더욱이 var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다. 변수 이름이 중복되면 의도치 않은 재할당이 이뤄진다.

```jsx
var x = 1;
//...

// 변수의 중복 선언. 기존 변수에 값을 재할당한다.
var x = 100;
console.log(x); // 100
```

### **3. 스코프 체인 상에서 종점에 존재**

전역 변수는 스코프 체인 상에서 종점에 존재한다. → **전역 변수의 검색 속도가 가장 느리다.**

### **4. 네임스페이스 오염**

자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다.

→ 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 의도치 않은 결과가 발생할 수 있다.

# **14.3 전역 변수의 사용을 억제하는 방법**

**전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 하고, 변수의 스코프는 좁을수록 좋다.**

## **14.3.1 즉시 실행 함수**

**모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.**

이러한 특성을 이용해 전역 변수의 사용을 제한한다.

```jsx
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  //...
})();

console.log(foo); // ReferenceError
```

전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.

## **14.3.2 네임스페이스 객체**

전역에 네임스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

```jsx
var MYAPP = {};

MYAPP.name = "Son";

console.log(MYAPP.name); // Son
```

→ `namespace` 객체에 또 다른 네임스페이스 객체를 `프로퍼티`로 추가해서 `namespace`를 계층적으로 구성가능

```jsx
var MYAPP = {};

MYAPP.person = {
  name: "Son",
  address: "Seoul",
};

console.log(MYAPP.person.name); // Son
```

→ `namespace`를 분리해서 식별자 충돌을 방지하는 효과는 있으나 `namespace` 객체 자체가 전역 변수에 할당되므로 비추…

## **14.3.3 모듈 패턴**

<aside>
💬

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.

</aside>

- 모듈 패턴은 클로저를 기반으로 동작한다.
  모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다.

> **캡슐화**는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
> 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 **정보 은닉**이라 한다.

- 자바스크립트는 `public`, `private`, `protected` 등의 접근 제어자를 제공하지 않는다.
- 모듈 패턴은 전역 네임스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용한다.

```jsx
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

## **14.3.4 ES6 모듈**

- ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다.
- **ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.**

# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

```jsx
var x = 1;
var y = 1;

// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
var x = 100;
// 초기화문이 없는 변수 선언문은 무시된다.
var y;

console.log(x); // 100
console.log(y); // 1
```

변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생한다.

### 15.1.2 함수 레벨 스코프

`var` 키워드는 함수 스코프를 가지기 때문에, 블록 내부에서 선언하더라도 전역 변수 `x`와 같은 스코프를 공유한다. 따라서 `if` 블록 안에서 `var x = 10;`을 선언하면, 이미 전역에서 선언된 `x = 1;`의 값을 덮어쓰게 됩니다.

```jsx
var x = 1;

if (true) {
  // x는 전역 변수이며 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
  // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

```jsx
var i = 10;

// for문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 i 변수의 값이 변경되었다.
console.log(i); // 5
```

### 15.1.3 변수 호이스팅

`var` 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 `var` 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.

단, 할당문 이전에 변수를 참조하면 언제나 `undefined`를 반환한다.

```jsx
// 이 시점에는 변수 호이스팅에 의해 이미 foo 변수가 선언되었다.(1. 선언단계)
// 변수 foo는 undeinfed로 초기화된다(2. 초기화 단계)
console.log(foo); // undefined

// 변수에 값을 할당(3. 할당 단계)
foo = 123;

console.log(foo); // 123

// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.
var foo;
```

## 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

`let` 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생한다.

```jsx
var foo = 123;
// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
var foo = 456;

let bar = 123;
// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
let bar = 456; // SyntaxError
```

### **15.2.2 블록 레벨 스코프**

`let` 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```jsx
let foo = 1; // 전역 변수
{
  let foo = 2; // 지역 변수
  let bar = 3; // 지역 변수
}

console.log(foo); // 1
console.log(bar); // ReferenceError
```

### **15.2.3 변수 호이스팅**

자바스크립트는 ES6에서 도입된 `let`, `const`를 포함하여 모든 선언(var, let, const, function, [function\*](https://poiemaweb.com/es6-generateor), class)을 **호이스팅**한다.

<aside>
💬

**호이스팅(Hoisting)**이란, `var` 선언문이나 `function` 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다.

</aside>

```jsx
console.log(foo); // undefined
var foo;

console.log(bar); // Error: Uncaught ReferenceError: bar is not defined
let bar;
```

하지만 var 키워드로 선언된 변수와는 달리 let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.

### 🤔 왜일까 ? 이유는 다음과 같다.

이는 let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 **일시적 사각지대(Temporal Dead Zone; TDZ)**에 빠지기 때문이다.

- **var & let & const 변수 선언과 초기화 차이**
  | **특징** | **`var`** | **`let` / `const`** |
  | ------------------------ | ---------------------------- | --------------------------------- |
  | **스코프** | 함수 스코프 | 블록 스코프 |
  | **호이스팅** | 선언과 동시에 초기화됨 | 선언만 호이스팅됨 (TDZ 적용) |
  | **초기값** | 선언 시 `undefined`로 초기화 | 초기화되기 전까지 참조 불가 (TDZ) |
  | **초기화 시점** | 선언과 동시에 초기화 | 선언문에 도달했을 때 초기화 |
  | **초기화 전에 접근** | `undefined` 반환 | `ReferenceError` 발생 |
  | **일시적 사각지대(TDZ)** | 적용되지 않음 | 적용됨 |
  ###

1. **선언 단계**: 자바스크립트는 `foo` 변수가 존재한다는 것을 인식한다. 즉, 변수가 **호이스팅**되어 선언되었지만, 초기화되기 전이다.
2. **초기화 단계**: `let foo = 10;`에 도달하면 변수 `foo`는 값 `10`으로 초기화된다. 그 이후로 `foo`를 정상적으로 사용할 수 있다.
3. 그러나 **선언 후 초기화가 되기 전(TDZ)**에 해당 변수를 접근하려고 하면 **참조 에러**가 발생한다. 따라서, `console.log(foo)`에서 `ReferenceError`가 발생한 것이다.

```jsx
// 스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.
// 따라서 변수 선언문 이전에 변수를 참조할 수 있다.
console.log(foo); // undefined

var foo;
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

![var 키워드로 선언된 변수의 생명주기](/13스코프-18함수&일급객체/image/김혜수/image%202.png)

var 키워드로 선언된 변수의 생명주기

<aside>
💬

**var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.** 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, `undefined`로 초기화(초기화 단계)한다.

따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 `undefined`를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다. 이러한 현상을 [변수 호이스팅(Variable Hoisting)](https://poiemaweb.com/js-data-type-variable#24-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)이라 한다.

</aside>

![let 키워드로 선언된 변수의 생명주기](/13스코프-18함수&일급객체/image/김혜수/image%203.png)

let 키워드로 선언된 변수의 생명주기

```jsx
// 런타임 이전에 선언 단계가 실행된다. 아직 변수가 초기화되지 않았다.
// 초기화 이전에 일시적 사각지대에서는 변수를 참조할 수 없다.
console.log(foo); // ReferenceError

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 10; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 10
```

<aside>
💬

**let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.**

즉, 스코프에 변수를 등록(선언단계)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다. 초기화 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다.

이는 변수가 아직 초기화되지 않았기 때문이다. 다시 말하면 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다.

스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 **‘일시적 사각지대(Temporal Dead Zone; TDZ)’**라고 부른다.

</aside>

- **TDZ(일시적 사각지대)**
  `TDZ`는 변수 선언문에 도달하기 전까지 변수를 사용할 수 없게 하는 영역을 뜻한다. 이 영역에서는 변수가 선언되어 있지만, 아직 초기화되지 않았기 때문에 접근할 수 없다.
  따라서, **초기화 단계 전에 변수를 접근하려고 하면 참조 에러가 발생**하는 이유는, 변수가 선언만 되어 있고 아직 사용할 준비가 되어 있지 않기 때문이다.
  → `let`과 `const`는 이 방식으로 변수 사용의 안전성을 높이는 것이다.

### **15.2.4 전역 객체와 let**

```jsx
// 이 예제는 브라우저 환경에서 실행해야 한다.

// 전역 변수
var x = 1;
// 암묵적 전역
y = 2;
// 전역 함수
function foo() {}

// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다.
console.log(window.x); // 1
// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다.
console.log(x); // 1

// 암묵적 전역은 전역 객체 window의 프로퍼티다.
console.log(window.y); // 2
console.log(y); // 2

// 함수 선언문으로 정의한 전역 함수는 전역 객체 window의 프로퍼티다.
console.log(window.foo); // foo() {}
// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다.
console.log(foo); // foo() {}
```

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

→ `window.foo` 와 같이 접근할 수 없다.

```jsx
// 이 예제는 브라우저 환경에서 실행해야 한다.
let x = 1;

// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.
console.log(window.x); // undefined
console.log(x); // 1
```

## **15.3. const 키워드**

`const` 키워드는 상수를 선언하기 위해 사용한다.

그러나 반드시 상수만을 위해 사용하지는 않는다.

### **15.3.1 선언과 초기화**

**`const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.**

```jsx
const foo = 1;
// 초기화 하지 않으면 문법 에러가 발생한다.
const bar; // SyntaxError
```

`const` 키워드로 선언한 변수는 블록 레벨 스코프{}를 가지며, 변수 호이스팅이 발생하지 않는다.

### **15.3.2 재할당 금지**

**const 키워드로 선언한 변수는 재할당이 금지된다.**

```jsx
const foo = 1;
foo = 2; // TypeError
```

### **15.3.3 상수**

`const` 키워드로 선언한 변수는 원시 값을 할당한 경우 변수 값을 변경할 수 없다.

```jsx
// 세전 가격
let preTaxPrice = 100;

// 세후 가격
// 0.1의 의미를 명확히 알기 어렵기 때문에 가독성이 좋지 않다.
let afterTaxPrice = preTaxPrice + preTaxPrice * 0.1;

console.log(afterTaxPrice); // 110
```

**`const` 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 `const` 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.**

일반적으로 상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다.

```jsx
// 세율을 의미하는 0.1은 변경할 수 없는 상수로서 사용될 값이다.
// 변수 이름을 대문자로 선언해 상수임을 명확히 나타낸다.
const TAX_RATE = 0.1;

// 세전 가격
let preTaxPrice = 100;

// 세후 가격
// 0.1의 의미를 명확히 알기 어렵기 때문에 가독성이 좋지 않다.
let afterTaxPrice = preTaxPrice + preTaxPrice * TAX_RATE;

console.log(afterTaxPrice); // 110
```

### **15.3.4 const 키워드와 객체**

`const` 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없다.

그러나, **`const` 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.**

```jsx
const person = {
  name: "Son",
};

// 객체는 변경 가능한 값이다. 따라서 재할당 없이 변경이 가능하다.
person.name = "Sunny";

console.log(person); // { name: 'Sunny' }
```

**const 키워드는 재할당을 금지할 뿐 불변을 의미하지 않는다.**

프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능하다.

# **15.4 var vs let vs const**

- ES6를 사용한다면 `var` 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 `let` 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 `const` 키워드를 사용한다.

# 16장 프로퍼티 어트리뷰트

## [16.1 내부 슬롯과 내부 메서드](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) → 용어 이해

<aside>
💬

ECMAScript 사양에 등장하는 이중 대괄호(`[[…]]`) 로 감싼 이름들이 **내부 슬롯**과 **내부 메서드**다.

</aside>

내부 슬롯과 내부 메서드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다.

**→ 원칙적으로 자바스크립트는 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다.**

```jsx
const o = {};

// 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.
o.[[Prototype]]; // Uncaught SyntaxError
// 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공한다.
o.__proto__; // Object.prototype (접근 가능한 방법이지만 지원 중단!!!!)
```

## **16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체**

**자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본적으로 자동 정의한다.**

프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값인 **내부 슬롯**이므로 직접 접근할 수 없지만, `Object.getOwnPropertyDescritor` 메소드를 사용해서 **간접적으로 확인**할 수 있다.

```jsx
// 객체 리터럴로 객체 생성 , 식별자 person
const person = {
  name: "Son",
};

// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.
console.log(Object.getOwnPropertyDescriptor(person, "name"));

// 프로퍼티의 값 / 값의 갱신 가능 여부 / 열거 가능 여부 / 재정의 가능 여부 = 프로퍼티 상태
// { value: 'Son', writable: true, enumerable: true, configurable: true } ->
```

- `Object.getOwnPropertyDescriptor()` 호출할 때 첫 번째 매개변수에는 **객체의 참조**를 전달하고, 두 번째 매개변수에는 **프로퍼티 키를 문자열로 전달**한다.
- `Object.getOwnPropertyDescriptor()` 프로퍼티 어트리뷰트 정보를 제공하는 **프로퍼티 디스크립터 객체**를 반환한다. 만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티라면 undefined를 반환된다.

```jsx
const person = {
  name: "Kim",
};

// 프로퍼티 동적 생성
person.age = 25;

// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.
console.log(Object.getOwnPropertyDescriptor(person));

/* {
	name: { value: 'Kim', writable: true, enumerable: true, configurable: true },
	age: { value: '25', writable: true, enumerable: true, configurable: true }
}
*/
```

<aside>
💬

`getOwnPropertyDescriptor()` 메소드는 하나의 프로퍼티에 대해 **프로퍼티 디스크립터(PropertyDescriptor)**라는 객체를 반환하는데, 그 객체는 **프로퍼티 어트리뷰트** 정보를 담고있다.

`getOwnPropertyDescriptors()` 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들 반환 !

</aside>

## **16.3 데이터 프로퍼티와 접근자 프로퍼티**

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티. (위 예시)
- 접근자 프로퍼티: 자체적으로 값을 갖지 않고 **다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티.**

### **16.3.1 데이터 프로퍼티**

데이터 프로퍼티는 **값을 직접 저장하고 참조하는 일반적인 방식**이며 네가지 어트리뷰트를 갖는데, 이는 프로퍼티 생성 시 기본 값으로 자동 정의된다.

| 프로퍼티 어트리뷰트                                                                                                                                                                       | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------- | ----------------------------------------------------------------- |
| [[Value]]                                                                                                                                                                                 | value                               | - **프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값**이다.       |
| - 프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.                                 |
| [[Writable]]                                                                                                                                                                              | writable                            | - **프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값**을 갖는다. |
| - [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.                                                                            |
| [[Enumerable]]                                                                                                                                                                            | enumerable                          | - 프로퍼티의 **열거 가능 여부를 나타내며 불리언 값**을 갖는다.    |
| - [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for..in문이나 Object.keys 메소드 등으로 열거할 수 없다.                                                                             |
| [[Configurable]]                                                                                                                                                                          | configurable                        | - 프로퍼티의 **재정의 가능 여부를 나타내며 불리언 값**을 갖는다.  |
| - [[Configurable]]의 값이 false인 경우, 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. |

```jsx
const person = {
  // 데이터 프로퍼티
  firstName: "Sunny", // 데이터 프로퍼티
  lastName: "Son", // 데이터 프로퍼티
};

// 1. 데이터 프로퍼티를 통한 프로퍼티 값의 참조
console.log(person.firstName + " " + person.lastName); // Sunny Son

// firstName는 데이터 프로퍼티이다.
// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
let descriptor = Object.getOwnPropertyDescriptor(person, "firstName");
console.log(descriptor);
//   { value: 'Sunny', writable: true, enumerable: true, configurable: true }
```

### **16.3.2 접근자 프로퍼티**

접근자 프로퍼티(Accessor Property)는 자체적으로는 값을 갖지 않고 `getter/setter` 함수를 통해다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 **접근자 함수**로 구성된 프로퍼티이다.

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                                |
| ------------------- | ----------------------------------- | ----------------------------------------------------------------------------------- |
| [[Get]]             | get                                 | **접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 사용되는 접근자 함수이다.** |

즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 `getter`함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.
**→ 값을 가지고 있지않고 조작 Only** |
| [[Set]] | set | **접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다.**
즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 `setter`함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다. |
| [[Enumerable]] | enumerable | 데이터 프로퍼티와 동일 |
| [[Configurable]] | configurable | 데이터 프로퍼티와 동일 |

→ 접근자 함수는 `getter/setter` 함수라고도 부른다.

```jsx
const person = {
  // 접근자 프로퍼티
  get fullName() {
    // getter
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(name) {
    // setter
    [this.firstName, this.lastName] = name.split(" ");
  },
};

// 2. 접근자 프로퍼티를 통한 프로퍼티 값 저장 및 참조
// 2-1.접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
person.fullName = "Cloud Kim";
console.log(person); // { firstName: "Cloud", lastName: "Kim" }

// 2-2. 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(person.fullName); // Cloud Kim

// fullName는 접근자 프로퍼티이다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
let descriptor = Object.getOwnPropertyDescriptor(person, "fullName");
console.log(descriptor);
//   { get: [Function: get fullName], set: [Function: set fullName], enumerable: true, configurable: true }
```

### **+ 프로토타입**

: **어떤 객체의 상위 객체의 역할을 하는 객체**
프로토타입 객체의 프로퍼티나 메서드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메서드인 것처럼 자유롭게 사용할 수 있다.

접근자 프로퍼티와 데이터 프로퍼티를 구별하는 방법은 다음과 같다.

```jsx
// 일반 객체의 __proto__는 접근자 프로퍼티다.
Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

// 함수 객체의 prototype은 데이터 프로퍼티다.
Object.getOwnPropertyDescriptor(function () {}, "prototype");
```

## **16.4 프로퍼티 정의**

1. 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하는 것
2. 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것

**(즉, 프로퍼티 값이 `enumerable`하도록 할건지 `writable`하도록 할 건지 등을 정의..~)**

**정의 방법**

`Object.definedProperty` 메소드를 사용하여 프로퍼티 어트리뷰트를 정의한다.
인수는 객체의 참조와 데이터 프로퍼티의 키인 **문자열** 그리고 **프로퍼티 디스크립터 객체**를 전달한다.

**프로퍼티 정의 차이점
(`JS 엔진` VS `defineProperty`)**

- JS가 자동으로 프로퍼티 정의할 때엔 `true`로 자동 정의된다.
- `definedProperty` 을 통해 프로퍼티를 정의할 때에는 명시하지 않은 것은 모두 `false` 로 정의된다.

```jsx
const person = {};

// 데이터 프로퍼티 정의
Object.defineProperty(person, "firstName", {
  value: "Sunny",
  writable: true,
  enumerable: true,
  configurable: true,
});

Object.defineProperty(person, "lastName", {
  value: "Son", // 지정 안할 경우 나머지 모두 false
});

let descriptor = Object.getOwnPropertyDescriptor(person, "firstName");
console.log("firstName", descriptor);
// firstName {
//     value: 'Sunny',
//     writable: true,
//     enumerable: true,
//     configurable: true
//   }

// 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.
descriptor = Object.getOwnPropertyDescriptor(person, "lastName");
console.log("lastName", descriptor);
// lastName {
//     value: 'Son',
//     writable: false,
//     enumerable: false,
//     configurable: false
//   }

// lastName 프로퍼티는 [[Writable]] 의 값이 false 이므로 변경 할 수 없다.
person.lastName = "Kim";

// lastName 프로퍼티는 [[Enumerable]] 값이 false이므로 열거되지 않음
console.log(Object.keys(person)); // ["firstName"]

// lastName 프로퍼티는 [[Configurable]] 값이 false이므로 삭제하거나 재정의할 수 없다.
delete person.lastName;
Object.defineProperty(person, "lastName", { enumerable: true }); // SyntaxError

// 접근자 프로퍼티 정의
Object.defineProperty(person, "fullName", {
  get() {
    return `${this.firstName} ${this.lastName}`;
  },
  set(name) {
    [this.firstName, this.lastName] = name.split(" ");
  },
  enumerable: true,
  configurable: true,
});
```

`Object.defineProperties()` 사용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.

## **16.5 객체 변경 방지**

자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다. 객체 변경 방지 메서드들은 객체의 변경을 금지하는 정도가 다르다.

| 구분 | 메소드 | 프로퍼티
추가 | 프로퍼티
삭제 | 프로퍼티
값 읽기 | 프로퍼티
값 쓰기 | 프로퍼티 어트리 뷰트 재정의 |
| --- | --- | --- | --- | --- | --- | --- |
| 객체 확장 금지 | Object.preventExtension | X | O | O | O | O |
| 객체 밀봉 | Object.seal | X | X | O | O | X |
| 객체 동결 | Object.freeze | X | X | O | X | X |

### **16.5.1 객체 확장 금지**

`Object.preventExtensions()` 객체의 확장을 금지하고, 객체 확장 금지란 프로퍼티 추가 금지를 의미한다.

<aside>
💬

**즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다 !**

</aside>

### **프로퍼티 추가방법**

1. **프로퍼티 동적 추가**
2. `Object.definedProperty` 메소드로 추가

### 확장 금지 여부 확인 방법

`Object.isExtensible` 메소드로 확인

```jsx
const person = {
  name: "Sunny",
};

// 확장이 금지되지 않음
console.log(Object.isExtensible(person)); // true

// person 객체 확장 금지
Object.preventExtensions(person);
// person 객체는 확장이 금지됨
console.log(Object.isExtensible(person)); // false

// 프로퍼티 추가가 되지 않음
person.age = 20; // 무시 But strict mode에서는 제외
console.log(person); // {name: "Sunny"}

// 프로퍼티 삭제는 가능
delete person.name;
console.log(person); // {}

// 프로퍼티 정의에 의한 프로퍼티 추가도 금지
Object.defineProperty(person, "age", { value: 20 }); // TypeError
```

## **16.5.2 객체 밀봉**

`Object.seal()` 객체를 밀봉한다.

**밀봉된 객체는 읽기와 쓰기만 가능하다.**

```jsx
const person = {
  name: "Sunny",
};

// 밀봉되지 않음
console.log(Object.isSealed(person)); // false

// 밀봉
Object.seal(person);

// 프로퍼티 추가가 되지 않음
person.age = 20;
console.log(person); // {name: "Sunny"}

// 프로퍼티 삭제 금지
delete person.name;
console.log(person); // {name: "Sunny"}

// 프로퍼티 값 갱신은 가능
person.name = "Kim";
console.log(person); // {name: "Kim"}

// 프로퍼티 어트리뷰트 재정의가 금지
Object.defineProperty(person, "name", { configurable: true }); // TypeError
```

## **16.5.3 객체 동결**

`Object.freeze()` 객체를 동결한다.

**동결된 객체는 읽기만 가능하다.**

```jsx
const person = {
  name: "Sunny",
};

// 동결되지 않음
console.log(Object.isFrozen(person)); // false

// 동결
Object.freeze(person);

// 프로퍼티 추가가 되지 않음
person.age = 20;
console.log(person); // {name: "Sunny"}

// 프로퍼티 삭제 금지
delete person.name;
console.log(person); // {name: "Sunny"}

// 프로퍼티 값 갱신 금지
person.name = "Kim";
console.log(person); // {name: "Sunny"}

// 프로퍼티 어트리뷰트 재정의가 금지
Object.defineProperty(person, "name", { configurable: true }); // TypeError
```

### **16.5.4 불변 객체**

위 메서드들은 얕은 변경 방지(shallow only)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못한다. → `Object.freeze` 로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.

```jsx
const person = {
  name: "Sunny",
  address: { city: "Seoul" }, // 중첩 객체인 city에서는 변경 방지 메서드 작동 X
};

// 얕은 동결
Object.freeze(person);

// 중첩 객체까지 동결하지 못함
console.log(Object.isFrozen(person)); // true
console.log(Object.isFrozen(person.address)); // false

person.address.city = "Busan";
console.log(person); // { name: 'Sunny', address: { city: 'Busan' } }
```

객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 **재귀적으로 `Object.freeze()` 메서드를 호출**해야 한다.

```jsx
function deepFreeze(target) {
  // 객체가 아니거나 동결된 객체는 무시하고 객체이며 동결되지 않은 객체만 동결
  if (target && typeof target === "object" && !Object.isFrozen(target)) {
    Object.freeze(target); // 여기 까지하면 중첩 객체는 복사 안됨

    // 프로퍼티 키들을 배열로 반환하여 순회(name,address)하여 요소 하나씩 동결
    Object.keys(target).forEach((key) => deepFreeze(target[key]));
  }

  return target;
}

const person = {
  name: "Sunny",
  address: { city: "Seoul" },
};

// 깊은 동결
deepFreeze(person);

// 중첩 객체까지 동결하지 못함
console.log(Object.isFrozen(person)); // true
console.log(Object.isFrozen(person.address)); // true

person.address.city = "Busan";
console.log(person); // { name: 'Sunny', address: { city: 'Seoul' } }
```

# 17장 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

`new` 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.

빈 객체 생성 후 `프로퍼티` 혹은 `메소드`를 추가하여 객체를 완성할 수 있다.

```jsx
// 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = "Kim";
person.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

console.log(person);
person.sayHello;

// { name: 'Kim', sayHello: [Function (anonymous)] }
// Hi! My name is Kim
```

> 자바스크립트는 Object 생성자 함수 외에도 `string` ,`number` ,`Fuction`, `Array`, `Date`, `RegExp`, `Promise` 등의 빌트인 생성자 함수 제공하지만 Object으로 객체 생성 방식은 그닥 유용하진 않다..

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만 생성

→ 동일한 프로퍼티를 가진 객체를 여러 개 생성하는 경우 매번 같은 프로퍼티를 기술해야 한다. (=비효율적)

→ 코드 중복 발생

```jsx
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  },
};

const circle2 = {
  radius: 10,
  getDiameter() {
    return 2 * this.radius;
  },
};

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

`객체(인스턴스)`를 생성하기 위한 템플릿(클래스)처럼 **생성자 함수**를 사용하여 프로퍼티 구조가 동일한 객체(인스턴스) 여러개 를 간편하게 생성 가능.

- **생성자 함수 만들어서 인스턴스로 값만 넘겨준다.**

```jsx
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

---

<aside>
💬

`this` 는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이다.
**this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다 ! (22장 에서… 잘 ..배우기..)**

</aside>

| **함수 호출 방식**   | **this가 가르키는 값(this 바인딩)**    |
| -------------------- | -------------------------------------- |
| 일반 함수로서 호출   | 전역객체                               |
| 메서드로서 호출      | 메서드를 호출한 객체(마침표 앞의 객체) |
| 생성자 함수로서 호출 | 생성자 함수가(미래에) 생성할 인스턴스  |

```jsx
// 함수는 다양한 방식으로 호출될 수 있다.
function foo() {
  console.log(this);
}

// 일반적인 함수로서 호출
// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.
foo(); // window

// 메서드로서 호출
const obj = { foo }; // ES6 프로퍼티 축약 표현
obj.foo(); // obj

// 생성자 함수로서 호출
const inst = new foo(); // inst
```

**생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수다.**

- new 연산자 ⭕ → 생성자 함수를 호출
  - 해당 함수는 **생성자 함수로 동작.**
- new 연산자 ❌ → 생성자 함수를 호출
  - 생성자 함수가 아니라 **일반 함수로 동작.**

```jsx
function Circle(radius) {
  this.radius = radius; // this가 전역 객체를 가리킴 (브라우저에서는 window)
}
// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.
// 일반 함수로 호출됨
const circle3 = Circle(15);

// 일반 함수로서 호출된 Circle은 반환문이 없으므로 암묵적으로 undefiend
console.log(circle3); // undefined

// 일반 함수로서 호출된 Circle 내의 this는 전역 객체를 가리킨다.
console.log(radius); // 15
```

---

### 17.2.3 생성자 함수의 인스턴스 생성 과정

### **`new` 연산자와 생성자 함수의 기본 동작**

`new` 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 **암묵적으로 세 가지 단계**를 수행한다.

1. **새로운 객체를 생성 후** 새로운 객체를 `this`에 바인딩
2. 생성자 함수의 코드를 실행하여, **`this`에 바인딩된 객체에 속성을 추가**하거나 초기화한다.
3. **자동으로 `this`가 반환**됩니다. 즉, 생성된 객체가 반환

```jsx
function Circle(radius) {
  // 1. 암묵적으로 빈 객체 생성되고 this에 바인딩된다.(빈객체)

  // 2. this에 바인딩되어 있는 인스턴스를 초기화한다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };

  // 3. 암묵적으로 this를 반환한다.
  // 명시적으로 return 해버리면 이 return이 자바스크립트 기본동작을 덮어쓴다.
  return {}; // {}으로 덮어씌워져 this대신 {}만 출력 ..생략해!
}

// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.
const circle = new Circle(1);
console.log(circle); // {}
```

### **17.2.4 내부 메서드 [[Call]] 과 [[Construct]]**

함수는 객체이지만 일반 객체와는 다르다. ”**일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.”**

함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론, 함수로서 동작하기 위해 함수 객체 만을 위한 `Environment`, `FormalParameter` 등의 **내부 슬롯**과 `Call`, `Construct` 같은 **내부 메서드**를 추가로 가지고 있다.

```jsx
// 함수는 객체다.
function foo() {}

// 함수는 객체이므로 프로퍼티를 소유할 수 있다.
foo.prop = 10;

// 함수는 객체이므로 메서드를 소유할 수 있다.
foo.method = function () {
  console.log(this.prop);
};

foo.method(); // 10
```

- 함수가 **일반 함수로서 호출**되면 함수 객체의 내부 메서드 `[[Call]]`이 호출
- `new 연산자`와 함께 **생성자 함수로서 호출**되면 내부 메서드 `[[Construct]]`가 호출

```jsx
function foo() {}

// 일반적인 함수로서 호출: Call 호출 - 새로운 객체 생성 X
foo();

// 생성자 함수로서 호출: Construct 호출 - 새로운 객체 생성 O
new foo();
```

![모든 함수 객체는 callable이지만 모든 함수 객체가 constructor인 것은 아니다.](/13스코프-18함수&일급객체/image/김혜수/image%204.png)

모든 함수 객체는 callable이지만 모든 함수 객체가 constructor인 것은 아니다.

- 내부 메서드 `[[Call]]` 을 갖는 함수 객체 - `callable` (호출할 수 있는 객체 = 함수)
- 내부 메서드 `[[Construct]]` 를 갖는 함수 객체 - `constructor` (생성자 함수로서 호출할 수 있는 함수)
- Construct 를 갖지 않은 함수 객체 - `non-constructor` (생성자 함수로서 호출할 수 없는 함수)
  → **축약 표현 메소드 & 화살표 함수**

### **17.2.5 constructor와 non-constructor의 구분**

자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 `constructor`와 `non-constructor`로 구분한다.

<aside>
💬

`constructor`: 함수 선언문, 함수 표현식, 클래스(클래스도 함수)

`non-constructor`: 메서드, 화살표 함수

</aside>

```jsx
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않음
const baz = {
  x: function () {},
};

// 일반 함수로 정의된 함수만이 constructor.
new foo(); // foo {}
new bar(); // bar {}
new bar.x(); // x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow(); // TypeError

// 메서드 정의: ES6 의 메서드 축약 표현만 메서드로 인정
const obj = {
  x() {},
};

new obj.x(); // TypeError:
```

> 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(`callble` / `constructor`)에 `new` 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다.

### **17.2.6 new 연산자**

`new` 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다.

```jsx
// 생성자 함수로서 정의하지 않은 일반 함수
function add(x, y) {
  return x + y;
}

// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출
let inst = new add();

// 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. -> 빈 객체가 생성
console.log(inst); // {}

// 명시적으로 객체를 반환하는 일반 함수
function createUser(name, role) {
  return { name, role };
}

// 일반 함수를 new 연산자와 함께 호출
inst = new createUser("Son", "admin");
// 함수가 생성된 객체 반환
console.log(inst); // { name: 'Son', role: 'admin' }
```

반대로 `new` 연산자 없이 생성자 함수를 호출하면 `일반 함수`로 호출된다.

```jsx
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  }; // return 문이 없기에 일반 함수로서 반환값 undefined
}
// new 연산자 없이 생성자 함수 호출 -> 일반 함수로서 호출
const circle = Circle(5);

console.log(circle); // undefined

// 일반 함수 내부의 this는 전역 객체 window를 가리킨다.
console.log(radius); // 5
console.log(getDiameter()); // 10

circle.getDiameter();
// TypeError: Cannot read property 'getDiameter' of undefined
```

- 위 예제의 Circle 함수는 일반 함수로서 호출되었기 때문에 Circle 함수 내부의 `this`는 전역 객체 `window`를 가리킨다. → `radius 프로퍼티`, `getDiameter 메서드`는 **전역 객체의 프로퍼티와 메서드**가 된다.
- Circle 함수에 대한 return 값이 없기에 `circle` 은 `undefined` 을 출력한다.
  따라서 `circle.getDiameter`를 호출하려고 하면, `undefined`에서 `getDiameter` 프로퍼티를 찾으려고 하기 때문에 `TypeError`가 발생한다.

### **17.2.7 `new.target`**

### **`new.target`이란?**

`new.target`은 함수 또는 생성자 함수가 **`new` 키워드**로 호출되었는지 확인하는 방법이다.
( 자바스크립트에서 `new.target`은 **메타 프로퍼티**로, 함수 내부에서만 사용할 수 있는 **특별한 변수인 것)**

<aside>
💬

- **`new` 키워드로 호출된 경우: 함수 내부의 `new.target` 은 함수 자신을 가리킨다.**
- **`new` 없이 호출된 경우: 함수 내부의 `new.target` 은 undefined다.**
</aside>

```jsx
// 생성자 함수
function Circle(radius) {
  // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.
  if (!new.target) {
    // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.
    return new Circle(radius);
  }
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.
const circle = Circle(5);
console.log(circle.getDiameter()); // 10
```

참고로 대부분의 **빌트인 생성자 함수**는 `new` 연산자와 함께 호출 되었는지를 확인한 후 적절한 값을 반환한다.

```jsx
let obj = new Object();
console.log(obj); // {}

obj = Object();
console.log(obj); // {}

let f = new Function("x", "return x ** x");
console.log(f); // [Function: anonymous]

f = Function("x", "return x ** x");
console.log(f); // [Function: anonymous]
```

하지만 `String`, `Number`, `Boolean` 생성자 함수는 `new` 연산자와 함께 호출 했을 때 객체를 생성하여 반환하지만 **new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다.**

```jsx
const str = String(123);
console.log(str, typeof str); // 123 string

const num = Number("123");
console.log(num, typeof num); // 123 number

const bool = Boolean(1);
console.log(bool, typeof bool); // true boolean
```

# 18장 함수와 일급 객체

## **18.1 일급 객체**

**다음의 조건을 만족하는 객체를 일급 객체라 한다.**

1. 무명의 리터럴로 생성할 수 있다. **즉, 런타임에 생성이 가능하다.**
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용될 수 있다.

```jsx
// 1. 함수는 무명의 리터럴로 생성할 수 있다.
// 2. 함수는 변수에 저장할 수 있다.
// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.
const increase = function (num) {
  return ++num;
};

const decrease = function (num) {
  return --num;
};

// 2. 함수는 객체에 저장할 수 있다.
const predicates = { increase, decrease };

// 3. 함수의 매개변수에 전달할 수 있다.
// 4. 함수의 반환값으로 사용할 수 있다.
function makeCounter(predicate) {
  let num = 0;

  return function () {
    num = predicate(num);
    return num;
  };
}

// 3. 함수는 매개변수에게 함수를 전달할 수 있다.
const increaser = makeCounter(predicates.increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

const decreaser = makeCounter(predicates.decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

### 일급 객체로서 함수가 가지는 특징

1.  일반 객체와 같이 함수의 매개변수에 전달할 수 있으며, 함수의 반환값으로 사용할 수도 있다는 것이다.

    → 함수형 프로그래밍을 가능하게 해주는 자바스크립트의 장점 중 하나 !

2.  함수는 객체이지만 일반 객체와는 차이가 있다. **일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다.**
3.  함수 객체는 일반 객체에는 없는 **함수 고유의 프로퍼티를 소유**한다.

## 18.**2. 함수 객체의 프로퍼티**

```jsx
function square(number) {
  return number * number;
}

console.log(Object.getOwnPropertyDescriptors(square));
```

`arguments`, `caller`, `length`, `name`, `prototype` 프로퍼티는 모두 함수 객체의 데이터 프로퍼티다.

이들 프로퍼티는 일반 객체에는 없는 함수 객체 고유의 프로퍼티다.

### **18.2.1 arguments 프로퍼티**

`arguments` 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다. → 함수 외부에서는 참조할 수 없다.

<aside>
💬

자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.

→ 함수 호출 시 매개변수 개수만큼 인수를 전달하지 않아도 에러가 발생하지 않는다.

</aside>

```jsx
function multiply(x, y) {
  console.log(arguments);
  return x * y;
}

console.log(multiply()); // NaN
console.log(multiply(1)); // NaN
console.log(multiply(1, 2)); // 2
console.log(multiply(1, 2, 3)); // 2
```

arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다.

선언된 매개변수의 개수와 함수를 호출할 때 전달하는 인수의 개수를 확인하지 않는 자바스크립트의 특성 때문에 함수가 호출되면 인수 개수를 확인하고 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다.

→ arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하다.

```jsx
function sum() {
  let res = 0;

  // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.
  for (let i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }

  return res;
}

console.log(sum()); // 0
console.log(sum(1, 2)); // 3
console.log(sum(1, 2, 3)); // 6
```

arguments 객체는 배열 형태로 인자 정보를 담고 있지만 **실제 배열이 아닌 유사 배열 객체**다.

<aside>
💬

유사 배열 객체란?

`length 프로퍼티`를 가진 객체로 for 문으로 순회할 수 있는 객체를 말한다.
유사 배열 객체는 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다.
**→ 배열 메서드를 사용하려면 `Function.prototype.call` , `Function.prototype.apply` 를 사용해 간접 호출해야 하는 번거로움이 있다.**

</aside>

```jsx
function sum() {
  // arguments 객체를 배열로 변환
  const array = Array.prototype.slice.call(arguments);
  return array.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2)); // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```

ES6에서는 Rest 파라미터를 도입

```jsx
// ES6 Rest parameter
function sum(...args) {
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2)); // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```

### **18.2.2 caller 프로퍼티**

caller 프로퍼티는 ECMAScript 사양에 포함되지 않은 비표준 프로퍼티다. 넘어가도록 하자.

### **2.3 length 프로퍼티**

함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.

```jsx
function foo() {}
console.log(foo.length); // 0

function bar(x) {
  return x;
}
console.log(bar.length); // 1

function baz(x, y) {
  return x * y;
}
console.log(baz.length); // 2
```

arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있다.

- arguments 객체: 인자의 개수
- 함수 객체: 매개 변수의 개수

## **18.2.4 name 프로퍼티**

함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.

- **name 프로퍼티**는 ES5 와 ES6에서 동작을 다르기 때문에 주의
- **ES5**: 익명 함수 표현식의 경우 빈 문자열을 값을 갖는다.
- **ES6**: 함수 객체를 가리키는 식별자를 값으로 갖는다.

```jsx
// 기명 함수 표현식
var namedFunc = function foo() {};
console.log(namedFunc.name); // foo

// 익명 함수 표현식
var anonymousFunc = function () {};
console.log(anonymousFunc.name); // anonymousFunc

// 함수 선언문
function bar() {}
console.log(bar.name); // bar
```

## **18.2.5 `__proto__` 접근자 프로퍼티**

`__proto__` 프로퍼티는 Prototype 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.

```jsx
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype 이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty("a")); // true
console.log(obj.hasOwnProperty("__proto__")); // false
```

## **18.2.6 prototype 프로퍼티**

prototype 프로퍼티는 **생성자 함수로 호출할 수 있는 함수 객체**로 `non-constructor` 에는 존재하지 않는다.

```jsx
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty("prototype"); // true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty("prototype"); // false
```

→ prototype 프로퍼티는 **함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.**
