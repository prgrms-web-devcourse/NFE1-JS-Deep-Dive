# 13ch 스코프

## 📚 스코프란?

스코프(유효범위)는 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정되는 것을 의미. 즉, 식별자가 유효한 범위를 의미

- 스코프는 변수, 함수와 깊은 관련이 있음
- 변수는 코드의 가장 바깥 영역뿐 아니라 코드 블록이나 함수 몸채 내에서도 선언이 가능한데, 이때 코드 블록이나 함수는 중첩이 될 수 있음

```tsx
var x = "global";

function foo() {
  var x = "local";
  console.log(x); // 1
}

foo();

console.log(x); // 2
```

- 위의 코드에서는 코드의 가장 바깥 영역과 foo 함수 내부에 같은 이름을 갖는 x 변수가 있음을 볼 수 있다
  → 이때, 자바스크립트 엔진은 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조할 것인지를 결정하는데 이를 식별자 결정(`identifier resolution`)이라 한다
- 따라서, 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고 할 수 있다

> 💡
> 렉시컬 환경(lexical environment): 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 의미
> 실행 컨텍스트(execution context): 렉시컬 환경으로 이루어진 코드의 문맥을 구현한 것을 의미. 모든 코드는 실행 컨텍스트에서 평가되고 실행된다 할 수 있다

- 이름이 동일한 식별자여도 스코프는 다른 별개의 변수일 수 있다. 만약 스코프란 개념이 없으면 같은 이름을 갖는 변수는 충돌을 일으키게 되어 프로그램 전체에서 하나밖에 사용할 수 없게 된다
- 식별자는 어떤 값을 구별할 수 있어야 하므로 유일해야 한. 이때, 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있음을 확인할 수 있다. 즉, 스코프는 `네임스페이스`이다
- var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되는데, 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다
  ```tsx
  function foo() {
    var x = 1;
    var x = 2;
    console.log(x); // 2
  }
  ```
  - var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용
  - 위의 코드에서 `var x = 2;`와 같은 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다
- let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다
  ```tsx
  function bar() {
    let x = 1;
    let x = 2; // SyntaxError: Identifier 'x' has already been declared
  }
  bar();
  ```

## 📚 스코프의 종류

- 코드는 전역과 지역으로 구분할 수 있다
  | 구분 | 설명 | 스코프 | 변수 |
  | ---- | --------------------- | ----------- | --------- |
  | 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
  | 지역 | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |
  - 전역에서 선언된 변수는 전역 스코프를 갖는 변수, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다
  - 전역 변수는 어디서든지 참조할 수 있다
  - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다

## 📚 스코프 체인

- 함수의 중첩: 함수 몸체 내부에서 함수가 정의된 것
- 중첩 함수: 함수 몸체 내부에서 정의한 함수
- 외부 함수: 중첩 함수를 포함하는 함수

- 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 `계층적 구조`를 지님
- 스코프 체인: 스코프가 계층적으로 연결된 것
  - 변수를 참조할 때 자바스크립트 엔진은 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색 → 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조가 가능해짐
  - `변수 선언`이 실행되면 변수 `식별자`가 자료구조(렉시컬 환경)에 키로 등록되고, `변수 할당`시 자료구조의 변수 식별자에 해당하는 값을 변경함

### 스코프 체인에 의한 변수 검색

- 자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색
- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서는 참조할 수 없음

## 📚 함수 레벨 스코프

- ‘지역은 함수 몸체 내부를 말하고 지역은 스코프를 만든다’ = ‘코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다’
- var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정하고, 이를 `함수 레벨 스코프`라 칭함

## 📚 렉시컬 스코프

- `동적 스코프`: 함수가 호출되는 시점에 동적으로 상위 스코프를 결정
- `렉시컬 스코프 또는 정적 스코프`: 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정
  - 자바스크립트는 렉시컬 스코프를 따른다
  - 따라서 함수를 어디서 호출했는지가 아닌 **`함수를 어디서 정의했는지`**에 따라 상위 스코프를 결정
  - 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프가 된다
  - 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문에 **함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성되 함수 객체는 이렇게 결정된 상위 스코프를 기억한다**

# 14ch 전역 변수의 문제점

## 📚 변수의 생명 주기

### 지역 변수의 생명 주기

- 변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 계속해서 메모리 공간을 점유
- 변수는 자신이 선언된 위치에서 생성되고 소멸함
- `전역 변수`의 생명 주기 = 애플리케이션의 생명 주기
- `지역 변수`의 생명 주기 = 함수가 호출되면 생성되고 함수가 종료하면 소멸 = 함수의 생명 주기

```tsx
function foo() {
  var name = "hyein";
  console.log(name); // hyein
  return name;
}

foo();
console.log(name); // ReferenceError: name is not defined
```

- 변수 선언문은 선언문이 어디에 있든 상관없이 `가장 먼저 실행`됨
- `변수 선언`은 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임에 실행되는 것이 아닌 `런타임 이전 단계`에서 자바스크립트 엔진에 의해 먼저 실행됨
- 함수 몸체 내부에서 선언된 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치하나, 지역 변수가 함수보다 오래 생존하는 경우도 있음

> 💡
> 즉, `변수의 생명 주기`는 메모리 공간이 확보된 시점부터 메모리 공간이 해제가 되어 가용 메모리 풀에 반환되는 시점까지 라고 할 수 있다

- 변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효함
  - 할당된 메모리 공간은 더 이상 참조되지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환됨
  - 즉, 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 되며 이는 스코프도 마찬가지이다
- `호이스팅`은 스코프를 단위로 동작
- 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 의미

### 전역 변수의 생명 주기

- 전역 코드는 코드가 로드되자마자 곧바로 해석되고 실행됨
- 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨

> 💡
> 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체를 의미

- 전역 객체 window는 웹페이지를 닫기 전까지 유효함
- `var` 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치

## 📚 전역 변수의 문제점

- 암묵적 결합
  - 모든 코드가 전역 변수를 참조하고 변경할 수 있음
  - 변수의 유효 범위↑ 가독성↓ 의도치 않은 상태 변경의 위험성↑
- 긴 생명 주기
  - 전역 변수는 생명 주기가 길어서 메모리 리소스 소비 기간이 길다
- 스코프 체인 상에서 종점에 존재
  - 변수 검색시 전역 변수가 가장 마지막에 검색되므로 전역 변수의 검색 속도가 가장 느림
- 네임스페이스 오염
  - 다른 파일 내에서 동일한 이름으로 명명된 전역 변수, 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 갖고옴

## 📚 전역 변수의 사용을 억제하는 방법

변수의 스코프를 좁힐수록 좋음!

### 즉시 실행 함수

단 한 번만 호출되는 함수로, 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다

### 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

### 모듈 패턴

클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만듦 → 이는 클로저를 기반으로 동작하며 전역 변수의 억제를 포함하여 캡슐화까지 구현할 수 있음

> 💡
> `캡슐화`는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작 메서드를 하나로 묶는 것을 의미
> 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하며 이를 `정보 은닉`이라 칭함

### ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공

# 15ch let, const 키워드와 블록 레벨 스코프

## 📚 var 키워드로 선언한 변수의 문제점

### 변수 중복 선언 허용

변수 중복 선언이 가능하여 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 존재

```tsx
var x = 1;
var y = 1;

// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용
// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작
var x = 100;
// 초기화문이 없는 변수 선언문은 무시됨
var y;

console.log(x); // 100
console.log(y); // 1
```

### 함수 레벨 스코프

var 키워드로 선언한 변수는 오직 함수의 코드 블록만을 지역 스코프로 인정

즉, 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됨

```tsx
var x = 1;

if (true) {
  // x는 전역 변수. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언됨
  // 이는 곧 의도치 않게 변수값이 변경되는 부작용을 발생
  var x = 10;
}

console.log(x); // 10
```

함수 레벨 스코프는 전역 변수를 남발할 가능성을 높이는데, 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생함

### 변수 호이스팅

변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작

변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조가 가능 → 할당문 이전에 변수를 참조하면 언제나 undefined를 반환

## 📚 let 키워드

### 변수 중복 선언 금지

let 키워드를 사용하면 같은 변수를 중복 선언시 문법 에러가 뜸

### 블록 레벨 스코프

함수 레벨 스코프를 따르는 var와 달리 `let`을 통해 선언된 변수는 모든 코드 블록을 지역 스코프로 인정하는 `블록 레벨 스코프`를 따름

### 변수 호이스팅

var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작

```tsx
console.log(foo); // ReferenceError: foo is not defined
let foo;
```

- var 키워드로 선언한 변수는 런타임 이전에 `선언 단계`와 `초기화 단계`가 `한번에` 진행됨
  - 선언 단계: 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알림
  - 초기화 단계: undefined로 변수를 초기화
  - 따라서 변수 선언문 이전에 변수에 접근해도 스코프에 변수가 존재하지 않으므로 에러가 발생하지 않으며, 이후 변수 할당문에 도달하면 비로소 값이 할당됨
- let 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 `분리`되어 진행됨
  - 런타임 이전에 선언 단계가 먼저 실행
  - 초기화 단계는 변수 선언문에 도달했을 때 실행
  - 만약 초기화 단계 이전에 변수에 접근시 참조 에러가 발생

### 전역 객체와 let

let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재

## 📚 const 키워드

const 키워드는 상수를 선언하기 위해 사용함

### 선언과 초기화

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화가 필요

```tsx
const age = 26;
```

const로 선언한 변수는 let으로 선언된 변수와 마찬가지로 `블록 레벨 스코프`를 가짐

### 재할당 금지

const 키워드로 선언한 변수는 재할당이 금지됨

```tsx
const foo = 1;
foo = 2; //TypeError: Assignment to constant variable
```

### 상수

재할당이 금지된 변수로, 상수는 재할당이 금지됨

- const 키워드로 선언된 변수에 원시 값을 할당한 원시 값은 변경할 수 없는 값
- const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없음

### const 키워드와 객체

const로 원시 값을 할당한 경우 값을 변경할 수 없으나, const로 객체를 할당한 경우 값을 변경할 수 있음

```tsx
const person = {
  name: "jeong",
};

person.name = "cho";

console.log(person); // {name: 'cho'}
```

- const 키워드는 재할당을 금지할 뿐 ‘불변’을 의미하진 않음
- 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능하며, 이때 객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않음

# 16ch 프로퍼티 어트리뷰트

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 **ECMAScript 사양에서 사용하는 `의사 프로퍼티(pseudo property)`와 `의사 메서드(pseudo method)`**

- ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작함
- 외부로 공개된 객체의 프로퍼티가 아니므로 원칙적으로 개발자가 직접 접근하거나 호출할 수 없다
  - 자바스크립트 엔진의 내부 로직임
- 일부는 간접적으로 접근할 수 있다
  - 모든 객체는 `[[Prototype]]`이라는 `내부 슬롯`을 갖고있다
  - 해당 `내부 슬롯`에 `__proto__`를 통하여 간접적으로 접근할 수 있다

## 📚 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의
- 프로퍼티 어트리뷰트에 직접 접근할 수 없지만 `Object.getOwnPropertyDescriptor` 메서드를 사용하여 간접적으로 확인이 가능함
- getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환
  - 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터 요구시 undefined가 반환됨

## 📚 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티로 지금까지 살펴본 모든 프로퍼티가 해당됨
- 접근자 프로퍼티: 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터<br/>객체의 프로퍼티 | 설명                         |
| ------------------- | --------------------------------------- | ---------------------------- |
| [[Value]]           | `value`                                 | 프로퍼티의 값                |
| [[Writable]]        | `writable`                              | 변경 가능 여부의 `boolean`   |
| [[Enumerable]]      | `enumerable`                            | 열거 가능 여부의 `boolean`   |
| [[Configurable]]    | `configurable`                          | 재정의 가능 여부의 `boolean` |

## 📚 접근자 프로퍼티

자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터<br/>객체의 프로퍼티 | 설명                                                                       |
| ------------------- | --------------------------------------- | -------------------------------------------------------------------------- |
| [[Get]]             | `get`                                   | 접근자 프로퍼티를 통해 프로퍼티의 값을 읽을 때 호출되는 접근자 함수        |
| [[Set]]             | `set`                                   | 접근자 프로퍼티를 통해 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다. |
| [[Enumerable]]      | `enumerable`                            | 열거 가능 여부의 `boolean`                                                 |
| [[Configurable]]    | `configurable`                          | 재정의 가능 여부의 `boolean`                                               |

- 접근자 함수는 `getter/setter 함수` 라고도 칭함
  - 접근자 프로퍼티는 `getter`와 `setter` 함수 모두 정의하거나 하나만 정의할 수도 있음

## 📚 프로퍼티 정의

새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것

## 📚 객체 변경 방지

### 객체 확장 금지

- Object.preventExtensions
- 확장이 금지된 객체는 프로퍼티 추가가 금지됨

### 객체 밀봉

- Object.seal
- 밀봉된 객체는 읽기와 쓰기만 가능

### 객체 동결

- Object.freeze
- 동결된 객체는 읽기만 가능

### 불변 객체

지금까지 살펴본 변경 방지 메서드들은 `얕은 변경 방지`로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못함

# 17ch 생성자 함수에 의한 객체 생성

### Object 생성자 함수

new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수로, 생성자 함수에 의해 생성된 객체를 인스턴스라 칭함

### 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다는 장점이 있으나, 단 하나의 객체만 생성해야하는 단점으로 여러 개 생성해야하는 경우 비효율적이다

> 💡
> this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이다. 즉, this 바인딩은 함수 호출 방식에 따라 동적으로 결정됨

# 18ch 함수와 일급 객체

- 다음과 같은 조건을 만족하는 객체를 **`일급 객체`** 라 한다
  1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다
  2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
  3. 함수의 매개변수에 전달할 수 있다
  4. 함수의 반환값으로 사용할 수 있다

```jsx
// 1. 함수는 무명의 리터럴로 생성할 수 있다.
// 2. 함수는 변수에 저장할 수 있다.
// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.
const increase = function (num) {
  return ++num;
};

const decrease = function (num) {
  return --num;
};

// 2. 함수는 객체에 저장할 수 있다.
const auxs = { increase, decrease };

// 3. 함수의 매개변수에게 전달할 수 있다.
// 4. 함수의 반환값으로 사용할 수 있다.
function makeCounter(aux) {
  let num = 0;

  return function () {
    num = aux(num);
    return num;
  };
}

// 3. 함수는 매개변수에게 함수를 전달할 수 있다.
const increaser = makeCounter(auxs.increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

// 3. 함수는 매개변수에게 함수를 전달할 수 있다.
const decreaser = makeCounter(auxs.decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

- 함수가 일급 객체이다 = 함수를 객체와 동일하게 사용할 수 있다
- 함수는 값과 동일하게 취급할 수 있다
- 값을 사용할 수 있는 곳이라면 어디서든 리터럴로 정의할 수 있으며 런타임 함수에 객체로 평가됨
- 함수의 매개변수에 전달을 할 수 있으며, 함수의 반환값으로 사용할 수 있음
- 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있으므로 일반 객체에는 없는 함수 고유의 프로퍼티를 소유함

### arguments 프로퍼티

```jsx
function sum() {
  let res = 0;

  // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.
  for (let i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }

  return res;
}

console.log(sum()); // 0
console.log(sum(1, 2)); // 3
console.log(sum(1, 2, 3)); // 6
```

- arguments 프로퍼티 값은 arguments 객체로, 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 **유사 배열 객체**
- 함수 내부에서 지역 변수처럼 사용되어 외부에서 접근이 불가능
- 함수 객체 arguments 프로퍼티는 ES3 부터 표준에서 폐지되어 Function.arguments의 사용법은 권장되지 않음
- arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타냄
- 함수가 호출되면 인수 개수를 확인하고 이에 따라 함수 동작을 달리 정의할 필요가 있을 수 있으며, 이는 **가변 인자 함수**를 구현할 때 유용
- ES6 이전에는 arguments 객체는 유사 배열 객체로 구분되었지만 이터러블이 도입된 ES6 이후부터 arguments 객체는 유사 배열 객체이면서 동시에 이터러블임

### caller 프로퍼티

- ECMAScript 사야에 포함되지 않은 비표준 프로퍼티

### length 프로퍼티

```jsx
function foo() {}
console.log(foo.length); // 0

function bar(x) {
  return x;
}
console.log(bar.length); // 1

function baz(x, y) {
  return x * y;
}
console.log(baz.length); // 2
```

- 함수를 정의할 때 선언한 매개변수 개수를 가리키며, arguments 객체의 length와 length 프로퍼티와 함수 객체의 length 프로퍼티 값은 다를 수 있음
- arugments 객체의 length는 인자(Arguments)의 개수를, 가리키고, 함수 객체의 length는 매개변수(Parameter)의 개수를 가리킴

### name 프로퍼티

```jsx
// 기명 함수 표현식
var namedFunc = function foo() {};
console.log(namedFunc.name); // foo

// 익명 함수 표현식
var anonymousFunc = function () {};
// ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.
// ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.
console.log(anonymousFunc.name); // anonymousFunc

// 함수 선언문(Function declaration)
function bar() {}
console.log(bar.name); // bar
```

- 함수 객체의 name 프로퍼티는 함수 이름을 나타냄
- name 프로퍼티는 ES5와 ES6에서 동작을 달리하는데, **ES5에서 익명 함수 표현식의 name 프로퍼티는 빈 문자열을 값으로 갖는다는 점**과 **ES6에서 함수 객체를 가르키는 식별자를 값으로 갖는다는 점**에서 차이가 있음

### **proto** 접근자 프로퍼티

```jsx
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty("a")); // true
console.log(obj.hasOwnProperty("__proto__")); // false
```

- [[Prototype]]내부슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

### prototype 프로퍼티

```jsx
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty("prototype"); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty("prototype"); // -> false
```

- 생성자 함수로 호출할 수 있는 객체인 constructor만이 소유하는 프로퍼티
- 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스 프로토타입 객체를 가리킴
