# 프로토타입

자바스크립트에 대한 설명을 우선 해보겠습니다.

- 멀티 패러다임 언어
  자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 언어입니다.
- 프로토타입 기반 객체지향
  자바스크립트는 클래스 기반 언어(C++, 자바 등)와 달리, 프로토타입을 통해 상속과 캡슐화를 구현합니다. public, private 같은 접근 제어자가 없어 객체지향 언어가 아니라고 오해할 수 있지만, 실제로는 강력한 객체지향 기능을 제공합니다.
- ES6 클래스
  ES6에서 도입된 클래스는 단순히 **문법적 설탕(Syntactic Sugar)** 일 뿐, 실제로는 프로토타입을 기반으로 동작합니다. 즉, 클래스는 기존 객체 생성 방식의 편리한 표현입니다.
- 자바스크립트의 객체
  자바스크립트는 원시 타입(숫자, 문자열 등)을 제외한 거의 모든 값이 객체입니다. 객체 리터럴, 생성자 함수, Object.create() 등을 통해 다양한 방식으로 객체를 생성할 수 있습니다.
- 객체지향 요소
  자바스크립트는 캡슐화, 상속, 다형성 같은 객체지향 프로그래밍의 주요 요소를 프로토타입 체계를 통해 지원합니다.

## 객체지향 프로그래밍

- 객체지향 프로그래밍은 프로그램을 독립적인 단위(객체)의 집합으로 구성하는 패러다임입니다.
- 각 객체는 속성(attribute/property)과 이를 다루는 함수(메서드)를 가지며, 이를 통해 객체의 상태와 동작을 표현합니다.

### 추상화와 속성

- 현실의 사물을 객체로 표현할 때 모든 속성을 포함하지 않고, 특정 속성만을 추출하여 표현합니다. 이를 추상화라고 합니다.
- 예시: 이름과 주소 속성만을 가진 객체 person을 만들고, 이를 통해 사람의 특정 속성만을 나타낼 수 있습니다.

### 객체의 상태와 동작

- 객체는 상태(state)를 나타내는 데이터와 동작(behavior)을 조작할 수 있는 메서드(method)를 가집니다.
- 객체지향 프로그래밍에서는 객체의 상태와 동작을 하나의 논리적 단위로 묶어 복합적인 자료구조로 사용합니다.

### 객체 간의 관계와 메시지 전달

- 객체는 자신의 상태를 다른 객체와 상호작용하거나 메서드를 호출함으로써 조작할 수 있습니다.
- 다른 객체와의 관계나 메시지 전달을 통해 객체의 동작을 유기적으로 연결할 수 있습니다.

## 상속과 프로토타입

### 상속(Inheritance)이란?

- 객체지향 프로그래밍의 핵심 개념으로, 한 객체가 다른 객체의 속성이나 메서드를 물려받아 사용할 수 있게 해주는 기능입니다.
- 상속을 통해 코드의 중복을 줄이고, 기존 코드의 재사용성을 높일 수 있습니다.

### 문제점: 생성자 함수의 중복

![alt text](./image/최효종/메서드_중복_생성.png)

- 예제에서 Circle 생성자 함수는 모든 인스턴스가 동일한 getArea 메서드를 개별적으로 생성합니다.
- 이렇게 되면 모든 인스턴스가 메서드를 따로 가지게 되어 메모리 낭비와 성능 저하를 초래할 수 있습니다.

### 해결 방법: 프로토타입을 통한 상속

![alt text](./image/최효종/상속에_의한_메서드_공유.png)

- 자바스크립트는 프로토타입 체계를 사용해 상속을 구현합니다.
- Circle.prototype에 getArea 메서드를 정의하면, 생성된 모든 인스턴스가 이 메서드를 공유하여 중복 생성 문제를 해결할 수 있습니다.

### 상속의 장점

- 코드 재사용: 공통된 메서드를 프로토타입에 정의하여 모든 인스턴스에서 공유.
- 메모리 절약: 중복된 메서드가 인스턴스마다 개별적으로 생성되지 않음.
- 유지보수 용이: 메서드를 프로토타입에 한 번만 정의해도 되므로, 코드 변경 시 모든 인스턴스에 적용 가능.

## 프로토타입(Prototype)이란?

- 프로토타입은 객체지향 프로그래밍에서 객체 간 상속을 구현하기 위해 사용됩니다.
- 객체는 자신의 프로토타입을 통해 상위(부모) 객체의 속성과 메서드를 사용할 수 있습니다.
- 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지고 있으며, 객체 생성 방식에 따라 이 프로토타입이 결정됩니다.

### 프로토타입과 생성자 함수의 관계

- 객체 리터럴로 생성된 객체는 Object.prototype을 프로토타입으로 갖습니다.
- 생성자 함수로 생성된 객체는 해당 생성자 함수의 prototype 속성을 프로토타입으로 가집니다.
- 모든 프로토타입 객체는 constructor 프로퍼티를 가지고 있으며, 이 프로퍼티는 해당 프로토타입을 생성한 생성자 함수를 참조합니다.

### **proto** 접근자 프로퍼티

- **proto** 는 객체의 프로토타입에 간접적으로 접근할 수 있게 해주는 접근자 프로퍼티입니다.
- 객체의 **proto** 를 통해 자신의 프로토타입에 접근하거나, 다른 객체의 프로토타입을 참조할 수 있습니다.
- ES6부터는 Object.getPrototypeOf()와 Object.setPrototypeOf() 메서드를 사용하여 **proto**를 대신하도록 권장합니다.

### 프로토타입 체인

- 객체는 프로토타입 체인을 따라가며 상위 객체의 속성과 메서드에 접근합니다.
- 만약 객체 자체에 원하는 속성이나 메서드가 없으면, 프로토타입 체인을 따라 상위 객체로 탐색이 이어집니다.

### 프로토타입과 상속

- 프로토타입을 통해 객체는 다른 객체의 속성과 메서드를 상속받아 사용할 수 있습니다.
- prototype 속성을 사용해 생성자 함수에서 상속을 구현하면, 여러 인스턴스가 동일한 메서드를 공유하게 되어 메모리 효율성이 증가합니다.

### 생성자 함수와 prototype

![alt text](./image/최효종/생성자함수와_prototype.png)

- 생성자 함수는 객체를 생성할 때 해당 객체의 프로토타입을 자동으로 설정해 줍니다.
- 생성된 객체는 **proto** 를 통해 생성자 함수의 prototype 객체에 연결됩니다.

## 리터럴 표기법에 의한 객체 생성 간단 정리

### 리터럴 표기법이란?

- 자바스크립트에서 객체, 함수, 배열, 정규 표현식 등을 생성할 때 사용하는 간단한 문법입니다.
- 리터럴 표기법을 사용하여 생성된 객체도 프로토타입을 가지며, constructor 프로퍼티를 통해 생성자 함수와 연결됩니다.

### 리터럴 표기법과 생성자 함수의 관계

- 리터럴 표기법으로 생성된 객체는 Object 생성자 함수의 Object.prototype을 프로토타입으로 갖습니다.
- 예를 들어, {}로 생성된 객체는 Object 생성자 함수의 프로토타입을 상속받고, []로 생성된 배열은 Array.prototype을 상속받습니다.

### 생성자 함수와 연결

- 리터럴 표기법으로 생성된 객체는 내부적으로 생성자 함수를 호출한 것과 동일한 특성을 갖습니다.
- 객체 리터럴({})은 Object, 함수 리터럴(function() {})은 Function, 배열 리터럴([])은 Array 생성자 함수와 연결됩니다.

### 리터럴 표기법의 특징

- 리터럴 표기법으로 생성된 객체는 별도의 생성자 함수를 호출하지 않아도 생성됩니다.
- 리터럴 표기법으로 생성된 객체도 constructor 프로퍼티를 통해 생성자 함수와 연결되므로, 생성자 함수로 생성된 객체와 본질적으로 동일합니다.

### 리터럴 표기법의 종류

- 객체 리터럴: {}로 생성되며, Object.prototype을 프로토타입으로 가집니다.
- 함수 리터럴: function으로 생성되며, Function.prototype을 프로토타입으로 가집니다.
- 배열 리터럴: []로 생성되며, Array.prototype을 프로토타입으로 가집니다.
- 정규 표현식 리터럴: /pattern/flags로 생성되며, RegExp.prototype을 프로토타입으로 가집니다.

### 리터럴 표기법과 생성자 함수 비교

- 리터럴 표기법으로 생성된 객체와 생성자 함수로 생성된 객체는 생성 과정에서는 차이가 있지만, 결과적으로 동일한 특성을 가집니다.
- 리터럴 표기법으로 생성된 객체도 프로토타입 체인을 따라 생성자 함수의 프로토타입을 상속받게 됩니다.

## 프로토타입의 생성 시점 정리

### 프로토타입과 생성자 함수의 관계

- 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성됩니다.
- 모든 객체는 생성될 때 특정 생성자 함수의 prototype 객체를 상속받아 프로토타입 체인이 연결됩니다.

### Object.create와 클래스에 의한 객체 생성

- Object.create 메서드를 사용하면 프로토타입을 명시적으로 지정하여 객체를 생성할 수 있습니다.
- 클래스 문법으로 생성된 객체는 클래스의 prototype을 상속받습니다.

### 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 함께 생성됩니다.
- 즉, 생성자 함수와 프로토타입 객체는 단독으로 존재할 수 없으며 언제나 쌍으로 존재합니다.

### 사용자 정의 생성자 함수의 프로토타입 생성 시점

- 사용자가 직접 정의한 생성자 함수는 함수가 평가될 때 프로토타입 객체도 함께 생성됩니다.
- constructor 속성을 가진 함수가 정의되면, 해당 함수는 인스턴스를 생성할 수 있는 생성자 함수가 됩니다.

### 빌트인 생성자 함수와 프로토타입 생성 시점

- 자바스크립트의 기본 객체(Object, Array, Function 등)의 생성자 함수는 자바스크립트 엔진이 실행될 때 미리 생성됩니다.
- 빌트인 객체들은 Object.prototype, Array.prototype과 같은 자체 프로토타입 객체를 가지며, 이들 역시 엔진 실행 시점에 생성됩니다.

### 전역 객체의 프로토타입

- 전역 객체(window 객체 등)는 자바스크립트 코드가 실행되기 이전 단계에서 미리 생성된 객체로, 클라이언트와 서버 환경에 따라 다르게 정의될 수 있습니다.
- 전역 객체의 prototype도 엔진에 의해 생성되며, 이후 생성되는 모든 객체는 이 프로토타입을 상속받습니다.

## 객체 생성 방식과 프로토타입의 결정 간단 정리

### 객체 생성 방식 자바스크립트에서는 다음과 같은 다양한 방식으로 객체를 생성할 수 있습니다

- 객체 리터럴 ({})
- Object 생성자 함수 (new Object())
- 사용자 정의 생성자 함수 (function Person())
- Object.create() 메서드
- ES6 클래스 (class)

### 프로토타입의 결정

- 객체가 생성될 때, 각 방식마다 객체의 프로토타입이 결정됩니다.
- 자바스크립트 엔진은 객체를 생성할 때 OrdinaryObjectCreate라는 추상 연산을 통해 객체를 생성하고, 이때 객체의 프로토타입이 결정됩니다.
- 예를 들어, 객체 리터럴로 생성된 객체의 프로토타입은 Object.prototype입니다.

### 객체 리터럴에 의해 생성된 객체의 프로토타입

- 객체 리터럴 {}로 생성된 객체는 Object.prototype을 프로토타입으로 가집니다.
- Object.prototype은 객체가 가지는 기본적인 속성과 메서드(constructor, hasOwnProperty 등)를 포함하고 있습니다.

### Object 생성자 함수에 의해 생성된 객체의 프로토타입

- new Object()로 생성된 객체도 Object.prototype을 프로토타입으로 가지며, 객체 리터럴로 생성된 객체와 동일한 구조를 가집니다.

### 생성자 함수에 의해 생성된 객체의 프로토타입

- 생성자 함수와 함께 new 키워드를 사용하여 객체를 생성하면, 해당 생성자 함수의 prototype 속성이 생성된 객체의 프로토타입이 됩니다.
- 예를 들어, Person 생성자 함수로 생성된 객체의 프로토타입은 Person.prototype입니다.

### 프로토타입의 확장과 상속

- 생성자 함수의 prototype 객체에 새로운 메서드를 추가하면, 생성된 모든 객체가 이 메서드를 상속받아 사용할 수 있습니다.
- 예를 들어, Person.prototype에 sayHello 메서드를 추가하면, Person으로 생성된 모든 객체가 이 메서드를 사용할 수 있습니다.

### 클래스와 프로토타입

- ES6의 클래스 문법으로 생성된 객체도 내부적으로는 생성자 함수의 prototype을 상속받습니다.
- 클래스의 prototype을 확장하면, 해당 클래스로 생성된 모든 객체가 이를 상속받습니다.

## 프로토타입 체인 간단 정리

### 프로토타입 체인(Prototype Chain)이란?

![alt text](./image/최효종/프로토타입_체인.png)

- 자바스크립트에서 객체는 다른 객체를 자신의 프로토타입으로 참조할 수 있습니다.
- 이러한 참조 관계가 체인처럼 연결되어 있는 구조를 프로토타입 체인이라고 합니다.
- 객체의 프로퍼티나 메서드에 접근할 때, 해당 객체에 없으면 프로토타입 체인을 따라 상위 객체를 탐색합니다.

### 프로토타입 체인의 예시

- 예제에서 Person 생성자 함수의 인스턴스 me는 Person.prototype을 프로토타입으로 가집니다.
- Person.prototype은 다시 Object.prototype을 프로토타입으로 가지므로, me 객체는 Object.prototype의 메서드(hasOwnProperty 등)를 사용할 수 있습니다.

### 프로토타입 체인의 탐색

- 객체의 프로퍼티를 검색할 때, 자바스크립트 엔진은 객체의 프로토타입 체인을 따라 탐색합니다.
- 예를 들어, me.hasOwnProperty('name')을 호출하면 me 객체에서 hasOwnProperty 메서드를 찾고, 없으면 Person.prototype에서 찾습니다. 만약 Person.prototype에도 없으면 Object.prototype까지 탐색합니다.

### 프로토타입 체인의 최종점

- 모든 객체의 프로토타입 체인의 최종점은 Object.prototype입니다.
- Object.prototype의 프로토타입은 null이며, 더 이상 상위 객체가 없음을 의미합니다.

### 프로토타입 체인의 예제 분석

```
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
console.log(me.hasOwnProperty('name')); // true
console.log(Object.getPrototypeOf(me) === Person.prototype); // true
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // true
```

- me 객체는 Person.prototype을 상속받아 sayHello 메서드를 사용할 수 있습니다.
- 또한, Person.prototype은 Object.prototype을 상속받아 hasOwnProperty 메서드를 사용할 수 있습니다.

### 프로토타입 체인의 역할

- 프로토타입 체인은 객체 간 상속 관계를 정의하고, 객체의 속성이나 메서드를 찾기 위한 탐색 경로를 제공합니다.
- 프로토타입 체인은 자바스크립트의 객체지향 프로그래밍을 지원하는 핵심 메커니즘입니다.

### 스코프 체인과의 차이점

- 프로토타입 체인은 객체 간의 상속을 구현하기 위한 메커니즘입니다.
- 스코프 체인은 변수나 함수의 유효 범위를 결정하고, 식별자를 검색하기 위한 메커니즘입니다.
- 두 체인은 서로 독립적이지만, 협력하여 식별자와 프로퍼티를 검색할 때 사용됩니다.

## 오버라이딩과 프로퍼티 섀도잉

### 오버라이딩(Overriding)

- 자바스크립트에서 오버라이딩은 상위 클래스나 프로토타입에 정의된 메서드나 프로퍼티를 하위 클래스나 객체에서 재정의하는 것을 의미합니다.
- 예를 들어, Person.prototype.sayHello 메서드를 me 객체에서 다시 정의하여 기존 메서드를 덮어씁니다.

```
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

me.sayHello(); // Hey! My name is Lee
```

- 위 코드에서 me 객체는 Person.prototype.sayHello를 덮어쓴(오버라이딩) sayHello 메서드를 사용합니다.

### 프로퍼티 섀도잉(Property Shadowing)

- 프로퍼티 섀도잉은 객체의 프로퍼티가 프로토타입 체인의 상위 프로퍼티를 덮어써서 가리는 현상을 의미합니다.
- 하위 객체에 같은 이름의 프로퍼티가 존재할 때, 상위 객체의 프로퍼티는 접근할 수 없습니다

```
const me = new Person('Lee');
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

delete me.sayHello; // 하위 객체의 메서드 삭제
me.sayHello(); // Hi! My name is Lee (프로토타입의 메서드가 호출됨)
```

- 하위 객체의 sayHello 메서드를 삭제하면, 다시 상위 객체(프로토타입)의 sayHello 메서드가 호출됩니다.

### 오버라이딩과 프로퍼티 섀도잉의 차이점

- 오버라이딩은 상위 프로토타입 메서드나 프로퍼티를 하위 객체에서 재정의하는 것을 의미합니다.
- 프로퍼티 섀도잉은 하위 객체가 같은 이름의 프로퍼티를 가짐으로써 상위 프로퍼티를 덮어쓰는(섀도잉) 현상입니다.

### 프로토타입의 메서드 삭제

- 하위 객체에서 프로토타입의 메서드를 삭제하려고 하면 삭제되지 않습니다.
- 프로토타입 체인에서 하위 객체가 아닌 프로토타입에 직접 접근하여 삭제해야 합니다.

```
delete Person.prototype.sayHello; // 프로토타입 메서드 삭제
me.sayHello(); // TypeError: me.sayHello is not a function
```

- 오버라이딩: 상위 프로토타입의 메서드를 하위 객체에서 재정의.
- 프로퍼티 섀도잉: 하위 객체의 프로퍼티가 상위 프로퍼티를 가림.
- 프로퍼티 삭제 시, 프로토타입 체인을 통해 상위 프로퍼티에 접근하여 삭제해야 함.

## 프로토타입 교체란?

프로토타입 교체는 생성자 함수의 prototype 프로퍼티를 다른 객체로 변경하여 인스턴스가 새로운 프로토타입을 참조하도록 하는 것입니다. 프로토타입은 객체 간의 상속 관계를 결정하는 중요한 요소이며, 이를 교체함으로써 인스턴스의 프로토타입 체인을 변경할 수 있습니다.

### 생성자 함수에 의한 프로토타입의 교체

- 생성자 함수의 prototype 프로퍼티는 기본적으로 생성자 함수가 생성할 객체의 프로토타입이 됩니다.
- 생성자 함수의 prototype을 다른 객체 리터럴로 교체하면, 새로운 객체의 **proto** 는 교체된 객체를 참조하게 됩니다.
- 교체된 객체 리터럴에는 constructor 프로퍼티가 존재하지 않기 때문에, 프로토타입 체인이 깨질 수 있습니다.
- 예제 19-40과 19-41에서는 Person.prototype을 객체 리터럴로 교체하여 기존의 constructor 프로퍼티와의 연결이 끊어지는 상황을 보여주고 있습니다. 이로 인해 me.constructor를 조회하면 Person이 아닌 Object를 반환하게 됩니다.

### 9.9.2 인스턴스에 의한 프로토타입의 교체

- 이미 생성된 객체의 프로토타입을 변경할 때 Object.setPrototypeOf 메서드를 사용합니다.
- 이렇게 변경된 프로토타입은 기존의 생성자 함수와의 연결을 유지하지 않기 때문에, 생성자 함수의 prototype 프로퍼티와는 다른 프로토타입 체인을 가지게 됩니다.
- 예제 19-43에서는 Object.setPrototypeOf를 사용하여 me 객체의 프로토타입을 새로운 객체 parent로 교체하고, me의 sayHello 메서드를 통해 변경된 프로토타입이 올바르게 동작함을 보여줍니다.

### 프로토타입 교체 시 주의점

- 생성자 함수의 prototype을 객체 리터럴로 교체할 경우, constructor 프로퍼티와의 연결이 깨져서 의도한 생성자 함수가 아닌 Object를 가리키게 될 수 있습니다. 이 경우 constructor 프로퍼티를 명시적으로 추가해주어야 합니다.
- 이미 생성된 객체의 프로토타입을 교체할 때 Object.setPrototypeOf 메서드를 사용하면, 상속 관계가 동적으로 변하게 되므로 코드의 복잡도가 증가할 수 있습니다.

## instanceof 연산자

instanceof 연산자는 좌변에 있는 객체가 우변에 있는 생성자 함수의 prototype에 바인딩된 객체를 프로토타입 체인 상에서 찾을 수 있는지를 판별합니다. 만약 찾을 수 있다면 true를 반환하고, 찾을 수 없다면 false를 반환합니다.

```
object instanceof ConstructorFunction
```

- object: 검사할 인스턴스 객체
- ConstructorFunction: 생성자 함수 또는 그 함수의 프로토타입이 될 객체

### 예제 코드 분석

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');
console.log(me instanceof Person); // true
console.log(me instanceof Object); // true
```

- me 객체는 Person 생성자 함수로 생성되었으므로 me instanceof Person은 true가 됩니다.
- 모든 객체는 Object의 인스턴스이므로 me instanceof Object 또한 true가 됩니다.

### 프로토타입 교체 후의 instanceof

```
const parent = {};
Object.setPrototypeOf(me, parent);

console.log(me instanceof Person); // false
console.log(me instanceof Object); // true
```

me 객체의 프로토타입을 parent로 변경했기 때문에, me instanceof Person은 false를 반환합니다.
하지만 me는 여전히 Object의 인스턴스이므로 me instanceof Object는 true로 평가됩니다.

### instanceof의 동작 원리

instanceof 연산자는 다음과 같은 방식으로 동작합니다

- instanceof는 객체의 프로토타입 체인을 따라가면서, 우변에 있는 생성자 함수의 prototype과 동일한 객체가 존재하는지 확인합니다.
- 만약 존재한다면 true, 존재하지 않으면 false를 반환합니다.

instanceof 연산자와 constructor 프로퍼티의 차이점

- instanceof는 객체의 프로토타입 체인을 통해 평가하기 때문에, constructor 프로퍼티가 변경되더라도 instanceof의 결과에는 영향을 주지 않습니다.
- constructor는 객체를 생성할 때 자동으로 설정되지만, 프로토타입을 교체하거나 명시적으로 constructor를 설정하지 않으면 올바르지 않은 값을 가질 수 있습니다.

## 직접 상속

직접 상속은 기존 객체를 복제하거나 특정 객체의 프로토타입 체인을 따라 상속 구조를 명확하게 설정할 때 유용하게 사용됩니다. JavaScript에서 객체를 직접 상속받는 방법에는 여러 가지가 있지만, Object.create 메서드를 사용하는 것이 가장 일반적입니다.

### Object.create에 의한 직접 상속

Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성합니다. 이는 new 키워드를 사용하여 객체를 생성하는 방식과는 다르며, ES6 이후 class를 사용한 방식보다 더 명확하게 프로토타입 체인을 설정할 수 있습니다.

```
let obj = Object.create(prototype, propertiesObject);
```

- prototype: 생성할 객체의 프로토타입으로 지정할 객체
- propertiesObject: 생성할 객체의 프로퍼티 키와 디스크립터 객체로 이루어진 객체 (선택 사항)

이 메서드는 OrdinaryObjectCreate라는 내부 함수를 호출하여 객체를 생성합니다. 이를 통해 생성된 객체는 명시적으로 지정된 프로토타입을 가집니다.

### Object.create의 예제 코드 분석

Object.create를 이용한 객체 생성

```
let obj = Object.create(null);
console.log(Object.getPrototypeOf(obj) === null); // true
```

Object.create(null)을 사용하면 프로토타입이 null인 객체를 생성합니다. 이 객체는 Object의 기본 프로퍼티나 메서드(toString, hasOwnProperty 등)를 상속받지 않습니다.

기본 Object를 프로토타입으로 지정한 경우

```
let obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

```

Object.prototype을 프로토타입으로 설정하면, 생성된 객체는 일반 객체와 동일한 프로토타입 체인을 가집니다.

### 객체 리터럴을 프로토타입으로 지정한 경우

```
const myProto = { x: 10 };
let obj = Object.create(myProto);
console.log(obj.x); // 10
console.log(Object.getPrototypeOf(obj) === myProto); // true

```

myProto 객체를 프로토타입으로 지정하여, 해당 객체의 프로퍼티를 상속받는 새로운 객체를 생성합니다.

### 프로퍼티 디스크립터를 사용한 프로퍼티 정의

```
let obj = Object.create(Object.prototype, {
  y: {
    value: 20,
    writable: true,
    enumerable: true,
    configurable: true
  }
});
console.log(obj.y); // 20
```

Object.create의 두 번째 인수로 프로퍼티 디스크립터 객체를 전달하여, 객체의 프로퍼티를 정의할 수 있습니다. 이 방식을 사용하면 객체의 프로퍼티를 좀 더 정밀하게 설정할 수 있습니다.

### 객체 리터럴 내부에서 **proto**에 의한 직접 상속

```
const myProto = { x: 10 };
const obj = {
  y: 20,
  __proto__: myProto
};
console.log(obj.x, obj.y); // 10 20
console.log(Object.getPrototypeOf(obj) === myProto); // true
```

**proto** 접근자를 사용하여 객체 리터럴 내부에서 직접적으로 프로토타입을 설정할 수 있습니다. 이 방식은 Object.create를 사용하는 것보다 간결하지만, 프로토타입 체인을 명시적으로 표현하기에는 적합하지 않을 수 있습니다.

## 정적 프로퍼티/메서드

정적 프로퍼티와 메서드는 생성자 함수로 인스턴스를 생성하지 않고도 접근할 수 있는 프로퍼티/메서드를 의미합니다. 정적 프로퍼티와 메서드는 생성자 함수의 prototype 프로퍼티에 바인딩된 프로퍼티나 메서드가 아니라 생성자 함수 자체에 직접 바인딩된 프로퍼티와 메서드를 뜻합니다.

```
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

// 정적 프로퍼티
Person.staticProp = 'static prop';

// 정적 메서드
Person.staticMethod = function () {
  console.log('staticMethod');
};

const me = new Person('Lee');

// 정적 프로퍼티와 메서드 호출
Person.staticMethod(); // staticMethod

// 인스턴스에서 정적 프로퍼티/메서드 호출 불가
me.staticMethod(); // TypeError: me.staticMethod is not a function

```

- Person 생성자 함수의 prototype에 바인딩된 메서드 sayHello는 Person 생성자 함수로 생성된 인스턴스(me)가 참조할 수 있는 메서드입니다.
- Person.staticProp 및 Person.staticMethod는 Person 생성자 함수 자체에 바인딩된 정적 프로퍼티와 메서드로, 인스턴스를 생성하지 않고도 Person을 통해 직접 접근하여 사용할 수 있습니다.
- 정적 프로퍼티/메서드는 인스턴스가 접근할 수 없기 때문에, me.staticMethod()를 호출하려고 하면 에러가 발생합니다.

## 프로퍼티 열거

### for...in 문

for...in 문은 객체의 모든 열거 가능한 프로퍼티를 순회할 때 사용합니다. 여기에는 객체 자신이 가지는 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티도 포함됩니다.

```
for (변수선언문 in 객체) {
  // ...
}
```

```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

// for...in 문을 사용하여 person 객체의 프로퍼티를 순회합니다.
for (const key in person) {
  console.log(key + ': ' + person[key]);
}
// 출력 결과:
// name: Lee
// address: Seoul

```

- for...in 문은 객체의 모든 열거 가능한 프로퍼티를 순회하며, key에는 각 프로퍼티의 이름이 할당됩니다.
- 위 예제에서는 name과 address 프로퍼티가 순서대로 출력됩니다.

### for...in 문의 특징

프로토타입 체인 상의 모든 열거 가능한 프로퍼티를 포함

- for...in 문은 객체의 프로토타입 체인 상에 존재하는 열거 가능한 프로퍼티를 순회합니다. 만약 프로토타입에 toString과 같은 메서드가 추가되어 있다면, 이를 포함하여 순회합니다.
- 예제 19-65에서 toString 메서드는 기본적으로 enumerable: false로 설정되어 있으므로 for...in 문으로 열거되지 않습니다.
- Object.getOwnPropertyDescriptor를 사용하여 열거 가능 여부 확인

- Object.getOwnPropertyDescriptor 메서드를 사용하여 특정 프로퍼티의 열거 가능 여부를 확인할 수 있습니다.
- 예제 19-66에서는 Object.prototype에 존재하는 toString 메서드의 enumerable 값이 false로 설정되어 있음을 확인할 수 있습니다.

### for...in 문과 열거 속성

- for...in 문은 객체의 모든 열거 가능한 프로퍼티를 순회하며, 이때 상속받은 프로퍼티도 포함됩니다.
- 프로퍼티의 열거 가능 여부는 프로퍼티의 속성 중 enumerable 값에 따라 결정되며, false일 경우 for...in 문에서 제외됩니다.

### 배열과 for...in 문

배열에는 for...in 문 대신 for 문, forEach 메서드, for...of 문을 사용하는 것이 바람직합니다.
