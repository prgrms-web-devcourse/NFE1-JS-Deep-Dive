# 01~03Ch

### 컴파일러(인터프리터)

> 사람이 이해할 수 있는 구문을 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기 역할

### 자바스크립트란

- 초창기의 JS는 웹페이지의 보조적인 기능을 수행하기 위한 한정적인 용도로 사용
- Ajax를 통한 비동기 방식으로 데이터를 교환할 수 있게 됨으로, 필요한 부분만 한정적으로 렌더링하는 방식이 가능해짐
- 웹 애플리케이션 구축을 위해 더욱 빠르게 동작하는 JS 엔진인 V8이 등장하면서 JS는 데스크탑 애플리케이션과 유사한 UX를 제공할 수 있는 웹 프로그래밍 언어로 정착
- V8 엔진으로 빌드된 JS의 런타임 환경인 Node.js가 등장하면서 브라우저 이외의 환경에서도 JS엔진이 동작할 수 있도록 함
  > 💡 **Node.js란?** <br/>
      - 비동기 I/O를 지원<br/>
      - 단일 스레드 이벤트 루프 기반으로 동작함으로 요청 처리 성능이 좋음<br/>
      - I/O가 빈번하게 발생하는 SPA에 적합 <br/>
      **npm?** <br/>
      - JS 패키지 매니저<br/>
      - Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할<br/>
      - 패키지 설치 및 관리를 위한 CLI 제공<br/>
      - 패키지 공개 및 검색을 통한 재사용 가능<br/>
      - 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어<br/>
      - 프로토타입 기반의 객체지향 언어

# 04Ch-변수

## 변수와 식별자

### 변수

- 하나의 값을 저장하기 위해 확보한 `메모리 공간` 자체
- 그 메모리 공간을 식별하기 위해 붙인 이름
- 값의 위치를 가리키는 상직적인 이름
- let variable = 123 ⇒ `키워드 변수명 = 값` 의 형태
  - 변수명은 메모리상의 주소를, 값은 주소에 해당하는 값을 의미함
  - 메모리상 값은 언제든 변경이 가능
    ![image](https://github.com/user-attachments/assets/e4dc1232-0c9b-4e28-b01d-33f423e65bde)

### 식별자

> 변수 이름을 의미하며, 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 의미

- 식별자는 값이 아닌 메모리 주소를 기억 → 즉, 식별자는 메모리 주소에 붙인 이름과 같음
- 변수 선언을 통해 JS 엔진이 식별자를 감지

## 변수 선언

- 변수를 생성하는 것
- 값을 저장하기 위한 **메모리 공간을 확보** 후, 확보된 메모리 공간의 **주소를 연결**하여 **값을 저장**할 수 있도록 준비
- 변수를 사용하기 위해 반드시 필요하며 `var`, `let`, `const` 키워드가 존재
- 선언 단계 후 초기화 단계를 거침
  - **선언 단계**: 변수 이름을 등록하여 JS 엔진에 변수의 존재를 알림
  - **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당하여 초기화함
- `변수 호이스팅`: 변수 선언문이 코드의 **가장 처음에 위치**한 것처럼 동작하는 JS 고유의 특징
  - 즉, 자바스크립트 엔진은 변수 선언이 어디에 위치하든 다른 코드보다 먼저 실행함
  - 변수 선언 - 런타임 이전, 값의 할당 - 런타임시 실행

### 변수 재할당

변수에 값을 재할당시 이전 값이 저장되어 있던 메모리 공간에 새로운 값을 저장하는 것 ❌

→ 새로운 메모리 공간을 확보하고 해당 메모리 공간에 새로운 값을 저장 🙆‍♀️

이때, 아무도 사용하지 않는 메모리를 해제 해주는 **가비지 콜렉터**를 통해 메모리 누수를 방지

# 05Ch-표현식과 문

## 값

> 표현식이 평가되어 생성된 결과로, 변수에 할당되는 것

## 리터럴

> 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법으로, JS엔진에 의해 런타임에 평가되어 값을 생성

## 표현식

> 값으로 평가될 수 있는 문으로, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조

## 문

> 프로그램을 구성하는 기본 단위이자 최소 실행 단위로, 해당 문들의 집합으로 이루어진 것을 프로그램이라 칭함

- 명령문이라고도 부름
- 선언문, 할당문, 조건문, 반복문 등으로 구분

### 토큰

> 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미

# 06Ch-데이터 타입

- 데이터 타입이 필요한 이유
  - **값 저장시**) JS 엔진은 값의 종류에 따라 정해진 크기의 메모리 공간을 확보
  - **값 참조시**) 한 번에 읽어야할 메모리 공간의 크기를 알아야하는데, 이때 변수에 할당된 타입을 확인함
  - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해
- `심벌 테이블` : 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리하는 자료구조중 하나

## 원시 타입

1. `숫자 타입`: 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
   - 하나의 숫자 타입만 존재(정수, 실수 등 포함하여 하나로만 표현)
   - Infinity: 양의 무한대, -Infinity: 음의 무한대, NaN: 산술 연산 불가
2. `문자열 타입`: 텍스트 데이터를 나타냄
   - 템플릿 리터럴 `${변수} 문자` 와 같은 사용이 가능
   - 문자열끼리 + 연산자를 사용해 연결 가능
3. `불리언 타입`: 논리적 참(true)과 거짓(false)
   - 조건문에서 많이 사용됨
4. `undefined 타입`: var 키워드로 선언된 변수에 암묵적으로 할당되는 값
   - 변수 선언에 의해 확보된 메모리 공간에 처음으로 할당될 때까지 undefined가 반환됨
   - 변수 참조시 undefined가 반환되면 참조한 변수가 선언 이후 초기화되지 않았음을 확인할 수 있음!
   - 때문에 의도적으로 할당시 undefined의 본래 취지를 줄이기 위해 `null`을 할당함
5. `null 타입`: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
   - 변수에 null 할당 === 변수에 값이 없다는 것을 의도적으로 명시할 때 사용
6. `심벌 타입`: 변경 불가능한 원시 타입의 값

   - 다른 값과 중복되지 않는 유일한 값으로, 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
   - Symbol 함수를 호출해 사용
   - 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않음

     ```tsx
     // 심벌 값 생성
     var key = Symbol("key");

     // 객체 생성
     var obj = {};
     ```

## 객체 타입

## 동적 타입과 정적 타입 언어

### 정적 타입

- 변수 선언시 데이터 타입을 사전에 선언해야하는 것으로, 명시적 타입 선언이라 한다
- 변수에 선언한 타입에 해당되는 값만 할당 가능
- `컴파일` 시점에서 타입 체크

### 동적 타입

- 선언이 아닌 할당에 의해 타입이 결정됨
- 재할당에 의해 변수의 타입은 언제든지 변할 수 있음
- `런타임 환경` 때 타입이 결정되고 확인됨
- JS는 동적 타입에 해당되며, 개발자의 의도와 상관없이 JS 엔진에 의해 **타입이 자동 변환**되는 문제점 발생
  - 변수의 개수 최소한으로 줄이기
  - 변수의 유효 스코프 좁히기
  - 전역 변수 사용 줄이기
  - 변수보단 상수를 사용하여 값의 변경을 방지하기

# 07Ch-연산자

- **연산자**: 하나 이상의 표현식을 대상으로 산술, 할당, 비교 등을 수행하여 하나의 값을 만듦
- **피연산자**: 연산의 대상

## 산술 연산자

> 피연산자를 대상으로 수학적 계산을 수행하여 새로운 숫자 값을 만듦

- 산술 연산이 불가능한 경우, NaN을 반환

### 이항 산술 연산자

> 2개의 피연산자를 산술 연산하여 숫자 값을 만드는 것으로 `+`, `-`, `*`, `/`, `%` 등이 있다

### 단항 산술 연산자

> 1개의 피연산자를 산술 연산하여 값을 만드는 것으로 `++`, `--`, `+`, `-(반전한 값)`이 있다

```tsx
var before = 5;

// 선할당 후증가
after = before++;

console.log(before, after); // 6 7

// 선증가 후할당
after = ++before;
console.log(before, after); // 7 7
```

## 할당 연산자

> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당하며, 변수 값이 변하는 부수 효과가 있다

ex) =, +=, -=, \*=, /=, %=

## 비교 연산자

> 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 변환

- if문, for문과 같은 제어문의 조건식에서 주료 사용함

ex) ==, ===, ! =, ! == 이때, ===와 ! ==는 값과 타입까지 비교하므로 더 예측하기 쉬움. 단, NaN의 경우 자신과 일치하지 않는 유일한 값이므로 특정 숫자가 NaN인지를 조사하기 위해선 Number.isNaN을 사용해야한다

## 삼항 조건 연산자

`조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값`과 같은 조건문으로, if-else문을 사용해서도 유사하게 처리할 수 있다. 단, if-else문은 삼항 조건 연산자와 같이 값처럼 사용이 불가능함

```tsx
var a = 2;

// 2 % 2는 0이고 0은 false이므로 암묵적 타입 변환이 됨
var result = a % 2 ? "홀수" : "짝수";

if (x % 2) result = "홀수";
else result = "짝수";
```

## 논리 부정 연산자

- `||` 논리합(OR)
  - 좌항에서 우항으로 평가됨
  - 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략
- `&&` 논리곱(AND)
  - 좌항에서 우항으로 평가됨
  - 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략
- `!` 부정(NOT)
  - 언제나 `boolean` 값을 반환 (ex. !0 → true , !’hi’ → false)

# 08Ch-제어문

> 조건에 따라 코드 블록을 실행하거나 반복 실행할 때 사용하며, 일반적으로 위에서 아래 방향으로 순차적 진행이 된다

## 블록문(= 코드 블록 = 블록)

0개 이상의 문을 중괄호로 묶은 것을 의미

- 하나의 실행 단위로 취급
- 단독 사용보단 제어문이나 함수 정의 시 사용하는 것이 일반적
- 자체 종결성이 있으므로 블록문 끝에는 세미클론을 붙이지 않음

## 조건문

> 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정하며, 조건식은 불리언 값으로 평가될 수 있는 표현식

### if…else 문

> 주어진 조건식의 결과가 참 또는 거짓에 따라 실행할 코드 블록이 결정됨

```tsx
if (조건식) {
  // 참인 경우 해당 코드 블록이 실행
} else {
  // 거짓인 경우 해당 코드 블록이 실행
}
```

- 조건을 추가하고 싶은 경우 `else if` 문을 사용하여 코드 블록을 늘릴 수 있다
- else if, else 문은 옵션
- 대부분의 If…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있음

### switch 문

> 주어진 표현식을 평가한 값과 일치하는 표현식에 해당되는 `case 문`으로 실행 흐름을 옮김

- 상황을 의미하는 표현식 뒤에 콜론 `:` 을 붙이고, 그 뒤에 실행할 문들을 위치시킴
- 표현식과 일치하는 case 문이 없으면 default 문으로 이동하며, default 문은 선택사항이다

```tsx
switch (표현식) {
  case 표현식1:
    // switch문의 표현식과 표현식1이 일치하면 실행될 문
    break;
  case 표현식2:
    // switch문의 표현식과 표현식2이 일치하면 실행될 문
    break;
  default:
  // switch문의 표현식과 일치하는 case문이 없을 경우 실행될 문
}
```

### 풀스루(fall through)

> 각 case에 break 문을 사용하지 않았을 때 발생하며, 표현식과 일치하는 case문 이후의 case문과 default문으로 이동한다

- 여러 개의 case 문을 하나의 조건으로 사용할 때 유용하게 사용이 가능
  ```tsx
  swtich(month) {
  	case 6: case7: case8:
  		vacation = 'summer';
  		break;
  	case 12: case1: case2:
  		vacation = 'winter';
  		break;
  }
  ```

## 반복문

> 조건식의 평과 결과에 따라 코드 블록의 반복 여부를 결정

- 실행 후 조건식을 다시 평가하여 조건식이 거짓일 때까지 코드 블록을 반복함
- JS에서는 for문, while문, do…while문을 제공

### for 문

> 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행

- 반복 횟수가 명확한 상황 위주로 사용

```tsx
for (변수 선언문 또는 할당문; 조건식; 증감식) {
	조건식이 참인 경우 반복 실행될 문
}
```

- **for 문의 실행 순서**: `변수 선언문 > 조건식 > 코드블럭 > 증감식`
- 변수 선언문, 조건식, 증감식 모두 옵션이나 어떠한 식도 사용하지 않으면 **무한루프**가 됨

### while 문

> 주어진 조건식의 평가 결과가 참이면 코드 블럭을 반복 실행

- 반복 횟수가 불명확할 때 주로 사용
- 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환하여 논리적 참, 거짓을 구별

```tsx
while (조건문) {
	// 조건식이 참인 경우 반복 실행
}

while (true) { ... } // 무한루프 예시로, 탈출을 위해선 탈출 조건 설정 및 break문 사용이 필요
```

### do…while 문

> 코드 블록을 먼저 실행하고 조건식을 평가하는 문으로 코드 블록은 무조건 한 번 이상 실행됨

```tsx
do {
  // 최초, 조건식이 참인 경우 반복 실행
} while (조건문);
```

### break 문

> 레이블 문, 반복문(for, for..in, for…of, whilde, do…while) 또는 switch 문의 코드 블록을 탈출하며 이 외의 경우에서 사용시 SyntaxError(문법 에러)가 발생한다

- 레이블 문(label statement): 식별자가 붙은 문으로 프로그램의 실행순서를 제어하는데 사용된다
  - switch문의 case문과 default문도 레이블 문에 해당
  ```tsx
  foo: console.log("foo");
  ```

## 🧐 예시문제

```jsx
const example1 = "JS Deep Dive" - 5;
console.log(example1);
```

<details>
  <summary>정답</summary>
    NaN, 숫자가 아닌 값을 숫자와 연산할 때 포함시키면 NaN이 발생
</details>
<hr>

```jsx
const example2 = 0 / 0;
console.log(example2);
```

<details>
  <summary>정답</summary>
    NaN, 0/0은 정의되지 않은 연산이므로 NaN이 발생
</details>
<hr>

```jsx
const example3 = 1 / 0;
console.log(example3);
```

<details>
  <summary>정답</summary>
    Infinity, 매우 큰 숫자를 0에 가까운 값으로 나눈경우 해당 값이 발생
</details>
<hr>

```jsx
const answer = 5;

switch (answer) {
  case 1:
    console.log("answer는 1");
  case 3:
    console.log("answer는 3");
  case 5:
    console.log("answer는 5");
  case 7:
    console.log("answer는 7");
  default:
    console.log("정답이 없습니다");
}
```

<details>
  <summary>정답</summary>
    answer는 5 <br/>
    answer는 7 <br/>
    정답이 없습니다, <br/>
    answer가 5이므로 case5에 일치하여 실행되나 break문이 없어 이후에 나오는 case 7, default도 연속적으로 실행됨
</details>
