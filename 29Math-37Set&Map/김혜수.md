# 29장 Math

> **Math는 생성자 함수가 아니다 !**

→ Math는 정적 프로퍼티와 정적 메서드만 제공
_(기본적인 내용이므로 가볍게 정리만 진행)_

## 29.1 Math 프로퍼티

### 1. Math.PI (원주율 3.141592)

```jsx
Math.PI; // -> 3.141592653589793
```

## 29.2 Math 메서드

### 1.Math.abs

리턴값 : **절대값**
→ 반드시 0 or 양수

```jsx
Math.abs(-1); // -> 1
Math.abs("-1"); // -> 1
Math.abs(""); // -> 0
Math.abs([]); // -> 0
Math.abs(null); // -> 0
Math.abs(undefined); // -> NaN
Math.abs({}); // -> NaN
Math.abs("string"); // -> NaN
Math.abs(); // -> NaN
```

### 2. Math.round (소수점 이하 반올림)

```jsx
Math.round(1.4); // -> 1
Math.round(1.6); // -> 2
Math.round(-1.4); // -> -1
Math.round(-1.6); // -> -2
Math.round(1); // -> 1
Math.round(); // -> NaN
```

### 3. Math.ceil (소수점 이하 올림)

```jsx
Math.ceil(1.4); // -> 2
Math.ceil(1.6); // -> 2
Math.ceil(-1.4); // -> -1
Math.ceil(-1.6); // -> -1
Math.ceil(1); // -> 1
Math.ceil(); // -> NaN
```

### 4. Math.floor (소수점 이하 내림)

```jsx
Math.floor(1.9); // -> 1
Math.floor(9.1); // -> 9
Math.floor(-1.9); // -> -2
Math.floor(-9.1); // -> -10
Math.floor(1); // -> 1
Math.floor(); // -> NaN
```

### 5. Math.sqrt (제곱근 반환)

```jsx
Math.sqrt(9); // -> 3
Math.sqrt(-9); // -> NaN
Math.sqrt(2); // -> 1.414213562373095
Math.sqrt(1); // -> 1
Math.sqrt(0); // -> 0
Math.sqrt(); // -> NaN
```

### 6. Math.random (임의 난수 반환 → 랜덤 0~1 미만)

```jsx
Math.random(); // 0에서 1 미만의 랜덤 실수(0.8208720231391746)

/*
1에서 10 범위의 랜덤 정수 취득
1) Math.random으로 0에서 1 미만의 랜덤 실수를 구한 다음, 10을 곱해 0에서 10 미만의
랜덤 실수를 구한다.
2) 0에서 10 미만의 랜덤 실수에 1을 더해 1에서 10 범위의 랜덤 실수를 구한다.
3) Math.floor로 1에서 10 범위의 랜덤 실수의 소수점 이하를 떼어 버린 다음 정수를 반환한다.
*/
const random = Math.floor(Math.random() * 10 + 1);
console.log(random); // 1에서 10 범위의 정수
```

### 7. Math.pow (밑, 지수 → 거듭제곱)

```jsx
Math.pow(2, 8); // -> 256
Math.pow(2, -1); // -> 0.5
Math.pow(2); // -> NaN

// ES7 지수 연산자
2 ** (2 ** 2); // -> 16
Math.pow(Math.pow(2, 2), 2); // -> 16
```

### 8. Math.max (최대값 , null → -Infinity)

```jsx
Math.max(1); // -> 1
Math.max(1, 2); // -> 2
Math.max(1, 2, 3); // -> 3
Math.max(); // -> -Infinity

// 배열 요소 중에서 최대값 취득
Math.max.apply(null, [1, 2, 3]); // -> 3

// ES6 스프레드 문법
Math.max(...[1, 2, 3]); // -> 3
```

### 9. Math.min (최소값, null → Infinity)

```jsx
Math.min(1); // -> 1
Math.min(1, 2); // -> 1
Math.min(1, 2, 3); // -> 1
Math.min(); // -> Infinity

// 배열 요소 중에서 최소값 취득
Math.min.apply(null, [1, 2, 3]); // -> 1

// ES6 스프레드 문법
Math.min(...[1, 2, 3]); // -> 1
```

# 30장 Date

## 30.1 Date 생성자 함수

<aside>
💬

**Date는 생성자 함수다 !**
Default : 현재 날짜 + 시간 (정수 값)

</aside>

### 1. new Date()

- Date 생성자 함수를 인수 없이 new 연산자와 함께 호출하면 현재 날짜와 시간을 가지는 Date 객체를 반환
- Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖지만 Date 객체를 호출하면 기본적으로 날짜와 시간 정보를 출력

```jsx
new Date(); // 2023-08-15T12:50:28.906Z
```

- Date 생성자 함수를 **new 연산자 없이 호출**하면 Date 객체를 반환하지 않고 날짜와 시간 정보를 나타내는 문자열을 반환한다.

```jsx
Date(); // Tue Aug 15 2023 21:52:47 GMT+0900 (Korean Standard Time)
```

### 2. new Date(**milliseconds**)

**UTC 기점** 인수로 전달된 밀리초 만큼 경과한 날짜와 시간 Return

```jsx
new Date(0); // 1970-01-01T00:00:00.000Z

new Date(86400000); // 1970-01-02T00:00:00.000Z
```

### 3. new Date(**dateString**)

지정된 날짜와 시간을 Date 객체를 반환한다.
**→ 이때 인수로 전달한 문자열은 `Date.parse` 메서드에 의해 해석 가능한 형식이여야만 한다.**

```jsx
new Date("May 26, 2020 10:00:00"); // 2020-05-26T01:00:00.000Z

new Date("2023/08/15/10:00:00"); // 2023-08-15T01:00:00.000Z
```

### 4. new Date(year, month, day …)

<aside>
💬

**year, month**은 필수 지정 !

</aside>

| **인수**    | **내용**                                                               |
| ----------- | ---------------------------------------------------------------------- |
| year        | 연을 나타내는 1900년 이후의 정수. 0부터 99는 1900부터 1999로 처리된다. |
| month       | 월을 나타내는 0 ~ 11까지의 정수(주의: 0부터 시작, 0 = 1월)             |
| day         | 일을 나타내는 1 ~ 31까지의 정수                                        |
| hour        | 시를 나타내는 0 ~ 23까지의 정수                                        |
| minute      | 분을 나타내는 0 ~ 59까지의 정수                                        |
| second      | 초를 나타내는 0 ~ 59까지의 정수                                        |
| millisecond | 밀리초를 나타내는 0 ~ 999까지의 정수                                   |

```jsx
new Date(2020, 2); // 2020-02-29T15:00:00.000Z
new Date(2020, 2, 26, 10, 0, 0, 0); // 2020-03-26T01:00:00.000Z

// 가독성이 훨씬 좋다.
new Date("2020/2/26/10:00:00:00"); // 2020-02-26T01:00:00.000Z
```

## 30.2 Date 메서드

### 1. Date.now

**1970년 1월 1일 00:00:00(UTC)** 을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환

```jsx
Date.now(); // 1692105562943
```

### 2. Date.parse

**1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정시간(new Date(dateString)) 까지**의 밀리초를 숫자로 반환

```jsx
Date.parse("Jan 2, 1970 00:00:00 UTC"); // 86400000
Date.parse("Jan 2, 1970 00:00:00"); // 54000000
Date.parse("2023/08/16/10:00:00"); // 1692147600000
```

### 3. Date.UTC

**1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환**

- Date.UTC 메서드는 `new Date(year, month[, day…]`와 같은 형식의 인수를 사용해야 한다.

```jsx
Date.UTC(1970, 0, 2); // 86400000
Date.UTC("2020/02/02"); // NaN
```

### 4. Date 메서드들

```jsx
// Date.prototype.getFullYear
// Date 객체의 연도를 나타내는 정수를 반환한다.
new Date("2020/07/23").getFullYear(); // 2020

// Date.prototype.setFullYear
// Date 객체의 연도를 나타내는 정수를 설정한다. 연도 이외에 옵션으로 월, 일도 설정할 수 있다.
const today = new Date();

// 년도 지정
today.setFullYear(2000);
today.getFullYear(); // 2000

// 년도/월/일 지정
today.setFullYear(2023, 0, 2);
today.getFullYear(); // 2023

// Date.prototype.getMonth
// Date 객체의 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다.
new Date("2023/08/14").getMonth(); // 6

// Date.prototype.setMonth
// Date 객체의 월을 나타내는 0 ~ 11의 정수를 설정한다.
const today = new Date();

// 월 지정
today.setMonth(0); // 1월
today.getMonth(); // 0

// 월/일 지정
today.setMonth(11, 1); // 12월 1일
today.getMonth(); // 11

// Date.prototype.getDate
// Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 반환한다.
new Date("2023/08/15").getDate(); // 24

// Date.prototype.setDate
// Date 객체의 날짜(1 ~ 31)를 나타내는 정수를 설정한다.
const today = new Date();

// 날짜 지정
today.setDate(1);
today.getDate(); // 1

// Date.prototype.getDay
// Date 객체의 요일(0 ~ 6)을 나타내는 정수를 반환한다.
new Date("2023/08/15").getDay(); // 2

// Date.prototype.getHours
// Date 객체의 시간(0 ~ 23)을 나타내는 정수를 반환한다.
new Date("2023/08/15/12:00").getHours(); // 12

// Date.prototype.setHours
// Date 객체의 시간(0 ~ 23)을 나타내는 정수를 설정한다
// 시간 이외에 옵션으로 분, 초, 밀리초도 설정할 수 있다.
const today = new Date();

// 시간 지정
today.setHours(7);
today.getHours(); // 0

// 시간/분/초/밀리초 지정
today.setHours(0, 0, 0, 0); // 00:00:00:00
today.getHours();

// Date.prototype.getMinutes
// Date 객체의 분(0 ~ 59)을 나타내는 정수를 반환한다.
new Date("2023/08/15/12:20").getMinutes(); // 20

// Date.prototype.setMinutes
// Date 객체에 분(0 ~ 59)을 나타내는 정수를 설정한다.
// 분 이외에 옵션으로 초, 밀리초도 설정할 수 있다.
const today = new Date();

// 시간 지정
today.setMinutes(5);
today.getMinutes(); // 5

// 시간/분/초/밀리초 지정
today.setMinutes(5, 10, 0); // HH:05:10:00
today.getMinutes(); // 5

// Date.prototype.getSeconds
// Date 객체의 초(0 ~ 59)를 나타내는 정수를 반환한다.
new Date("2023/08/15/12:20:10").getSeconds(); // 10

// Date.prototype.setSeconds
// Date 객체의 초(0 ~ 59)를 나타내는 정수를 설정한다.
const today = new Date();

// 시간 지정
today.setSeconds(5);
today.getSeconds(); // 5

// 시간/분/초/밀리초 지정
today.setSeconds(5, 10); // HH:MM:05:10
today.getSeconds(); // 5

// Date.prototype.getMilliseconds
// Date 객체의 밀리초(0 ~ 999)를 나타내는 정수를 반환한다.
new Date("2023/08/15/12:20:10:150").getMilliseconds(); // 150
```

### 5. Date Time, Timezone 메서드들

```jsx
// Date.prototype.getTime
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 반환한다.
new Date("2023/08/15/12:30").getTime(); // 1692070200000

// Date.prototype.setTime
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 Date 객체의 시간까지 경과된 밀리초를 설정한다.
const today = new Date();

today.setTime(86400000); // 86400000은 1day를 의미

// Date.prototype.getTimezoneOffset
// UTC와 Date 객체에 지정된 locale 시간과의 차이를 분 단위로 반환한다.
// KST는 UTC에 9시간을 더한 시간이다.
const today = new Date();

today.getTimezoneOffset() / 60; // -9

// Date.prototype.toDateString
// 사람이 읽을 수 있는 문자열로 Date 객체의 날짜를 반환한다.
const today = new Date("2023/08/15/12:30");

today.toString(); // Tue Aug 15 2023 12:30:00 GMT+0900 (Korean Standard Time)
today.toDateString(); // Tue Aug 15 2023

// Date.prototype.toTimeString
// 사람이 읽을 수 있는 문자열로 Date 객체의 날짜를 반환한다.
const today = new Date("2023/08/15/12:30");

today.toTimeString(); // 12:30:00 GMT+0900 (Korean Standard Time)

// Date.prototype.toISOString
// ISO 8601 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.
const today = new Date("2023/08/15/12:30");

today.toISOString(); // 2023-08-15T03:30:00.000Z
today.toISOString().slice(0, 10); // 2023-08-15
today.toISOString().slice(0, 10).replace(/-/g, ""); // 20230815

// Date.prototype.toLocaleString
// 인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 문자열을 반환한다.
// 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.
const today = new Date("2023/08/15/12:30");

today.toLocaleString(); // 8/15/2023, 12:30:00 PM
today.toLocaleString("ko-KR"); // 2023. 8. 15. 오후 12:30:00
today.toLocaleString("en-US"); // 8/15/2023, 12:30:00 PM
today.toLocaleString("ja-JP"); // 2023/8/15 12:30:00

// Date.prototype.toLocaleTimeString
// 인수로 전달한 로캘을 기준으로 Date 객체의 시간을 문자열을 반환한다.
// 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.
const today = new Date("2023/08/15/12:30");

today.toLocaleTimeString()); // 12:30:00 PM
today.toLocaleTimeString("ko-KR"); // 오후 12:30:00
today.toLocaleTimeString("en-US"); // 12:30:00 PM
today.toLocaleTimeString("ja-JP"); // 12:30:00
```

# 31장 RegExp

## 1. 정규 표현식이란?

: **일정한 패턴을 가진 문자열의 집합을 표현**하기 위해 사용하는 형식 언어
→ 문자열을 대상으로 패턴 매칭 기능을 제공

```jsx
// 사용자로부터 입력받은 휴대폰 전화번호
const tel = "010-1234-567팔";

// 정규 표현식 리터럴로 휴대폰 전화번호 패턴 정의
const regExp = /^\d{3}-\d{4}-\d{4}$/;

// 패턴 매칭 확인
regExp.test(tel); // false
```

## 2. 정규 표현식의 생성

1. **정규 표현식 리터럴 → 일반적인 방식**
2. **RegExp 생성자 함수**

```jsx
const target = "Is this all there is?";

// 패턴: is
// 플래그: i => 대소문자를 구별하지 않고 검색한다.
const regexp = /is/i;

// test 메서드는 target 문자열에 대해 정규 표현식 regexp의 패턴을 검색하여
// 매칭 결과를 불리언 값으로 반환한다.
regexp.test(target); // true

// RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.
const target = "Is this all there is?";

const regexp = new RegExp(/is/i); // ES6

regexp.test(target); // true
```

## 3. RegExp 메서드

### 1. **RegExp.prototype.exec**

**`exec` 메서드**: 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환

- 매칭 결과가 없을 시 `null` 반환
- `exec` 메서드는 문자열 내의 모든 패턴을 검색하는 `g` 플래그를 지정해도 **첫 번째 매칭 결과만 반환하므로 주의**

```jsx
const target = "Is this all there is?";
const regexp = /is/i;

regexp.exec(target);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]
```

### **2. RegExp.prototype.test**

**`test` 메서드** : 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 **매칭 결과를 불리언으로 반환**

```jsx
const target = "Is this all there is?";
const regexp = /is/i;

regexp.test(target); // true
```

### **3. RegExp.prototype.match**

String 표준 빌트인 객체가 제공하는 `match` 메서드
: 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 **배열로 반환**

```jsx
const target = "Is this all there is?";
const regexp = /is/;

target.match(regexp);

/*
[
  'Is this all there is',
  index: 0,
  input: 'Is this all there is?',
  groups: undefined
]
*/
```

- `exec` 메서드는 문자열 내의 모든 패턴을 검색하는 `g` 플래그를 지정해도 첫 번째 매칭 결과를 반환한다.
  → 하지만 `String.prototype.match` 메서드는 `g` 플래그를 지정되면 모든 매칭 결과를 배여롤 반환한다.

```jsx
const target = "Is this all there is?";
const regexp = /is/g;

target.match(regexp); // ["is", "is"]
```

### 4. 플래그

| **플래그** | **의미**    | **설명**                                                        |
| ---------- | ----------- | --------------------------------------------------------------- |
| i          | Ignore case | 대소문자를 구별하지 않고 패턴을 검색한다.                       |
| g          | Global      | 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다. |
| m          | Multi line  | 문자열의 행이 바뀌더라도 패턴 검색을 계속한다.                  |

```jsx
const target = "Is this all there is?";

// target 문자열에서 is 문자열을 대소문자를 구별하여 한 번 만 검색한다.
target.match(/is/);
// [ 'is', index: 5, input: , groups: undefined ]?'

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 한 번 만 검색한다.
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]

// target 문자열에서 is 문자열을 대소문자를 구별하여 전역 검색한다.
target.match(/is/g); // [ 'is', 'is' ]

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 전역 검색한다.
target.match(/is/gi); // [ 'Is', 'is', 'is' ]
```

## 5. 패턴

> 패턴은 `/` 로 열고 닫으며 문자열의 따옴표는 생략

### 1. 문자열 검색

: 정규 표현식의 패턴에 문자 또는 문자열을 지정하면 검색 대상 문자열에서 패턴으로 지정한 문자 또는 문자열을 검색

```jsx
const target = "Is this all there is?";

// target 문자열에서 is 문자열을 대소문자를 구별하여 한 번 만 검색한다.
target.match(/is/);
// [ 'is', index: 5, input: , groups: undefined ]?'

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 한 번 만 검색한다.
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]

// target 문자열에서 is 문자열을 대소문자를 구별하여 전역 검색한다.
target.match(/is/g); // [ 'is', 'is' ]

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 전역 검색한다.
target.match(/is/gi); // [ 'Is', 'is', 'is' ]
```

### 2. 임의의 문자열 검색

- `.` 은 임의의 문자 한 개를 의미

```jsx
const target = "Is this all there is?";

// 임의의 3자리 문자열을 대소문자를 구별하여 전역 검색한다.
const regExp = /.../g;

console.log(target.match(regExp));

/*
[
  'Is ', 'thi',
  's a', 'll ',
  'the', 're ',
  'is?'
]
*/
```

### 3. 반복 검색

: `{m, n}` 은 **앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열**을 의미

<aside>
💬

**콤마 뒤에 공백**이 있으면 정상 동작하지 않으므로 주의 !

</aside>

```jsx
const target = "A AA B BB Aa Bb AAA";

// A가 최소 1번, 최대 2번 반복되는 문자열을 전역 검색한다.
let regExp = /A{1,2}/g;

target.match(regExp); // [ 'A', 'AA', 'A', 'AA', 'A' ]

// {n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다.
// -> {n} === {n, n}
regExp = /A{2}/g;

target.match(regExp); // ['AA', 'AA']

// {n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.
regExp = /A{2,}/g;

target.match(regExp); // ['AA', 'AAA']

// +는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. +는 {1,}
// 'A'가 최소 한 번 이상 반복되는 문자열('A', 'AA', 'AAA',....)을 전역 검색한다.
regExp = /A+/g;

target.match(regExp); // [ 'A', 'AA', 'A', 'AAA' ]

// ?는 앞선 패턴이 최대 한 번(0번 이상) 이상 반복되는 문자열을 의미한다.
// ?는 {0,1}과 같다.
// 'colo' 다음 'u'가 최대 한 번(0번 포함) 이상 반복되고 'r'이 이어지는
// 문자열 'color', 'colour'를 전역 검색한다.
const target = "color colour";

const regExp = /colou?r/g;
target.match(regExp); // ['color', 'colour']
```

### 4. OR 검색

: `|` 은 OR의 의미

```jsx
const target = "A AA B BB Aa Bb";

// 'A' 또는 'B'를 전역 검색한다.
let regExp = /A|B/g;

target.match(regExp);

/*
[
  'A', 'A', 'A',
  'B', 'B', ,B'
  'A', 'B'
]
*/

// 분해되지 않은 단어 레벨로 검색하기 위해서는 +를 함께 사용한다.
// 'A', 'AA', 'AAA', 'B', 'BB'...
regExp = /A+|B+/g;

target.match(regExp); // [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]

// []내의 문자는 or로 동작한다. 그 뒤에 +를 사용하면 앞선 패턴을 한 번 이상 반복한다.
regExp = /[AB]+/g;

target.match(regExp); // [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]

// 범위를 지정하려면 []내에 -를 사용한다.
const target = "A AA BB ZZ Aa Bb";

// 'A' ~ 'Z'가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[A-Z]+/g;

target.match(regExp); // [ 'A', 'AA', 'BB', 'ZZ', 'A', 'B' ]

// 대소문자를 구별하지 않고 알파벳을 검색하는 방법은 다음과 같다.
const target = "AA BB Aa Bb 12";

// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[A-Za-z]+/g;

target.match(regExp); // [ 'AA', 'BB', 'Aa', 'Bb' ]
```

### + 숫자 검색 방법

```jsx
const target = "AA BB 12,345";

// '0' ~ '9'가 한 번 이상 반복되는 문자열을 전역 검색한다.
let regExp = /[0-9]+/g;

target.match(regExp); // ['12', '345']

// 쉼표를 패턴에 포함한다면
regExp = /[0-9,]+/g;

target.match(regExp); // ['12,345']

// \d는 숫자를 의미한다.
let regExp = /[\d,]+/g;

target.match(regExp); // ['12,345']

// \D는 숫자가 아닌 문자를 의미한다.
// 숫자가 아닌 문자 또는 ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[\D,]+/g;

target.match(regExp); // [ 'AA BB ', ',' ]

// \w는 알파벳, 숫자, 언더스코어를 의미한다.
// \w는 [A-Za-z0-9_]와 같다.
const target = "Aa Bb 12,345 _$%&";

// 알파벳, 숫자, 언더스코어, ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
let regExp = /[\w,]+/g;

target.match(regExp); // [ 'Aa', 'Bb', '12,345', '_' ]

// 알파벳, 숫자, 언더스코어가 아닌 문자 또는 ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[\W,]+/g;

target.match(regExp); // [ ' ', ' ', ',', ' ', '$%&' ]
```

### 5. NOT 검색

: `[…]` 내의 `^`은 not의 의미

```jsx
const target = "AA BB 12 Aa Bb";

// 숫자를 제외한 문자열을 전역 검색한다.
const regExp = /[^\d]+/g;

target.match(regExp); // [ 'AA BB ', ' Aa Bb' ]
```

### 6. 시작 위치로 검색

: `[…]` 밖의 `^`은 문자열의 시작을 의미 **_( 단, `[…]`내의 `^`은 not의 의미 ! )_**

```jsx
const target = "https://naver.com";

// 'https'로 시작되는지 검사한다.
const regExp = /^https/g;

regExp.test(target); // true
```

### 7. 마지막 위치로 검색

: `$`는 문자열의 마지막을 의미

```jsx
const target = "https://naver.com";

// 'com'로 시작되는지 검사한다.
const regExp = /com$/g;

regExp.test(target); // true
```

## **6. 자주 사용하는 정규 표현식**

### **1. 특정 단어로 시작하는지 검사**

```jsx
const url = "https://naver.com";

// 'http://' 또는 'https://'로 시작하는지 검사한다.
const regExp = /^https?:\/\//;

regExp.test(target); // true
```

### **2. 특정 단어로 끝나는지 검사**

```jsx
const fileName = "index.html";

const regExp = /html$/;

regExp.test(fileName); // true
```

### 3. 숫자로만 이루어진 문자열인지 검사

**처음과 끝이 숫자**이고 **최소 한 번 이상 반복**되는 문자열검사는

```jsx
const target = "12345";

const regExp = /^\d+$/;

regExp.test(target); // true
```

### **4. 하나 이상의 공백으로 시작하는지 검사**

`\s` 는 여러 가지 공백 문자(스페이스, 탭 등)를 의미

```jsx
const target = " Hi!";

const regExp = /^[\s]+/;

regExp.test(target); // true
```

### 5. 아이디로 사용 가능한지 검사

알파벳 대소문자 또는 숫자로 시작하고 끝나며 4~10자리인지 검사

```jsx
const id = "abc123";

const regExp = /^[A-Za-z0-9]{4,10}$/;

regExp.test(id); // true
```

### 6. 메일 주소 형식에 맞는지 검사

인터넷 메시지 형식 규약인 **RFC 5322**에 맞는 정교한 패턴 매칭을 사용한다면 무척이나 복잡한 패턴을 가짐

```jsx
const email = "abc123@gmail.com";

const regExp =
  /^[-0-9A-Za-z!#$%&'*+/=?^_`{|}~.]+@[-0-9A-Za-z!#$%&'*+/=?^_`{|}~]+[.]{1}[0-9A-Za-z]/;

regExp.test(email); // true
```

### 7. 휴대폰 번호 형식에 맞는지 검사

```jsx
const cellPhone = "010-1234-5678";

const regExp = /^\d{3,4}-\d{3,4}-\d{4,4}$;

regExp.test(cellPhone); // true
```

### 8. 특수 문자 포함 여부 검사

```jsx
const target = "abc#123";

const regExp = /[^A-Za-z0-9]/gi;

regExp.test(target); // true

// 특수 문자를 제거한다면 String.prototype.replace 메서드를 사용한다.
target.replace(regExp, ""); // abc123
```

# 32장 String 생성자 함수

## 32.1 String 생성자 함수

1. 표준 빌트인 객체인 String 객체는 **생성자 함수 객체**

→ `new` 연산자와 함께 호출하여 `String` 인스턴스를 생성

```jsx
const strObj = new String();
console.log(strObj); // [String: '']
```

1. `String` 생성자 함수의 인수로 문자열을 전달하면서 `new` 연산자와 함께 호출
   → `StringData` 내부 슬롯에 인수로 **전달받은 문자열을 할당한 String 래퍼 객체를 생성**

```jsx
const strObj = new String();
console.log(strObj); // [String: 'Son']
```

1. `string` 래퍼 객체는 배열과 마찬가지로 `length` 프로퍼티와 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로, 각 문자를 프로퍼티 값으로 갖는 유사 배열 객체이면서 이터러블이다.

   → 배열과 유사하게 인덱스를 사용해서 각 문자에 접근할 수 있다.

```jsx
console.log(strObj[0]); // S
```

1. 단, **문자열은 원시 값**이므로 변경할 수 없다. 이때 에러는 발생하지 않는다.

```jsx
const strObj = new String("Son");
strObj[0] = "K";
console.log(strObj); // [String: 'Son']
```

1. `String` 생성자 함수의 인수로 문자열이 아닌 값을 전달하면 인수를 문자열로 강제 변환한 후, `StringData` 내부 슬롯에 변환된 문자열을 할당한 `String` 객체 래퍼를 생성

```jsx
let strObj = new String(123);
console.log(strObj); // [String: '123']

strObj = new String(null);
console.log(strObj); // [String: 'null']
```

1. `new` 연산자를 사용하지 않고 `String` 생성자 함수를 호출하면 `String` 인스턴스가 아닌 **문자열을 반환**한다.

   **→ 명시적으로 타입을 변환**

```jsx
// 숫자 타입 -> 문자열 타입
String(1); // "1"
String(NaN); // "NaN"
String(Infinity); // "Infinity"

// 불리언 타입 -> 문자열 타입
String(true); // "true"
String(false); // "false
```

## 32.2 length 프로퍼티

`length` 프로퍼티는 문자열의 문자 개수를 반환

```jsx
"Hello".length; // 5
"안녕하세요!".length; // 6
```

## 32.3 String 메서드

1. `String` 객체에는 원본 String 래퍼 객체를 직접 변경하는 메서드는 존재 X

   **→ String 객체의 메서드는 언제나 새로운 문자열을 반환한다.**

2. 문자열은 변경 불가능한 원시 값이기 때문에 **String 래퍼 객체도 읽기 전용 객체로 제공**

### **String.prototype.indexOf**

`indexOf` 메서드는 대상 문자열에서 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환

- 검색에 실패하면 -1을 반환

```jsx
const str = "Hello World";

// 문자열 str에서 'l'을 검색하여 첫 번째 인덱스를 반환
str.indexOf("l"); // 2

// 문자열 str에서 'or'을 검색하여 첫 번째 인덱스를 반환
str.indexOf("or"); // 7

// 문자열 str에서 'x'을 검색하여 첫 번째 인덱스를 반환. 검색을 실패하여 -1 반환
str.indexOf("x"); // -1

// indexOf 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

// 문자열 str에서 인덱스 3부터 'l'을 검색하여 첫 번째 인덱스를 반환
str.indexOf("l", 3); // 3
```

- `indexOf` 메서드는 대상 문자열에 특정 문자열이 존재하는지 확인할 때 유용
- ES6에서 도입된 `String.prototype.includes` 메서드를 사용 시 가독성 Good!

```jsx
if (str.indexOf("Hello") !== -1) {
        // 문자열 str에 'Hello'가 포함되어 있는 경우에 처리할 내용
}

if (str.includes("Hello") {
        // 문자열 str에 'Hello'가 포함되어 있는 경우에 처리할 내용
}
```

### **String.prototype.search**

: `search` 메서드는 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환

- 검색에 실패하면 -1을 반환한다.

```jsx
const str = "Hello World";

// 문자열 str에서 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환
str.search(/o/); // 4
str.search(/x/); // -1
```

### **String.prototype.includes**

: ES6에서 도입된 `inlucdes` 메서드는 대상 문자열에 인수로 전달받은 문자열이 포함되어 있는지 확인하여 그 결과를 `true` 또는 `false`로 반환

```jsx
const str = "Hello World";

str.includes("Hello"); // true
str.includes(" "); // true
str.includes("x"); // false
str.includes(); // false
```

- `includes` 메서드에 2번째 인수로 검색을 시작할 인덱스를 전달 O

```jsx
const str = "Hello World";

str.includes("l", 3); // true
str.includes("H", 3); // false
```

### **String.prototype.startsWith**

: ES6에서 도입된 `startsWith` 메서드는 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 `true or false`로 반환

```jsx
const str = "Hello World";

str.startsWith("He"); // true
str.startsWith("x"); // false

// startsWith 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.
str.startsWith(" ", 5); // true
```

### **String.prototype.endsWith**

: ES6에서 도입된 `endsWith` 메서드는 대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 `true or false`로 반환

```jsx
const str = "Hello World";

str.endsWith("ld"); // true
str.endsWith("x"); // false

// endsWith 메서드의 2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.
// 문자열 str의 처음부터 5자리까지("Hello")가 "lo"로 끝나는지 확인
str.startsWith("lo", 5); // true
```

### **String.prototype.charAt**

: `charAt` 메서드는 대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환

```jsx
const str = "Hello";

for (let i = 0; i < str.length; i++) {
  console.log(str.charAt(i)); // H e l l o
}

// 인덱스가 문자열의 범위를 벗어난 경우 빈 문자열을 반환한다.
str.charAt(5); // ""
```

### **String.prototype.substring**

: `substring` 메서드는 대상 문자열에서 **첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자**까지의 부분 문자열을 반환

```jsx
const str = "Hello World";

// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.
str.substring(1, 4); // ell

// substring 메서드의 두번째 인수는 생략할 수 있다.
// 이때, 첫 번째 인수로 전달한 인덱스에 위치하는 문자부터 마지막 문자까지 부분 문자열을 반환한다.
str.substring(1); // ello World
```

<aside>
💬

`substring` 메서드의 **첫 번째 인수는 두 번째 인수보다 큰 정수이어야 정상**이지만 다음과 같이 인수를 전달하여도 정상 동작

</aside>

```jsx
const str = "Hello World";

// 첫 번째 인수 > 두 번째 인수인 경우 두 인수는 교환된다.
str.substring(4, 1); // ell

// 인수 < 0 또는 NaN인 경우 0으로 취급된다.
str.substring(-2); // Hello World

// 인수 > 문자열의 길이인 경우 인수는 문자열의 길이로 취급된다.
str.substring(1, 20); // ello World
str.substring(20); // ""
```

- `String.prototype.indexOf` 메서드와 함께 사용하면 **특정 문자열을 기준으로 앞뒤에 위치한 부분 문자열**을 얻을 수 있다.

```jsx
const str = "Hello World";

// 스페이스를 기준으로 앞에 있는 부분 문자열 취득
str.substring(0, str.indexOf(" ")); // Hello

// 스페이스를 기준으로 뒤에 있는 부분 문자열 취득
str.substring(str.indexOf(" ") + 1, str.length); // World
```

### **String.prototype.slice**

: `slice` 메서드는 `substring` 메서드와 동일하게 동작

단, `slice` 메서드에서는 음수인 인수를 전달할 수 있다.
→ **음수인 인수를 전달하면 대상 문자열의 가장 뒤에서부터 시작하여 문자열을 잘라내어 반환**

```jsx
const str = "Hello World";

str.substring(0, 5); // Hello
str.slice(0, 5); // Hello

str.substring(2); // llo World
str.slice(2); // llo World

// 음수인 경우 0으로 취급된다.
str.substring(-5); // Hello World
// 음수인 경우 뒤에서 5자리를 잘라낸다.
str.slice(-5); // World
```

### **String.prototype.toUpperCase / toLowerCase**

: `toUpperCase`/ `toLowerCase` 메서드는 대상 문자열을 모두 **대문자/소문자**로 변경한 문자열을 반환

```jsx
const str1 = "hello world";

str1.toUpperCase(); // HELLO WORLD

const str2 = "HELLO WORLD";

str2.toLowerCase(); // hello world
```

### **String.prototype.trim**

: `trim` 메서드는 대상 문자열 **앞뒤에 공백 문자가 있을 경우 제거한 문자열을 반환**

```jsx
const str = "      foo    ";

str.trim(); // foo
```

- `String.prototype.trimStart`, `String.prototype.trimEnd`를 사용하면 대상 문자열 앞 또는 뒤에 공백 문자가 있을 경우 이를 제거한 문자열을 반환

```jsx
const str = "      foo    ";

str.trimStart(); // "foo    "
str.trimEnd(); // "      foo"
```

- `String.prototype.replace` 메서드에 정규표현식을 인수로 전달하여 공백 문자를 제거 O

```jsx
const str = "      foo    ";

str.replace(/\s/g, ""); // "foo"
str.replace(/^\s+/g, ""); // "foo    "
str.replace(/\s+$/g, ""); // "      foo"
```

### **String.prototype.repeat**

: `repeat` 메서드는 대상 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반환

- 인수로 전달받은 **정수가 0이면 빈 문자열**을 반환, **음수이면 `RangeError`**를 발생
- 인수를 생략하면 기본값 0이 설정된다.

```jsx
const str = "abc";

str.repeat(); // ""
str.repeat(0); // ""
str.repeat(1); // "abc"
str.repeat(2); // "abcabc"
str.repeat(2.5); // "abcabc" => (2.5 -> 2)
str.repeat(-1); // RangeError
```

### **String.prototype.replace**

: `replace` 메서드는 대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규 표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환한 문자열을 반환

```jsx
const str = "Hello world";

// str에서 첫 번째 인수 'world'를 검색하여 두 번째 인수 'Son'으로 치환한다.
str.replace("world", "Son"); // Hello Son

// 검색된 문자열이 여럿 존재할 경우 첫 번째로 검색된 문자열만 치환한다.
const str = "Hello world world";
str.replace("world", "Son"); // Hello Son world

// 특수한 교체 패턴을 사용할 수 있다.
const str = "Hello world";

// 특수한 교체 패턴을 사용할 수 있다. ($& -> 검색된 문자열
str.replace("world", "<string>$&</string>");

// replace 메서드의 첫 번째 인수로 정규 표현식을 전달할 수 있다.
const str = "Hello hello";

// 'Hello"를 대소문자를 구별하지 않고 전역 검색
str.replace(/hello/gi, "Son"); // Son Son
```

### **String.prototype.split**

: `split`메서드는 대상 문자열에서 **첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환**

- 인수로 빈 문자열을 전달하면 각 문자를 모두 분리하고, 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환

```jsx
const str = "How are you doing?";

// 공백으로 구분
str.split(" "); // [ 'How', 'are', 'you', 'doing?' ]

// \s 는 여러 가지 공백 문자(스페이스, 탭 등)를 의미
str.split(/\s/); // [ 'How', 'are', 'you', 'doing?' ]

// 인수로 빈 문자열을 전달하면 각 문자를 모두 분리
str.split("");
/*
[
  'H', 'o', 'w', ' ', 'a',
  'r', 'e', ' ', 'y', 'o',
  'u', ' ', 'd', 'o', 'i',
  'n', 'g', '?'
]
*/

// 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열 반환
str.split(); // [ 'How are you doing?' ]

// 두 번째 인수로 배열의 길이를 지정
str.split(" ", 2); // [ 'How', 'are' ]

// 문자열 역순 만들기(Array.prototype.reverse, Array.prototype.join)
function reverseString(str) {
  return str.split("").reverse().join("");
}

reverseString(str); // ?gniod uoy era woH
```

# 33장 Symbol

## **33.1 심벌이란?**

: ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값

- 심벌 값은 다른 값과 중복되지 않는 유일무이한 값
- 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용

## **33.2 심벌 값의 생성**

### **1. Symbol 함수**

심벌 값은 `Symbol` 함수를 호출하여 생성

**→ 이때 생성한 심벌 값은 외부로 노출되지 않아 확인할 수 없으며, 다른 값과 절대 중복되지 않는 유일무이한 값**

```jsx
// Symbol 함수를 호출하여 유일무이한 심벌 값을 생성한다.
const mySymbol = Symbol();
console.log(typeof mySymbol); // symbol

// 심벌 값은 외부로 노출되지 않아 확인할 수 없다.
console.log(mySymbol); // Symbol()
```

- `Symbol` 함수는 `String`, `Number`, `Boolean` 생성자 함수와 달리 **`new` 연산자와 함께 호출하지 않는다.**

```jsx
new Symbol(); // TypeError
```

- `Symbol` 함수에는 선택적으로 문자열을 인수로 전달 O
- 이 문자열은 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용
- 심벌 값 생성에 어떠한 영향 X
  → **심벌 값에 대한 설명이 같더라도 생성된 심벌 값은 유일무이한 값이다.**

```jsx
// 심벌 값에 대한 설명이 같더라도 유일무이한 심벌 값을 생성한다.
const mySymbol1 = Symbol("mySymbol");
const mySymbol2 = Symbol("mySymbol");

console.log(mySymbol1 === mySymbol2); // false
```

- 심벌 값도 문자열, 숫자, 불리언과 같이 **객체처럼 접근하면 암묵적으로 래퍼 객체를 생성**한다.

```jsx
const mySymbol = Symbol("mySymbol!!");

// 심벌도 래퍼 객체를 생성한다.
console.log(mySymbol.description); // mySymbol!!
console.log(mySymbol.toString()); // Symbol(mySymbol!!)
```

- 심벌 값은 **암묵적으로 문자열이나 숫자 타입으로 변환 X**

```jsx
const mySymbol = Symbol();

// 심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.
console.log(mySymbol + ""); // TypeError
console.log(+mySymbol); // TypeError
```

- 단, 불리언 타입으로는 암묵적으로 타입 변환 O → `if` 문 등에서 존재 확인 O

```jsx
const mySymbol = Symbol();

// 불리언 타입으로는 암묵적으로 타입 변환된다.
console.log(!!mySymbol); // true

// if 문 등에서 존재 확인이 가능하다.
if (mySymbol) {
  console.log("mySymbol is not empty.");
}
// mySymbol is not empty.
```

### **2. Symbol.for / Symbol.keyFor 메서드**

: `Symbol.for` 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색

- 검색에 성공하면 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환
- 검색에 실패하면 새로운 심벌 값을 생성하여 `Symbol.for` 메서드의 인수로 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌 값을 반환

```jsx
// 전역 심벌 레지스트리에 mySymbol 이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for("mySymbol");
// 전역 심벌 레지스트리에 mySymbol 이라는 키로 저장된 심벌 값이 있으면 해당 심벌 값을 반환
const s2 = Symbol.for("mySymbol");

console.log(s1 === s2); // true
```

- `Symbol` 함수는 호출될 때마다 유일무이한 심벌 값을 생성한다.
  → 이때 자바스크립트 엔진이 관리하는 심벌 값 저장소인 전역 심벌 레지스트리에서 심벌 값을 검색할 수 있는 키를 지정할 수 없으므로 전역 심벌 레지스트리에 등록되어 관리되지 않는다.

- `Symbol.for` 메서드를 사용하면 애플리케이션 전역에서 중복되지 않는 유일무이한 상수인 심벌 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유할 수 있다.
- `Symbol.keyFor` 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

```jsx
// 전역 심벌 레지스트리에 mySymbol 이라는 키로 저장된 심벌 값이 없으면 새로운 심벌 값을 생성
const s1 = Symbol.for("mySymbol");
// 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출
Symbol.keyFor(s1); // mySymbol

// Symbol 함수를 호출하여 생성한 심벌 값은 전역 심벌 레지스트리에 등록되어 관리되지 않는다.
const s2 = Symbol("foo");
Symbol.keyFor(s2); // undefined
```

## **33.3 심벌과 상수**

: 위, 아래, 왼쪽, 아래쪽을 나타내는 상수를 심벌로 정의 시

```jsx
const Direction = {
  UP: Symbol("up"),
  DOWN: Symbol("down"),
  LEFT: Symbol("left"),
  RIGHT: Symbol("right"),
};

const myDirection = Direction.UP;

if (myDirection === Direction.UP) {
  console.log("위로 갑니다."); // 위로 갑니다.
}
```

## **33.4 심벌과 프로퍼티 키**

: 객체의 프로퍼티 키는 빈 문자열을 포함하는 **모든 문자열 또는 심벌 값**으로 만들 수 있으며, **동적으로 생성**할 수도 있다.

### [심벌 값으로 프로퍼티 키를 동적 생성하여 프로퍼티를 만들기]

- 심벌 값을 프로퍼티 키로 사용하려면 **프로퍼티 키로 사용할 심벌 값에 대괄호를 사용**해야 한다.
- 프로퍼티에 접근할 때도 마찬가지로 **대괄호를 사용**해야 한다.

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol.for("mySymbol")]: 1,
};

console.log(obj[Symbol.for("mySymbol")]); // 1
```

**심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다.**

## **33.5 심벌과 프로퍼티 은닉**

<aside>
💬

심벌 값을 프로퍼티 키로 생성한 프로퍼티는 `for…in` , `Object.keys` , `Object.getOwnPropertyNames` 메서드로 찾을 수 없다.

→ 이처럼 심벌 값을 **프로퍼티 키로 사용하여 프로퍼티를 생성**하면 외부에 노출할 필요가 없는 프로퍼티를 은닉할 수 있다.

</aside>

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol("mySymbol")]: 1,
};

for (const key in obj) {
  console.log(key); // 아무것도 출력되지 않는다.
}

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
```

ES6에서 도입된 `Object.getOwnPropertySymbols` 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

```jsx
const obj = {
  // 심벌 값으로 프로퍼티 키를 생성
  [Symbol("mySymbol")]: 1,
};

console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]

// getOwnPropertySymbols 메서드로 심벌 값도 찾을 수 있다.
const symbolKey = Object.getOwnPropertySymbols(obj)[0];
console.log(obj[symbolKey]); // 1
```

# **33.6 심벌과 표준 빌트인 객체 확장**

표준 빌트인 객체는 읽기 전용으로 사용하는 것이 Good!

```jsx
// 표준 빌트인 객체를 확장하는 것은 권장하지 않는다.
Array.prototype.sum = function () {
  return this.reduce((acc, cur) => acc + cur, 0);
}[(1, 2)].sum(); // 3
```

### 🤔 Why? 왜일까?

: **개발자가 직접 추가한 메서드와 미래에 표준 사용으로 추가될 메서드의 이름이 중복될 수 있기 때문**

하지만 중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 표준 사양의 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다.

```jsx
Array.prototype[Symbol.for("sum")] = function () {
  return this.reduce((acc, cur) => acc + cur, 0);
}[(1, 2)][Symbol.for("sum")](); // 3
```

## **33.7 Well-known Symbol**

자바스크립트가 기본 제공하는 빌트인 심벌 값이 있다.

브라우저 콘솔에서 Symbol 함수를 참조하면

자바스크립트가 기본 제공하는 심벌 값을 ECMAScript 사양에서는 **`Well-known Symbol`** 이라 부른다.

`Well-known Symbol` 은 자바스크립트 엔진의 내부 알고리즘에 사용된다.

> 심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입 !

# **34장 이터러블**

## **34.1 이터레이션 프로토콜**

: ES6에서 도입된 **이터레이션 프로토콜**은 순회 가능한 데이터 컬렉션을 만들기 위해 `ECMAScript` 사양에 정의하여 미리 약속한 규칙

이터레이션 프로토콜 = **이터러블 프로토콜** & **이터레이터 프로토콜**

## **1.1 이터러블**

: 이터러블 프로토콜: 준수한 객체 === **이터러블**

→ 이터러블은 `Symbol.iterator`를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.

```jsx
const isIterable = (v) =>
  v !== null && typeof v[Symbol.iterator] === "function";

// 배열, 문자열, Map, Set 등은 이터러블이다.
isIterable([]); // true
isIterable(""); // true
isIterable(new Map()); // true
isIterable(new Set()); // true
isIterable({}); // false
```

- 이터러블은 `for...of` 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.

```jsx
const array = [1, 2, 3];

// 배열은 Array.prototype 의 Symbol.iterator 메서드를 상속받은 이터러블이다.
console.log(Symbol.iterator in array); // true

// 이터러블인 배열은 for...of 문으로 순회 가능하다.
for (const item of array) {
  console.log(item);
}

// 이터러블인 배열은 스프레드 문법의 대상으로 사용할 수 있다.
console.log([...array]); // [1, 2, 3]

// 이터러블인 배열은 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.
const [a, ...rest] = array;
console.log(a, rest); // 1, [2, 3]
```

- `Symbol.iterator` 메서드를 **직접 구현하지 않거나 상속받지 않은 일반 객체**는 이터러블 프로토콜을 준수한 이터러블 X
  → 일반 객체는 `for...of` 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.

```jsx
const obj = { a: 1, b: 2 };

// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.
// 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.
console.log(Symbol.iterator in obj); // false

// 이터러블이 아닌 일반 객체는 for...of 문으로 순회할 수 없다.
for (const item of obj) {
  // TypeError
  console.log(item);
}

// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.
const [a, b] = obj; // TypeError
```

- 2020년 7월 ~, _스프레드 프로퍼티 제안은 일반 객체에 스프레드 문법의 사용을 허용_

```jsx
const obj = { a: 1, b: 2 };

// 스프레드 프로퍼티 제안은 객체 리터럴 내부에서 스프레드 문법의 사용을 허용한다.
console.log({ ...obj }); // { a: 1, b: 2 }
```

### **이터레이터**

: 이터러블의 `Symbol.iterator` 메서드가 반환한 이터레이터는 `next` 메서드를 갖는다.

```jsx
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터리이터를 반환한다.
const iterator = array[Symbol.iterator]();

// Symbol.iterator 메서드가 반환한 이터리이터는 next 메서드를 갖는다.
console.log("next" in iterator); // true
```

- `next` 메서드를 호출하면 이터러블을 순차적으로 **한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환**

```jsx
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터리이터를 반환한다.
const iterator = array[Symbol.iterator]();

// 이터레이터 리절트 객체는 value 와 done 프로퍼티를 갖는 객체다.
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());

/*
    { value: 1, done: false }
    { value: 2, done: false }
    { value: 3, done: false }
    { value: undefined, done: true }
*/
```

## **34.2 빌트인 이터러블**

: 표준 빌트인 객체 === 빌트인 이터러블

- Array
- String
- Map
- Set
- TypedArray
- arguments
- DOM 컬렉션

## **34.3 for…of 문**

- `for...of` 문은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당
- `for...of` 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 `for...of` 문의 변수에 할당한다.
- 이터레이터 리절트 객체의 done 프포퍼티 값이 false이면 이터러블의 순회를 계속하고 true면 이터러블의 순회를 중단한다.

```jsx
for (const item of [1, 2, 3]) {
  // item 변수에 순차적으로 1, 2, 3 이 할당
  console.log(item); // 1, 2, 3
}
```

### [내부동작 설명하기]

```jsx
// 이터러블
const iterable = [1, 2, 3];

// 이터러블의 Symbol.iterator 메서드를 호출하여 이터레이터를 생성한다.
const iterator = iterable[Symbol.iterator]();

for (;;) {
  // 이터레이터의 next 메서드를 호출하여 이터러블을 순회한다.
  const res = iterator.next();

  // next 메서드가 반환한 이터레이터 리절트 객체의 done 프로퍼티 값이 true 이면 이터러블의 순회를 중단한다.
  if (res.done) break;

  // 이터레이터 리절트 객체의 value 프로퍼티 값을 item 변수에 할당한다.
  const item = res.value;
  console.log(item); // 1, 2, 3
}
```

## **34.4 이터러블과 유사 배열 객체**

: 유사 배열 객체는 `length` 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있고, 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가지므로 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.

```jsx
// 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.
for (let i = 0; i < arrayLike.length; i++) {
  // 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.
  console.log(arrayLike[i]); // 1 2 3
}
```

- 유사 배열 객체는 이터러블이 아닌 일반 객체다.
  → 유사 배열 객체에는 Symbol.iterator 메서드가 없기 때문에 `for...of` 문으로 순회할 수 없다.

```jsx
for (const item of arrayLike) {
  console.log(item); // TypeError
}
```

ES6에서 도입된 `Array.from` 메서드를 사용하여 배열로 간단히 변환할 수 있다.

`Array.from` 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.

```jsx
// 유사 배열 객체
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

// Array.from은 유사 배열 객체 또는 이터러블을 배열로 반환한다.
const arr = Array.from(arrayLike);
console.log(arr); // [1, 2, 3]
```

## **34.5 이터레이션 프로토콜의 필요성**

이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 **데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.**

## **34.6 사용자 정의 이터러블**

### **사용자 정의 이터러블 구현**

```jsx
// 피보나치 수열을 구현한 사용자 정의 이터러블
const fibonacci = {
  // Symbol.iterator 메서드를 구현하여 이터러블 프로토콜을 준수한다.
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10; // 수열의 최대값

    // next 메서드는 이터레이터 리절트 객체를 반환한다.
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        // 이터레이터 리절트 객체를 반환한다.
        return { value: cur, done: cur >= max };
      },
    };
  },
};

// 이터러블인 fibonacci 객체를 순회할 때마다 next 메서드가 호출한다.
for (const num of fibonacci) {
  console.log(num); // 1 2 3 5 8
}
```

- 이터러블은 `for...of` 문뿐만 아니라 스프레드 문법, 배열 디스트럭처링 할당에도 사용 O

```jsx
// 이터러블은 스프레드 문법의 대상이 될 수 있다.
const arr = [...fibonacci];
console.log(arr); // [1, 2, 3, 5, 8]

// 이터러블은 배열 디스트럭처링 할당의 대상이 될 수 있다.
const [first, second, ...rest] = fibonacci;
console.log(first, second, rest); // 1 2 [3, 5, 8]
```

### **이터러블을 생성하는 함수**

수열의 최대값을 인수로 전달받아 이터러블을 반환하는 함수도 가능

```jsx
// 피보나치 수열을 구현한 사용자 정의 이터러블
const fibonacci = function (max) {
  let [pre, cur] = [0, 1];

  // Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
  return {
    [Symbol.iterator]() {
      return {
        next() {
          [pre, cur] = [cur, pre + cur];
          return { value: cur, done: cur >= max };
        },
      };
    },
  };
};

for (const num of fibonacci(10)) {
  console.log(num); // 1 2 3 5 8
}
```

### **이터러블이면서 이터레이터인 객체를 생성하는 함수**

이터러블이면서 이터레이터 객체를 생성하여 반환하는 함수는

```jsx
const fibonacci = function (max) {
    let [pre, cur] = [0, 1];

    // Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
    return {
        [Symbol.iterator]() {
            return this;
        },
        // next 메서드는 이터레이터 리절트 객체를 반환
        next() {
            [pre, cur] = [cur, pre + cur];
            return {value: cur, done: cur >= max};
        }

    }
};

// iter는 이터러블이면서 이터레이터
let iter = fibonacci(10);

for (const num of iter) {
    console.log(num); // 1 2 3 5 8
}

iter = fibonacci(10);

// iter는 이터레이터이므로 이터레이션 리절트 객체를 반환하는 next 메서드르 소유한다.
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());

/*
    { value: 1, done: false }
    { value: 2, done: false }
    { value: 3, done: false }
    { value: 5, done: false }
    { value: 8, done: false }
    { value: 13, done: true }
/*
```

### **무한 이터러블과 지연 평가**

```jsx
const fibonacci = function () {
  let [pre, cur] = [0, 1];

  // Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
  return {
    [Symbol.iterator]() {
      return this;
    },
    // next 메서드는 이터레이터 리절트 객체를 반환
    next() {
      [pre, cur] = [cur, pre + cur];
      // 무한을 구현하므로 done 프로퍼티를 생략
      return { value: cur };
    },
  };
};

for (const num of fibonacci()) {
  if (num > 10000) break;
  console.log(num); // 1 2 3 5 8... 4181 6765
}

// 배열 디스트럭처링 할당을 통해 무한 이터러블에서 3개의 요소만 취득한다.
const [f1, f2, f3] = fibonacci();
console.log(f1, f2, f3); // 1 2
```

# 35장 스프레드 문법

ES6에서 도입된 스프레드 문법 `...` 은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

스프레드 문법을 사용할 수 있는 대상은 `for...of` 문으로 순회할 수 있는 이터러블에 한정됨

```jsx
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다.(-> 1, 2, 3)
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(...'Hello'); // H e l l o

// Map과 Set은 이터러블이다.
console.log(
  ...new Map([
    ['a', '1'],
    ['b', '2'],
  ]);
) // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 }); // TypeError
```

- 스프레드 문법의 결과는 값이 아니라 변수에 할당할 수 X

```jsx
// 스프레드 문법의 결과는 값이 아니다.
const list = ...[1, 2, 3]; // SyntaxError
```

## **35.1 함수 호출문의 인수 목록에서 사용하는 경우**

```jsx
const arr = [1, 2, 3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
const max = Math.max(arr); // NaN
```

( `Math.max` 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수 )

- `Math.max` 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할 수 없어 `NaN`을 반환한다.

→ 이 같은 문제를 해결하기 위해 배열을 펼쳐서 요소들을 개별적인 값들의 목록으로 만들고 `Math.max` 메서드의 인수로 전달해야 한다.

```jsx
var arr = [1, 2, 3];

var max = Math.max.apply(null, arr); // 3

// 스프레드 문법을 사용한다면
const arr = [1, 2, 3];

const max = Math.max(...arr); // 3
```

스프레드 문법은 `Rest` 파라미터와 형태가 동일하여 혼동할수 있으므로 주의할 필요가 있다.

```jsx
// Rest 파라미터는 인수들의 목록을 배열로 전달 받는다.
function foo(...rest) {
    console.log(rest); // 1, 2, 3 -> [1, 2, 3]
}

// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.
// 1, 2, 3
foo(...[1, 2, 3];
```

## **2. 배열 리터럴 내부에서 사용하는 경우**

ES5에서 사용하는 방식보다 좀 더 간결하고 가독성좋게 표현 O

### **1. concat**

```jsx
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]

// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4];
```

### **2 splice**

```jsx
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

// 세 번째 인수 arr2를 해체하여 전달해야 한다.
// 그렇지 않으면 arr1에 arr2 배열 자체가 추가된다.
arr1.splice(1, 0, arr2);

// 기대값은 [1, 2, 3, 4]지만
console.log(arr1); // [1, [2, 3], 4];

// 다음처럼 코드가 추가되어야 한다.
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));
console.log(arr1); // [1, 2, 3, 4]
```

**스프레드 문법** 사용 시 → 더욱 간결하고 가독성 좋게 표현 O

```jsx
let arr1 = [1, 4];
let arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4];
```

### **3. 배열 복사**

ES5에선 배열을 복사하려면 `slice` 메서드를 사용해야 한다.

```jsx
var origin = [1, 2];
var copy = origin.slice();

console.log(copy); // [1, 2]
console.log(origin === copy); // false
```

→ **스프레드 문법** 사용

```jsx
let origin = [1, 2];
let copy = [...origin];

console.log(copy); // [1, 2];
console.log(origin === copy); // false
```

### **4. 이터러블을 배열로 변환**

ES5에서 이터러블을 배열로 변환하려면 `apply` 또는 `call` 메서드를 사용하여 `slice` 메서드를 호출해야 한다.

```jsx
function sum() {
  // 이터러블이면서 유사 배열 객체인 arguments 를 배열로 변환
  var args = Array.prototype.slice.call(arguments);

  return args.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3)); // 6
```

- 이터러블뿐만 아니라 이터러블이 아닌 **유사 배열 객체도 배열로 변환 O**

```jsx
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

const arr = Array.prototype.slice.call(arrayLike); // [1, 2, 3]
console.log(Array.isArray(arr)); // true
```

- **스프레드 문법** 사용 시 더 간편하게 이터러블을 배열로 변환 O

```jsx
function sum() {
  // 이터러블이면서 유사 배열 객체인 arguments 를 배열로 변환
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

- 이보다 더 나은 방법은 `Rest` 파라미터를 사용하는 것이다.

```jsx
const sum = (...args) => args.reduce((pre, cur) => pre + cur, 0);

console.log(sum(1, 2, 3));
```

<aside>
💬

단, 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.

</aside>

```jsx
const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
};

const arr = [...arrayLike]; // TypeError
```

- 이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 ES6에서 도입된 `Array.from` 메서드를 사용

```jsx
// Array.from 은 유사 배열 객체 또는 이터러블을 배열로 변환한다.
Array.from(arrayLike); // [1, 2, 3]
```

## **35.3 객체 리터럴 내부에서 사용하는 경우**

스프레드 문법의 대상은 이터러블이어야 하지만 **스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용**

```jsx
// 스프레드 프로퍼티
// 객체 복사(얕은 복사)
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2 }
console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }
```

- 스프레드 프로퍼티는 `Object.assign` 메서드를 대체할 수 있는 간편한 문법

```jsx
// 객체 병합, 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, Y: 2 }, z: 0 };
console.log(added); // { x: 1, Y: 2, z: 0 }
```

# 36장 디스트럭처링 할당

: 구조화된 배열과 같은 이터러블 또는 객체를 `destructuring`하여 1개 이상의 변수에 개별적으로 할당하는 것

<aside>
💬

배열과 같은 **이터러블** 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용 !

</aside>

## **36.1 배열 디스트럭처링 할당**

ES5에서 구조화된 배열을 디스트럭처링 하여 1개 이상의 변수에 할당하는 방법

```jsx
var arr = [1, 2, 3];

var one = arr[0];
var two = arr[1];
var three = arr[2];

console.log(one, two, three); // 1 2 3
```

- **ES6 배열 디스트럭처링 할당의 대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다.**

```jsx
const arr = [1, 2, 3];

const [one, two, three] = arr;

console.log(one, two, three); // 1 2 3
```

- 배열 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 값을 할당받을 변수를 선언해야 한다.
  → 이때 **배열 리터럴 형태**로 선언한다.

```jsx
const [x, y] = [1, 2];

// 우변에 이터러블을 할당하지 않으면 에러가 발생한다.
const [x, y]; // SyntaxError

const [a, b] = {}; // TypeError
```

- 배열 디스트럭처링 할당의 변수 선언문은 다음처럼 선언과 할당을 분리 O
- `const` 키워드는 변수를 선언할 수 없으므로 권장 X

```jsx
let x, y;
[x, y] = [1, 2];
```

- 배열 디스트럭처링 할당의 기준은 **배열의 인덱스**다.
  → 즉, **순서대로 할당**된다.

```jsx
const [a, b] = [1, 2];
console.log(a, b); // 1 2

const [c, d] = [1];
console.log(c, d); // 1 undefined

const [e, f] = [1, 2, 3];
console.log(e, f); // 1 2

const [g, , h] = [1, 2, 3];
console.log(g, h); // 1 3
```

- 배열 디스트럭처링 할당을 위한 변수에 **기본값을 설정 O**

```jsx
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3

// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
console.log(e, f, g); //  1 2 3
```

배열 디스트럭처링 할당을 위한 변수에 `Rest` 파라미터와 유사하게 `Rest` 요소를 사용 O

```jsx
// Rest 요소
const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [2, 3]
```

## **36.2 객체 디스트럭처링 할당**

ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링하여 변수에 할당하기 위해서는 **프로퍼티 키**를 사용해야 한다.

```jsx
var user = {
  firstName: "HS",
  lastName: "Kim",
};

var firstName = user.firstName;
var lastName = user.lastName;

console.log(firstName, lastName); // HS Kim
```

ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다.

객체 디스트럭처링 할당의 대상은 객체이어야 하며, **할당 기준은 프로퍼티 키다.**

```jsx
const user = {
  firstName: "HS",
  lastName: "Kim",
};

// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.
const { lastName, firstName } = user;

console.log(firstName, lastName); // HS Kim
```

- 객체 디스트럭처링 할당을 위해서는 **할당 연산자 왼쪽에 프로퍼티 값을 할당받을 변수를 선언**해야 한다.

```jsx
const { lastName, firstName } = { firstName: "HS", lastName: "Kim" };
```

- **우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생**

```jsx
const {lastName, firstName}; // SyntaxError

const {lastName, firstName} = null; // TypeError
```

- 객체 리터럴 형태로 선언한 `lastName`, `firstName`
  → **프로퍼티 축약 표현**을 통해 선언한 것

```jsx
const { lastName, firstName } = user;
// 위와 아래는 동치다.
const { lastName: lastName, firstName: firstName } = user;
```

### 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면

```jsx
const user = {
  firstName: "HS",
  lastName: "Kim",
};

// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다.
// 프로퍼티 키를 변수 선언과 함께 따로 할당한다.
const { lastName: ln, firstName: fn } = user;

console.log(fn, ln); // HS Kim
```

- 객체 디스트럭처링 할당을 위한 변수에 **기본값을 설정 O**

```jsx
const { firstName = "Cloud", lastName } = { lastName: "Kim" };
console.log(firstName, lastName); // Cloud Kim

const { lastName: ln, firstName: fn = "HS" } = { lastName: "Kim" };
console.log(fn, ln); // HS Kim
```

- 객체 디스트럭처링 할당은 **객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용**

```jsx
const str = "Hello";
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5

const todo = { id: 1, content: "HTML", completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

- 객체 디스트럭처링 할당은 객체를 인수로 전달받은 함수의 매개변수에도 사용가능

```jsx
function printTodo(todo) {
  console.log(
    `할일 ${todo.content}은 ${todo.completed ? "완료" : "비완료"} 상태입니다.`
  );
}

printTodo({ id: 1, content: "HTML", completed: true });
// 할일 HTML은 완료 상태입니다.
```

- 매개변수 `todo`에 객체 디스트럭처링 할당을 사용 시 더 간단하고 가독성 좋게 표현 가능 !

```jsx
function printTodo(content, completed) {
  console.log(`할일 ${content}은 ${completed ? "완료" : "비완료"} 상태입니다.`);
}

printTodo({ id: 1, content: "HTML", completed: true });
// 할일 HTML은 완료 상태입니다.
```

- 배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다…

```jsx
const todos = [
  { id: 1, content: "HTML", completed: true },
  { id: 2, content: "CSS", completed: false },
  { id: 3, content: "JS", completed: false },
];

// todos 배열의 두 번째 요소인 객체로부터 id 프로퍼티만 추출한다.
const [, { id }] = todos;
console.log(id); // 2
```

### 중첩 객체의 경우는 다음과 같이 사용 !

```jsx
const user = {
  name: "Sunny",
  address: {
    zipCode: "01023",
    city: "Seoul",
  },
};

// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출한다.
const {
  address: { city },
} = user;
console.log(city); // Seoul
```

객체 디스트럭처링 할당을 위한 `Rest` 파라미터나 `Rest` 요소와 유사하게 Rest 프로퍼티 `...` 을 사용할 수 있다.

```jsx
const { x, ...rest } = { x: 1, y: 2, z: 3 };
console.log(x, rest); // 1 {y: 2, z: 3}
```

# 37장 Set & Map

## **37.1 Set**

**: Set 객체는 중복되지 않는 유일한 값들의 집합**

### **1. Set 객체의 생성**

```jsx
const set = new Set();
console.log(set); // Set(0) {}
```

**Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다.
→ 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장 X**

```jsx
const set1 = new Set([1, 2, 3, 3]);
console.log(set1); // Set(3) {1, 2, 3}

const set2 = new Set("hello");
console.log(set2); // Set(4) { 'h', 'e', 'l', 'o' }
```

중복을 허용하지 않는 `Set` 객체의 특성을 활용하여 **배열에서 중복된 요소를 제거 O**

```jsx
const array = [2, 1, 2, 3, 4, 3, 4];

const uniq1 = (array) => array.filter((v, i, self) => self.indexOf(v) === i);
console.log(uniq1(array)); // [2, 1, 3, 4]

const uniq2 = (array) => [...new Set(array)];
console.log(uniq2(array)); // [2, 1, 3, 4]
```

### **2. 요소 개수 확인**

`Set` 객체의 요소 개수를 확인할 때는 `Set.prototype.size` 프로퍼티를 사용한다.

```jsx
const { size } = new Set([2, 1, 3, 3]);
console.log(size); // 3
```

`size` 프로퍼티는 `getter` 함수만 존재하는 접근자 프로퍼티다.

`size` 프로퍼티에 숫자를 할당하여 `Set` 객체의 요소 개수를 변경할 수 없다.

```jsx
const set = new Set([1, 2, 3]);

set.size = 10; // 무시됨.
console.log(set.size);
```

### **3. 요소 추가**

`Set` 객체에 요소를 추가할 때는 `Set.prototype.add` 메서드를 사용한다.

```jsx
const set = new Set();
console.log(set); // Set(0) {}

set.add(1);
console.log(set); // Set(1) {1}

// add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다.
// add 메서드를 연속적으로 호출이 가능하다.
set.add(1).add(2);
console.log(set); // Set(2) { 1, 2 }

----
const set = new Set();

// 일치 비교 연산자 ===을 사용하면 NaN과 NaN을 다르다고 평가한다.
// Set 객체는 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다.
// +0, -0은 일치 비교 연산자 ===와 마찬가지로 같다고 평가한다.
console.log(NaN === NaN); // false
console.log(+0 === -0); // true

set.add(NaN).add(NaN);
console.log(set); // Set(1) { NaN }

set.add(0).add(-0);
console.log(set); // Set(1) { 0 }
```

- Set 객체는 객체나 배열과 같이 자바스크립트의 모든 값을 요소로 저장 O

```jsx
const set = new Set();
set
  .add(1)
  .add("a")
  .add(true)
  .add(undefined)
  .add(null)
  .add({})
  .add([])
  .add(() => {});

console.log(set);

/*
    Set(8) {
      1,
      'a',
      true,
      undefined,
      null,
      {},
      [],
      [Function (anonymous)]
    }
*/
```

### **4. 요소 존재 여부 확인**

`Set` 객체에 특정 요소가 존재하는지 확인하려면 `Set.prototype.has` 메서드를 사용

→ `has` 메서드는 특정 요소의 존재 여부를 나타내는 **불리언 값을 반환**

```jsx
const set = new Set([1, 2, 3]);

console.log(set.has(2)); // true
console.log(set.has(4)); // false
```

### **5. 요소 삭제**

Set 객체에 특정 요소를 삭제하려면 `Set.prototype.delete` 메서드를 사용

- `delete` 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다.
- `delete` 메서드는 인덱스가 아니라 삭제하려는 요소값을 인수로 전달해야 한다.

```jsx
const set = new Set([1, 2, 3]);

// 요소 2 삭제
set.delete(2);
console.log(set); // Set(2) { 1, 3 }

// 존재하지 않는 요소 0을 삭제하면 무시된다.
set.delete(0);
console.log(set); // Set(2) { 1, 3 }
```

### **6. 요소 일괄 삭제**

Set 객체에 모든 요소를 일괄 삭제하려면 `Set.prototype.clear` 메서드를 사용한다.

`clear` 메서드는 언제나 `undefined`를 반환한다.

```jsx
const set = new Set([1, 2, 3]);

set.clear();
console.log(set); // Set(0) {}
```

### **7. 요소 순회**

Set 객체에 요소를 일괄 순회하려면 `Set.prototype.forEach` 메서드를 사용

Array의 `forEach` 메서드처럼 3개의 인수와 함께 콜백 함수를 전달

- 현재 순회 중인 요소값
- 현재 순회 중인 요소값
- 현재 순회 중인 Set 객체 자체

```jsx
const set = new Set([1, 2, 3]);

set.forEach((v, v2, set) => console.log(v, v2, set));

/*
    1 1 Set(3) { 1, 2, 3 }
    2 2 Set(3) { 1, 2, 3 }
    3 3 Set(3) { 1, 2, 3 }
*/
```

<aside>
💬

**Set 객체는 이터러블이다 !**

</aside>

- `for…of` 문
- 스프레드 문법
- 배열 디스트럭처링

```jsx
const set = new Set([1, 2, 3]);

// for...of 문
for (const value of set) {
  console.log(value); // 1 2 3
}

// 스프레드 문법
console.log([...set]); // [1, 2, 3]

// 배열 디스트럭처링
const [a, ...rest] = set;
console.log(a, rest); // 1 [2, 3]
```

- Set 객체는 요소의 순서에 의미를 갖지 않지만 `Set` 객체를 순회하는 순서는 요소가 추가된 순서를 따른다.

### **8. 집합 연산**

: Set 객체는 수학적 집합을 구현하기 위한 자료구조

집합 연산을 수행하는 프로토타입 메서드를 구현하면 ? (아래에 계속~)

### **교집합**

: 집합 A와 집합 B의 공통 요소로 구성

```jsx
Set.prototype.intersection = function (set) {
  const result = new Set();

  for (const value of set) {
    // 2개의 set의 요소가 공통되는 요소이면 교집합의 대상이다.
    if (this.has(value)) {
      result.add(value);
    }
  }

  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.intersection(setB)); // Set(2) { 2, 4 }
console.log(setB.intersection(setA)); // Set(2) { 2, 4 }

// 다음과 같은 방법으로도 가능하다.
Set.prototype.intersection = function (set) {
  return new Set([...this].filter((v) => set.has(v)));
};
```

### **합집합**

: 집합 A와 집합 B의 중복 없는 모든 요소로 구성

```jsx
Set.prototype.usage = function (set) {
  // this(Set 객체 복사)
  const result = new Set(this);

  for (const value of set) {
    // 중복된 요소는 포함되지 않도록 한다.
    result.add(value);
  }

  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.usage(setB)); // Set(4) { 1, 2, 3, 4 }
console.log(setB.usage(setA)); // Set(4) { 2, 4, 1, 3 }

// 다음과 같은 방법으로도 가능하다.
Set.prototype.usage = function (set) {
  return new Set([...this, ...set]);
};
```

### **차집합**

: A-B 는 집합 A에는 존재하지만 집합 B에는 존재하지 않는 요소로 구성

```jsx
Set.prototype.difference = function (set) {
  // this(Set 객체 복사)
  const result = new Set(this);

  for (const value of set) {
    // 어느 한쪽 집합에는 존재하지만 다른 한쪽 집합에는 존재하지 않는 요소로 구성한 집합이다.
    result.delete(value);
  }

  return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.difference(setB));
console.log(setB.difference(setA));

// 다음과 같은 방법으로도 가능하다.
Set.prototype.difference = function (set) {
  return new Set([...this].filter((v) => !set.has(v)));
};
```

### **부분집합과 상위 집합**

```jsx
Set.prototype.isSuperset = function (subset) {
  for (const value of subset) {
    // superset의 모든 요소가 subset의 모든 요소를 포함하는지 확인
    if (!this.has(value)) {
      return false;
    }
  }
  return true;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.isSuperset(setB));
console.log(setB.isSuperset(setA));

// 다음과 같은 방법으로도 가능하다.
Set.prototype.isSuperset = function (subset) {
  const supersetArr = [...this];
  return [...subset].every((v) => supersetArr.includes(v));
};
```

## **37.2 Map**

**: Map 객체는 키와 쌍으로 이루어진 컬렉션이다.**
 - Map 객체는 객체와 유사하나 다음과 같은 차이가 있다.

| **구분**               | **객체**                | **Map 객체**          |
| ---------------------- | ----------------------- | --------------------- |
| 키로 사용할 수 있는 값 | 문자열 또는 심벌 값     | 객체를 포함한 모든 값 |
| 이터러블               | X                       | O                     |
| 요소 개수 확인         | Object.keys(obj).length | map.size              |

### **1. Map 객체의 생성**

- Map 객체는 Map 생성자 함수로 생성
- Map 생성자 함수에 인수를 전달하지 않으면 빈 Map이 생성

```jsx
const map = new Map();
console.log(map); // Map(0) {}
```

- Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다.
- 인수로 전달되는 이터러블은 키와 쌍으로 이루어진 요소로 구성되어야 한다.

```jsx
const map1 = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);
console.log(map1); // Map(2) { 'key1' => 'value1', 'key2' => 'value2' }

const map2 = new Map([1, 2]); // TypeError
```

- **중복된 키는 Map 객체에 요소로 저장되지 않는다.**

```jsx
const map = new Map([
  ["key1", "value1"],
  ["key1", "value2"],
]);
console.log(map); // Map(1) { 'key1' => 'value2'}
```

### **2. 요소 개수 확인**

Map 객체의 요소 개수를 확인할 때는 `Map.prototype.size` 프로퍼티를 사용

```jsx
const { size } = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);
console.log(size); // 2
```

- size 프로퍼티는 `getter` 함수만 존재하는 접근자 프로퍼티
- size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경 X

```jsx
const map = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);

map.size = 10;
console.log(map.size); // 2
```

### **요소 추가**

: Map 객체의 요소를 추가할 때는 `Map.prototype.set` 프로퍼티를 사용

```jsx
const map = new Map();
console.log(map); // Map(0) {}

map.set("key1", "value1");
console.log(map); // Map(1) { 'key1' => 'value1' }

// set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다.
// set 메서드는 연속적으로 호출할 수 있다.
map.set("key1", "value1").set("key2", "value2");
console.log(map); // Map(2) { 'key1' => 'value1', 'key2' => 'value2' }

// Map 객체에 중복된 키를 갖는 요소의 추가는 허용되지 않는다.
// 에러는 발생하지 않고 무시한다.
map.set("key1", "value1").set("key1", "value2");
console.log(map); // Map(1) { 'key1' => 'value2' }

// NaN, +0,, -0도 Set과 마찬가지로 같다고 평가하여 중복 추가를 허용하지 않는다.
map.set(NaN, "value1").set(NaN, "value2");
console.log(map); // Map(1) { NaN => 'value2' }

map.set(0, "value1").set(-0, "value2");
console.log(map); // Map(1) { 0 => 'value2' }
```

- 객체는 문자열 또는 심벌 값만 키로 사용 O
- Map 객체는 키 타입에 제한이 없다.
  → 객체를 포함한 모든 값을 키로 사용 O

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");
console.log(map);

/*
    Map(2) 
    {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
*/
```

### **4. 요소 취득**

: Map 객체에서 특정 요소를 취득하려면 `Map.prototype.get` 메서드를 사용

- get 메서드의 인수로 키를 전달하면 Map 객체에서 인수로 전달한 키를 갖는 값을 반환
- 존재하지 않으면 `undefined`를 반환

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

console.log(map.get(lee)); // developer
console.log(map.get("key")); // undefined
```

### **5. 요소 존재 여부 확인**

: Map 객체에서 특정 요소가 존재하는지 확인하려면 `Map.prototype.has` 메서드를 사용

- `has` 메서드는 특정 요소의 존재 여부를 나타내는 **불리언 값을 반환**한다.

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

console.log(map.has(lee)); // true
console.log(map.has("key")); // false
```

### **6. 요소 삭제**

: Map 객체에서 요소를 삭제하려면 `Map.prototype.delete` 메서드를 사용

- `delete` 메서드는 삭제 성공 여부를 나타내는 **불리언 값을 반환**

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

map.delete(lee);
console.log(map); // Map(1) { { name: 'Son' } => 'designer' }

// 만약 존재하지 않는 키로 삭제하려하면 에러 없이 무시된다.
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

map.delete("key2");
console.log(map);

/*
    Map(2) 
    {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
*/

// delete 메서드는 연속적으로 호출할 수 없다.
map.delete(lee).delete(son); // TypeError
```

### **7. 요소 일괄 삭제**

: Map 객체에서 요소를 일괄 삭제하려면 `Map.prototype.clear` 메서드를 사용

- clear 메서드는 언제나 `undefined` 를 반환

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

map.clear();
console.log(map); // Map(0) {}
```

### **8. 요소 순회**

: Map 객체에서 요소를 순회하려면 `Map.prototype.forEach` 메서드를 사용

`Array`의 `forEach` 메서드처럼 3개의 인수와 함께 콜백 함수를 전달

- 현재 순회 중인 요소값
- 현재 순회 중인 요소키
- 현재 순회 중인 Map 객체 자체

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

map.forEach((v, k, map) => console.log(v, k, map));

/*
    developer { name: 'Lee' } Map(2) {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
    designer { name: 'Son' } Map(2) {
      { name: 'Lee' } => 'developer',
      { name: 'Son' } => 'designer'
    }
*/
```

### Map 객체 === 이터러블

- `for…of` 문
- 스프레드 문법
- 배열 디스트럭처링

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

// for...of 문
for (const entry of map) {
  console.log(entry);
  // [ { name: 'Lee' }, 'developer' ]
  // [ { name: 'Son' }, 'designer' ]
}

// 스프레드 문법
console.log([...map]);
// [ [ { name: 'Lee' }, 'developer' ], [ { name: 'Son' }, 'designer' ] ]

// 배열 디스트럭처링
const [a, b] = map;
console.log(a, b);
// [ { name: 'Lee' }, 'developer' ] [ { name: 'Son' }, 'designer' ]
```

<aside>
💬

Map 객체는 **이터러블**이면서 동시에 이터레이터인 객체를 반환하는 **메서드**를 제공한다.

</aside>

| **Map 메서드**        | **설명**                                                                            |
| --------------------- | ----------------------------------------------------------------------------------- |
| Map.prototype.keys    | Map 객체에서 요소키를 값으로 갖는 이터러블 / 이터레이터인 객체를 반환한다.          |
| Map.prototype.values  | Map 객체에서 요소값을 값으로 갖는 이터러블 / 이터레이터인 객체를 반환한다.          |
| Map.prototype.entries | Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블 / 이터레이터인 객체를 반환한다. |

```jsx
const map = new Map();

const lee = { name: "Lee" };
const son = { name: "Son" };

map.set(lee, "developer").set(son, "designer");

// Map.prototype.keys 문
for (const key of map.keys()) {
  console.log(key); // { name: 'Lee' } { name: 'Son' }
}

// Map.prototype.values 문
for (const value of map.values()) {
  console.log(value); // developer, designer
}

// Map.prototype.entries 문
for (const entry of map.entries()) {
  console.log(entry);
  // [ { name: 'Lee' }, 'developer' ] [ { name: 'Son' }, 'designer' ]
}
```

→ Map 객체는 요소의 순서에 의미를 갖지 않지만, **Map 객체를 순회하는 순서는 요소가 추가된 순서를 따른다.**
